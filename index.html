<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="https://d3nschot.github.io/crappy-FFT-vocoder/IconCFFTV.png">
    <title>Crappy FFT Vocoder</title>
    <style>
        /* Base text styling */
        label, span, p, h1, h2, h3, h4, h5, h6 {
            color: #ddd;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Bold or strong text */
        strong, b {
            color: #fff;
        }

        /* Headings */
        h1, h2, h3 {
            color: #fff;
            margin: 0.5em 0;
            font-weight: bold;
        }

        /* Subtle/inactive or muted text */
        .text-muted {
            color: #888;
            font-size: 0.9em;
            font-style: italic;
        }

        /* Informational (e.g. helper text) */
        .text-info {
            color: #5ac8fa;
            font-size: 0.95em;
        }

        /* For sliders and live values */
        .value-label {
            margin-left: 6px;
            color: #aaa;
            font-family: monospace;
            font-size: 0.95em;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-height: 100vh;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Header Section */
        .header-section {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #Title {
            font-size: clamp(24px, 5vw, 48px);
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #5ac8fa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        #Title:hover {
            transform: scale(1.05);
        }

        #what_is {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .author {
            color: #aaa;
            font-size: 12px;
        }

        #randomQuote {
            margin-top: 15px;
            padding: 10px;
            background: rgba(90, 200, 250, 0.1);
            border-radius: 8px;
            font-style: italic;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #randomQuote:hover {
            background: rgba(90, 200, 250, 0.2);
        }

        /* Canvas and Visualizer */
        .visualizer-section {
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #visualizer, #filterView {
            max-width: 100%;
            height: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Controls Layout */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(90, 200, 250, 0.3);
            font-size: 18px;
        }

        /* Form Controls */
        .form-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .form-group:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .form-group label {
            min-width: 120px;
            flex-shrink: 0;
            font-weight: 500;
        }

        .form-control {
            flex: 1;
            min-width: 100px;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* File Inputs */
        input[type="file"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
            font-size: 14px;
        }

        input[type="file"]:hover {
            border-color: #5ac8fa;
            background: rgba(90, 200, 250, 0.1);
        }

        input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            margin-right: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        input[type="file"]::file-selector-button:hover {
            background: linear-gradient(135deg, #007acc 0%, #005999 100%);
            transform: scale(1.05);
        }

        /* Select Dropdowns */
        select {
            background: rgba(68, 68, 68, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 120px;
        }

        select:hover, select:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Range Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            min-width: 120px;
            height: 6px;
            background: rgba(68, 68, 68, 0.8);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 15px rgba(90, 200, 250, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
        }

        /* Number Inputs */
        input[type="number"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }

        input[type="number"]:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Text Inputs and Textareas */
        input[type="text"], textarea {
            background: rgba(34, 34, 34, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            width: 100%;
            resize: vertical;
            min-height: 60px;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #5ac8fa;
            box-shadow: 0 0 10px rgba(90, 200, 250, 0.2);
        }

        /* Checkboxes */
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #5ac8fa;
        }

        /* Keyboard Section */
        .keyboard-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .keyboard-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 2px;
        }

        .key-button {
            position: relative;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            text-align: center;
            padding-top: 30px;
        }

        .key-button.white {
            background: #fff;
            color: #000;
            width: 40px;
            height: 120px;
        }

        .key-button.black {
            background: #222;
            color: #ccc;
            width: 25px;
            height: 80px;
            z-index: 2;
            margin-left: -12px;
            margin-right: -12px;
        }

        .key-button:hover {
            transform: translateY(-2px);
        }

        .key-button.active {
            background: #0055ff !important;
            color: #fff !important;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-top: 20px;
        }

        .action-buttons button {
            min-width: 120px;
        }

        /* Drag and Drop */
        .drag-over {
            border-color: #5ac8fa !important;
            background: rgba(90, 200, 250, 0.1) !important;
            transform: scale(1.02);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .form-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .form-group label {
                min-width: unset;
                width: 100%;
                margin-bottom: 5px;
            }

            .form-control {
                width: 100%;
            }

            input[type="range"] {
                min-width: unset;
            }

            .action-buttons {
                flex-direction: column;
            }

            .action-buttons button {
                min-width: unset;
                width: 100%;
            }

            #visualizer {
                width: 100%;
                height: 200px;
            }

            .keyboard-row {
                overflow-x: auto;
                padding-bottom: 10px;
            }

            .key-button.white {
                width: 35px;
                height: 100px;
            }

            .key-button.black {
                width: 20px;
                height: 65px;
                margin-left: -10px;
                margin-right: -10px;
            }
        }

        @media (max-width: 480px) {
            .control-panel {
                padding: 15px;
            }

            #Title {
                font-size: 24px;
            }

            button {
                padding: 12px 16px;
                font-size: 16px;
            }

            .form-group {
                margin-bottom: 20px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1200px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .main-container {
                padding: 20px;
            }
        }

        /* Dark mode enhancements */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            }
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-panel {
            animation: fadeIn 0.6s ease-out;
        }

        /* Utility classes */
        .hidden { display: none !important; }
        .visible { display: block !important; }
        
        /* Separator */
        .separator {
            display: inline-block;
            margin: 0 10px;
            color: #666;
        }

        /* Value display */
        .auto-value-span {
            color: #5ac8fa;
            font-family: monospace;
            font-weight: 500;
        }

        /* Corner GitHub link */
        .github-corner {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            padding: 12px 16px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .github-corner:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #666 0%, #888 100%);
        }

        @media (max-width: 768px) {
            .github-corner {
                bottom: 10px;
                right: 10px;
                padding: 10px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header Section -->
        <div class="header-section">
            <div id="Title">Crappy 4ormulator clone</div>
            <div id="what_is">an 4ormulator clone</div>
            <div class="author">by DX3050/D3nschot</div>
            <div id="randomQuote" style="display: none;">FFT? I only know it as Functional Family Therapy</div>
        </div>

        <!-- Visualizer Section -->
        <div class="visualizer-section">
            <canvas id="visualizer" width="800" height="400"></canvas>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button id="playButton" disabled>Play Audio</button>
            <button id="pauseButton" disabled>Pause Audio</button>
            <button id="stopButton" disabled>Stop Audio</button>
            <button id="downloadButton" disabled>Download Audio</button>
            <button id="reprocessButton" disabled>Reprocess Audio</button>
            <button id="helpButton">Help</button>
        </div>

        <!-- Controls Grid -->
        <div class="controls-grid">
            <!-- Mode Control Panel -->
            <div class="control-panel">
                <h3>Mode & Files</h3>
                
                <div class="form-group">
                    <button id="changeBackButton">Change to FFT Mode</button>
                    <button id="ViewProperties">View Properties</button>
                </div>

                <!--it's swaped, i ain't gonna fix it-->
                <div class="form-group">
                    <label>Audio Input:</label>
                    <input type="file" id="carrierInput" class="form-control" draggable="true">
                </div>

                <div class="form-group">
                    <label>Carrier Input:</label>
                    <input type="file" id="audioInput" class="form-control" draggable="true">
                </div>
            </div>

            <!-- Basic Controls Panel -->
            <div class="control-panel">
                <h3>Basic Controls</h3>
                
                <div class="form-group">
                    <label for="decayType">Decay Type:</label>
                    <select id="decayType" class="form-control">
                        <option value="1">RMS</option>
                        <option value="2">Peak</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="release">Release:</label>
                    <input type="range" id="release" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="pitch">Pitch:</label>
                    <input type="range" id="pitch" value="0" min="-24" max="24" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BandShift">Shift:</label>
                    <input type="range" id="BandShift" value="0" min="-100" max="100" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FreqFlip">Flip:</label>
                    <input type="checkbox" id="FreqFlip">
                </div>
            </div>

            <!-- FFT Controls Panel -->
            <div id="FFTcontrols" class="control-panel hidden">
                <h3>FFT Vocoder Settings</h3>
                
                <div class="form-group">
                    <label for="BandBreak">Band Break:</label>
                    <input type="checkbox" id="BandBreak">
                </div>

                <div class="form-group">
                    <label for="BR_voc_Type">Broken vocoder:</label>
                    <select id="BR_voc_Type" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">Triangle</option>
                        <option value="5">Square</option>
                        <option value="6">Sawtooth</option>
                        <option value="11">semi-sine</option>
                        <option value="2">double sine</option>
                        <option value="7">triple sine</option>
                        <option value="8">half sine</option>
                        <option value="10">sine squared</option>
                        <option value="14">sine cubed</option>
                        <option value="3">2 sine</option>
                        <option value="4">3 sine</option>
                        <option value="9">squared sine</option>
                        <option value="12">IDK</option>
                        <option value="13">Noise</option>
                        <option value="15">sine sine</option>
                        <option value="16">harmonics sq</option>
                        <option value="17">harmonics saw</option>
                        <option value="18">Bitwise</option>
                        <option value="19">Floor</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="BR_out">Broken vocoder out:</label>
                    <select id="BR_out" class="form-control">
                        <option value="1">Both</option>
                        <option value="2">Input</option>
                        <option value="3">Carrier</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="volume">Volume:</label>
                    <input type="range" id="volume" value="1" min="0" max="2" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="clamp_output">Clamp out:</label>
                    <select id="clamp_output" class="form-control">
                        <option value="0">Off</option>
                        <option value="1">On</option>
                        <option value="2">individual</option>
                        <!--option value="4">individual (soft)</option-->
                    </select>
                </div>

                <div class="form-group">
                    <label for="threshold">Clamp Threshold:</label>
                    <input type="range" id="threshold" value="1" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="divbands">Divide bands:</label>
                    <input type="range" id="divbands" value="1" min="1" max="64" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FFTsize">FFT size:</label>
                    <input type="range" id="FFTsize" value="10" min="2" max="14" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassBoost">Bass Boost:</label>
                    <input type="range" id="BassBoost" value="0" min="-4" max="4" step=".01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassCurve">Bass Curve:</label>
                    <select id="BassCurve" class="form-control">
                        <option value="0">+1</option>
                        <option value="1">x/i</option>
                        <option value="2">quadratic</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="EQType">Norm EQ type:</label>
                    <select id="EQType" class="form-control">
                        <option value="0">original</option>
                        <option value="1">sin</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="steps">Steps:</label>
                    <input type="range" id="steps" value="0" min="0" max="16" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="RoundType">Round Type:</label>
                    <select id="RoundType" class="form-control">
                        <option value="0">Floor</option>
                        <option value="1">Round</option>
                        <option value="2">Ceil</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="SoundGoodizer">SoundGoodizer:</label>
                    <input type="range" id="SoundGoodizer" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="simpleChorus">Simple Chorus:</label>
                    <select id="simpleChorus" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">sin</option>
                        <option value="2">cos</option>
                        <option value="3">asin</option>
                        <option value="4">acos</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="speedType">Speed:</label>
                    <select id="speedType" class="form-control">
                        <option value="0">Auto</option>
                        <option value="1">file length</option>
                        <option value="2">user</option>
                    </select>
                </div>

                <div class="form-group hidden">
                    <label for="userSpeed">Speed:</label>
                    <input type="range" id="userSpeed" value="1" min="0" max="100" step="0.01" class="form-control">
                </div>
            </div>

            <!-- Analog Controls Panel -->
            <div id="analogControls" class="control-panel hidden">
                <h3>Analog Vocoder Settings</h3>

                <div class="form-group">
                    <label for="AutoUpdateFilters">Auto-update Filters:</label>
                    <input type="checkbox" id="AutoUpdateFilters" checked>
                    <button id="ManualStudyFilters" class="hidden">Update Study Filters</button>
                </div>

                <div class="visualizer-section">
                    <canvas id="filterView" width="700" height="100"></canvas>
                </div>

                <div class="form-group">
                    <label for="TotalBands">Total Bands:</label>
                    <input type="range" id="TotalBands" value="40" min="1" max="1024" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance">Resonance:</label>
                    <input type="range" id="Resonance" value=".92" min="0" max=".9999" step="0.0001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BPwidth">Bandpass Width:</label>
                    <input type="range" id="BPwidth" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Volboost">Volume Boost:</label>
                    <input type="range" id="Volboost" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="DBperOct">dB per Octave: 12</label>
                    <input type="range" id="DBperOct" value="2" min="1" max="8" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Alt_BP">Alt Bandpass:</label>
                    <select id="Alt_BP" class="form-control">
                        <option value="0">Default</option>
                        <option value="1">normal</option>
                        <option value="2">weird</option>
                        <option value="3">fast</option>
                        <option value="4">3FLT</option>
                        <option value="5">ApLp</option>
                        <option value="6">True Cascade (slow)</option>
                        <option value="7">True Cascade2 (slow)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="decayByFreq">Decay by Frequency:</label>
                    <select id="decayByFreq" class="form-control">
                        <option value="0">fixed</option>
                        <option value="1">High priority</option>
                        <option value="2">Low priority</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="freqCurve">Frequency Curve:</lebel>
                    <select id="freqCurve" class="form-control">
                        <option value="0">linear</option>
                        <option value="1">logarithmic</option>
                        <option value="2">exponential</option>
                        <option value="3">exponential (base2)</option>
                        <option value="4">squared</option>
                        <option value="5">Audaciy aproxinarion</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="UseResBasedOnDistance">Use Resonance Based on Distance (Audaciy aproxinarion):</lebel>
                    <input type="checkbox" id="UseResBasedOnDistance">
                </div>

                <!--adds -->
                <div class="form-group">
                    <label for="addLPtoLowEnd">Add LP to Low End:</label>
                    <input type="checkbox" id="addLPtoLowEnd" checked>
                </div>
            </div>

            <!-- 4ormulator Controls Panel -->
            <div id="4ormClone" class="control-panel hidden">
                <h3>4ormulator Settings</h3>

                <div class="form-group">
                    <label for="Ag">Base frequency:</label>
                    <input type="range" id="Ag" value=".125" min="0" max="1" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance4orm">Resonance:</label>
                    <input type="range" id="Resonance4orm" value="0.999" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormFilterType">Filter Type:</label>
                    <select id="4ormFilterType" class="form-control">
                        <option value="0">ApLp</option>
                        <option value="1">Lp12</option>
                        <option value="2">BP12</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="UseArrLength">Use Array Length:</label>
                    <input type="checkbox" id="UseArrLength">
                </div>

                <div class="form-group">
                    <label for="MaxHarm">Max Harmonics:</label>
                    <input type="range" id="MaxHarm" value="16" min="1" max="1000" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormVolume">Volume:</label>
                    <input type="range" id="4ormVolume" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="use_gen">Use generator:</label>
                    <input type="checkbox" id="use_gen">
                </div>

                <div class="form-group">
                    <label for="gen_type">Generator (filtered):</label>
                    <select id="gen_type" class="form-control">
                        <option value="0">Input 2</option>
                        <option value="1">sine</option>
                        <option value="2">triangle</option>
                        <option value="3">sawtooth</option>
                        <option value="4">PWM</option>
                        <option value="5">noise</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="PWMwidth">PWM width:</label>
                    <input type="range" id="PWMwidth" value="0.5" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="resonance2">Resonance 2:</label>
                    <input type="range" id="resonance2" value="0.99" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Harmonics">Offsets (Array only):</label>
                    <textarea id="Harmonics" class="form-control">[-5,2,7,10].map((i)=&gt;2**((i+3)/12)*Math.PI/128/HZ*2048*440)</textarea>
                </div>

                <!-- Harmonics Buttons -->
                <div class="keyboard-section">
                    <div id="harm">
                        <h3>Harmonics</h3>
                        <!-- This will be populated with buttons H1-H12 -->
                    </div>
                </div>

                <!-- Easy Mode Keyboard -->
                <div class="keyboard-section">
                    <div id="easyKeyboard">
                        <h3>Easy Mode Keyboard</h3>
                        <div class="keyboard-container" id="keyboardContainer">
                            <!-- Keyboard will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Processing Controls Panel -->
            <div class="control-panel">
                <h3>Processing</h3>
                
                <div class="form-group">
                    <label for="iterations">Iterations:</label>
                    <input type="number" id="iterations" value="1" min="1" class="form-control">
                    <small class="text-muted">It may get loud (or not, I don't recommend using this with long audio files)</small>
                </div>
            </div>
        </div>

        <!-- Help Popup -->
        <div id="helpPopup" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; display: flex; align-items: center; justify-content: center;">
            <div style="background: #333; padding: 30px; border-radius: 15px; color: #fff; max-width: 90vw; max-height: 90vh; overflow-y: auto; width: 600px;">
                <h2>Help</h2>
                <p>Welcome to the Crappy FFT Vocoder!</p>
                <p>This is a Fast Fourier Transform based vocoder that uses a lot of math to process audio files.</p>
                <p><strong>What is FFT?</strong></p>
                <p>The Fast Fourier Transform (FFT) is an algorithm that quickly converts a signal from its original time domain into a frequency domain. This allows the vocoder to analyze and manipulate the different frequency components of audio, enabling effects like filtering, modulation, and vocoding.</p>
                <p>Learn more about the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank" rel="noopener noreferrer" style="color:#4af;">Fast Fourier Transform (FFT)</a> on Wikipedia.</p>
                <p>This is why it's taking so long to process</p>
                <p>Fun fact: dividing the FFT index by 2 will multiply the pitch by 2, multiplying it will do the opposite</p>
                <p>Here are some instructions and information to get you started:</p>
                
                <h3>Basic Controls:</h3>
                <ul>
                    <li><strong>Decay Type:</strong> Choose between RMS and Peak for the decay type.</li>
                    <li><strong>Release:</strong> Adjust the release time for the vocoder (0 is no release and 1 is max release).</li>
                    <li><strong>Pitch:</strong> Adjust the pitch of the vocoded audio (input only).</li>
                    <li><strong>Shift:</strong> Shifts the FFT bands of the vocoded audio (input only)</li>
                </ul>

                <h3>FFT Vocoder Mode:</h3>
                <ul>
                    <li><strong>Band Break:</strong> This shifts the bands a couple of times</li>
                    <li><strong>Flip:</strong> Self explanatory, it flips the bands</li>
                    <li><strong>Broken Vocoder Type:</strong> Select the type of broken vocoder effect.</li>
                    <li><strong>Volume:</strong> Adjust the volume of the output audio.</li>
                    <li><strong>FFT Size:</strong> Adjust the size of the FFT used for processing.</li>
                </ul>

                <h3>Analog Vocoder Mode:</h3>
                <ul>
                    <li><strong>Total Bands:</strong> Sets the number of filter bands (more bands = more detailed vocoding).</li>
                    <li><strong>Resonance:</strong> Controls the sharpness of the bandpass filters.</li>
                    <li><strong>Volume Boost:</strong> Increases the output volume after processing.</li>
                </ul>

                <h3>4ormulator Mode:</h3>
                <ul>
                    <li><strong>Base frequency:</strong> Sets the base frequency of Offsets.</li>
                    <li><strong>Max Harmonics:</strong> Sets the maximum amount of harmonics</li>
                    <li><strong>Offsets:</strong> Sets the offset (shift) for the filter.</li>
                </ul>

                <div style="margin-top: 20px; font-size: 12px; color: #aaa;">
                    Version 1.2<br>
                    Made by D3nschot (DX3050)
                </div>
                
                <button id="closeHelpButton" style="margin-top: 20px;">Close</button>
            </div>
        </div>
    </div>

    <!-- GitHub Corner Link -->
    <a href="https://github.com/D3nschot/crappy-FFT-vocoder" class="github-corner">Fork me on GitHub :)</a>

    <script>
        // Quote system
        const quotes = [
            "FFT? I only know it as Functional Family Therapy",
            "I love math -D3nschot",
            "I love math -DX3050",
            "probably gonna make Crappy Analog Voc- oh wait, I already did",
            "A fast Fourier transform (FFT) is an algorithm that computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).",
            "Don't we love how long it takes to process audio files? :D",
            "new ui? because why not?"
        ];

        document.getElementById('Title').addEventListener('click', function() {
            const quoteEl = document.getElementById('randomQuote');
            quoteEl.style.display = 'block';
            quoteEl.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        document.getElementById('randomQuote').addEventListener('click', function() {
            this.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        // Initialize quote
        document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];

        // Auto-value span system for sliders
        document.addEventListener('DOMContentLoaded', function() {
            const skipIds = ['FFTsize', 'DBperOct'];
            const offWhenZero = ['steps', 'SoundGoodizer'];

            document.querySelectorAll('input[type="range"]').forEach(slider => {
                let label = document.querySelector(`label[for="${slider.id}"]`);
                if (!label) return;

                let span = label.parentNode.querySelector(`.auto-value-span[data-for="${slider.id}"]`);
                if (!span) {
                    span = document.createElement('span');
                    span.className = 'auto-value-span value-label';
                    span.dataset.for = slider.id;
                    label.parentNode.appendChild(span);
                }

                // Add click-to-edit functionality
                if (!skipIds.includes(slider.id)) {
                    span.style.cursor = 'pointer';
                    span.title = 'Click to edit value';
                    span.addEventListener('click', function(e) {
                        if (span.querySelector('input')) return;
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.value = slider.value;
                        input.style.width = '60px';
                        input.style.fontSize = 'inherit';
                        input.style.background = 'rgba(68, 68, 68, 0.8)';
                        input.style.color = '#fff';
                        input.style.border = '1px solid #5ac8fa';
                        input.style.borderRadius = '4px';
                        input.style.padding = '2px 4px';
                        
                        span.textContent = '';
                        span.appendChild(input);
                        input.focus();
                        input.select();
                        
                        function finishEdit() {
                            let val = input.value;
                            if (slider.min !== '') val = Math.max(Number(slider.min), val);
                            if (slider.max !== '') val = Math.min(Number(slider.max), val);
                            slider.value = val;
                            slider.dispatchEvent(new Event('input'));
                            updateSpan();
                        }
                        
                        input.addEventListener('blur', finishEdit);
                        input.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') finishEdit();
                            else if (e.key === 'Escape') updateSpan();
                        });
                    });
                }

                function updateSpan() {
                    let val = slider.value;
                    if (offWhenZero.includes(slider.id) && (val === "0" || val === 0)) {
                        span.textContent = ' OFF';
                    } else {
                        if (skipIds.includes(slider.id)) {
                            switch (slider.id) {
                                case 'FFTsize':
                                    span.textContent = ' ' + (Math.pow(2, val)).toFixed(0);
                                    break;
                                case 'DBperOct':
                                    span.textContent = ' 12';
                                    break;
                                default:
                                    span.textContent = '';
                            }
                        } else {
                            span.textContent = ' ' + val;
                        }
                    }
                }

                updateSpan();
                slider.addEventListener('input', updateSpan);
            });
        });

        // Mode switching system
        let Vmode = 0; // Start with 4ormulator mode

        function SetUpUI() {
            const controls = ['FFTcontrols', 'analogControls', '4ormClone'];
            const configs = [
                { title: 'Crappy FFT Vocoder', whatIs: 'a Fast Fourier Transform vocoder', button: 'Change to Analog Mode', show: 0 },
                { title: 'Crappy Analog Vocoder', whatIs: 'an Analog Vocoder', button: 'Change to 4ormulator Mode', show: 1 },
                { title: 'Crappy 4ormulator clone', whatIs: 'an 4ormulator clone', button: 'Change to FFT Mode', show: 2 }
            ];

            // Hide all controls
            controls.forEach(id => document.getElementById(id).classList.add('hidden'));
            
            // Show current mode
            const config = configs[Vmode];
            document.getElementById('Title').textContent = config.title;
            document.getElementById('what_is').textContent = config.whatIs;
            document.getElementById('changeBackButton').textContent = config.button;
            document.getElementById(controls[config.show]).classList.remove('hidden');
        }

        document.getElementById('changeBackButton').addEventListener('click', function() {
            Vmode = ((Number(Vmode) || 0) + 1) % 3;
            SetUpUI();
            
            const params = new URLSearchParams(window.location.search);
            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        });

        // Speed type visibility control
        document.getElementById('speedType').addEventListener('change', function(event) {
            const userSpeedGroup = document.querySelector('label[for="userSpeed"]').parentNode;
            if (event.target.value == '2') {
                userSpeedGroup.classList.remove('hidden');
            } else {
                userSpeedGroup.classList.add('hidden');
            }
        });

        // Auto-update filters toggle
        document.addEventListener('DOMContentLoaded', () => {
            const autoUpdateCheckbox = document.getElementById('AutoUpdateFilters');
            const manualStudyButton = document.getElementById('ManualStudyFilters');

            autoUpdateCheckbox.addEventListener('change', () => {
                if (autoUpdateCheckbox.checked) {
                    manualStudyButton.classList.add('hidden');
                } else {
                    manualStudyButton.classList.remove('hidden');
                }
            });

            manualStudyButton.addEventListener('click', () => {
                if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
            });

            ['TotalBands', 'Resonance', 'DBperOct', 'BPwidth', 'Alt_BP', 'AutoUpdateFilters'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    const handler = () => {
                        const autoUpdate = document.getElementById('AutoUpdateFilters');
                        if (!autoUpdate || autoUpdate.checked) {
                            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
                        }
                    };
                    el.addEventListener('input', handler);
                    el.addEventListener('change', handler);
                }
            });

            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
        });

        // Harmonics textarea tab support
        document.addEventListener('DOMContentLoaded', function() {
            const harmonicsTextarea = document.getElementById('Harmonics');
            if (harmonicsTextarea) {
                harmonicsTextarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = this.selectionStart;
                        const end = this.selectionEnd;
                        this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
                        this.selectionStart = this.selectionEnd = start + 1;
                    }
                });
            }
        });

        // Harmonic buttons system
        function createHarmonicButtons() {
            const harmDiv = document.getElementById('harm');
            if (!harmDiv) return;
            
            window.harmString = window.harmString || [];
            
            Array.from(harmDiv.querySelectorAll('button.harm-btn')).forEach(btn => btn.remove());
            
            for (let i = 1; i <= 12; i++) {
                const btn = document.createElement('button');
                btn.textContent = `H${i}`;
                btn.className = 'harm-btn';
                btn.dataset.harmonic = i;
                
                if (window.harmString.includes(i)) {
                    btn.style.backgroundColor = "#0055ff";
                    btn.style.color = "#fff";
                }
                
                btn.addEventListener("click", () => {
                    const idx = window.harmString.indexOf(i);
                    if (idx !== -1) {
                        window.harmString.splice(idx, 1);
                        btn.style.backgroundColor = "";
                        btn.style.color = "";
                    } else {
                        window.harmString.push(i);
                        btn.style.backgroundColor = "#0055ff";
                        btn.style.color = "#fff";
                    }
                    if (typeof updateHarmonicsText === 'function') updateHarmonicsText();
                });
                
                harmDiv.appendChild(btn);
            }
        }

        // Piano keyboard system
        const semitoneNames = [
            { name: 'C', black: false },
            { name: 'C#', black: true },
            { name: 'D', black: false },
            { name: 'D#', black: true },
            { name: 'E', black: false },
            { name: 'F', black: false },
            { name: 'F#', black: true },
            { name: 'G', black: false },
            { name: 'G#', black: true },
            { name: 'A', black: false },
            { name: 'A#', black: true },
            { name: 'B', black: false },
        ];

        const heldNotes = new Set();
        const keyboard = document.getElementById("easyKeyboard");
        const totalKeys = 60;
        const base = -24;

        function updateHarmonicsText() {
            const harmonicsArea = document.getElementById("Harmonics");
            if (!harmonicsArea) return;

            const arr = Array.from(heldNotes).sort((a, b) => a - b);
            const harmArr = (window.harmString || []).slice().sort((a, b) => a - b);
            const arrString = `[${arr.join(",")}]`;
            const harmString = `[${harmArr.join(",")}]`;
            const mapFunctionString = `.flatMap((i)=>{\n    f=2**((i+3)/12)*Math.PI/128/HZ*2048*440;\n    return ${harmString}.map(a=>a*f);\n})`;
            harmonicsArea.value = arrString + mapFunctionString;
        }

        function renderKeyboard() {
            keyboard.innerHTML = '';
            
            let split = keyboard.offsetWidth < 600 || window.innerWidth < 700;
            let keysPerRow = split ? 12 : 24;
            
            for (let k = 0; k < totalKeys; k++) {
                if (k % keysPerRow === 0) {
                    var rowDiv = document.createElement("div");
                    rowDiv.className = "keyboard-row";
                    keyboard.appendChild(rowDiv);
                }

                const intVal = k + base;
                const name = semitoneNames[k % 12];
                const isBlack = name.black;

                const btn = document.createElement("button");
                btn.className = `key-button ${isBlack ? 'black' : 'white'}`;
                btn.dataset.note = intVal;
                if (isBlack) {
                    btn.style.marginLeft = "-21px";
                    btn.style.marginRight = "-21px";
                } else {
                    btn.style.marginLeft = "0";
                    btn.style.marginRight = "0";
                }


                if (heldNotes.has(intVal)) {
                    btn.classList.add('active');
                }

                btn.addEventListener("click", () => {
                    if (heldNotes.has(intVal)) {
                        heldNotes.delete(intVal);
                        btn.classList.remove('active');
                    } else {
                        heldNotes.add(intVal);
                        btn.classList.add('active');
                    }
                    updateHarmonicsText();
                });

                rowDiv.appendChild(btn);
            }
        }

        // Drag and drop system
        let draggingInputId = null;

        ['carrierInput', 'audioInput'].forEach(id => {
            const input = document.getElementById(id);
            if (!input) return;

            input.setAttribute('draggable', 'true');

            input.addEventListener('dragstart', e => {
                draggingInputId = id;
            });

            input.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                input.classList.add('drag-over');
            });

            input.addEventListener('dragleave', e => {
                input.classList.remove('drag-over');
            });

            input.addEventListener('drop', e => {
                e.preventDefault();
                input.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    input.files = files;
                    input.dispatchEvent(new Event('change'));
                }
            });
        });

        // URL parameter management
        function updateURLParams() {
            const params = new URLSearchParams();

            document.querySelectorAll('input, select, textarea').forEach(input => {
                const id = input.id;
                if (!id || input.type === 'file') return;

                if (input.type === 'checkbox') {
                    params.set(id, input.checked ? 'true' : 'false');
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    const encoded = btoa(unescape(encodeURIComponent(input.value)));
                    params.set(id, `base64~${encoded}`);
                } else {
                    params.set(id, input.value);
                }
            });

            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        }

        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);

            params.forEach((value, key) => {
                if (key === 'Vmode') {
                    window.Vmode = parseInt(value) || 0;
                    return;
                }

                const input = document.getElementById(key);
                if (!input) return;

                if (input.type === 'checkbox') {
                    input.checked = value === 'true';
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    if (value.startsWith('base64~')) {
                        try {
                            const b64 = value.slice(7);
                            input.value = decodeURIComponent(escape(atob(b64)));
                        } catch (e) {
                            input.value = '';
                        }
                    } else {
                        input.value = value;
                    }
                } else {
                    input.value = value;
                }

                input.dispatchEvent(new Event('input'));
            });
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            // Attach URL updating to all inputs
            document.querySelectorAll('input[type="range"], input[type="number"], input[type="checkbox"], select, textarea').forEach(input => {
                input.addEventListener('input', updateURLParams);
                input.addEventListener('change', updateURLParams);
            });

            loadStateFromURL();
            SetUpUI();
            createHarmonicButtons();
            renderKeyboard();
            updateHarmonicsText();

            // Handle window resize for keyboard
            window.addEventListener('resize', renderKeyboard);
        });

        // Help popup system
        document.getElementById('helpButton').addEventListener('click', function() {
            // Show the existing help popup
            document.getElementById('helpPopup').classList.remove('hidden');
        });

        // Close help popup
        document.getElementById('closeHelpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').classList.add('hidden');
        });

        // Function to clean up the URL by removing disallowed characters
            function CleanUpLink() {
                const DisAllowsCharacters = '(|^*%$#@!<>,/\\:\';\"{}[]~+")';
                const regex = new RegExp('[' + DisAllowsCharacters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']', 'g');
            
                const url = window.location.href;
                const [base, query] = url.split('?');
            
                if (query) {
                    const cleanedQuery = query.replace(regex, '');
                    const newUrl = `${base}?${cleanedQuery}`;
                    window.history.replaceState({}, '', newUrl);
                }
            }
            
            function handleDragOver(event) {
                event.preventDefault();
                event.target.classList.add('drag-over');
                event.target.classList.add('expanded');
            }

            function handleDragLeave(event) {
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
                const fileInput = event.target;
                const files = event.dataTransfer.files;
                fileInput.files = files;

                // Trigger change event manually
                const changeEvent = new Event('change');
                fileInput.dispatchEvent(changeEvent);
            }

            document.getElementById('carrierInput').addEventListener('dragover', handleDragOver);
            document.getElementById('carrierInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('carrierInput').addEventListener('drop', handleDrop);

            document.getElementById('audioInput').addEventListener('dragover', handleDragOver);
            document.getElementById('audioInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('audioInput').addEventListener('drop', handleDrop);

            document.getElementById('speedType').addEventListener('change', function(event) {
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                if (event.target.value == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            });

            const inputs='input[type="range"], input[type="number"], input[type="checkbox"], select'

            // Initialize the visibility of the speed slider based on the current selection
            document.getElementById('speedType').dispatchEvent(new Event('change'));

            // --- Cookie helpers ---
            function savePresetCookie(presetName, data, days = 30) {
                const json = JSON.stringify(data);
                const encoded = encodeURIComponent(json);
                let expires = "";
                if (days) {
                    const date = new Date();
                    date.setTime(date.getTime() + (days*24*60*60*1000));
                    expires = "; expires=" + date.toUTCString();
                }
                document.cookie = presetName + "=" + encoded + expires + "; path=/";
            }

            function loadPresetCookie(presetName) {
                const nameEQ = presetName + "=";
                const ca = document.cookie.split(';');
                for(let i=0; i < ca.length; i++) {
                    let c = ca[i].trim();
                    if (c.indexOf(nameEQ) === 0) {
                        try {
                            return JSON.parse(decodeURIComponent(c.substring(nameEQ.length)));
                        } catch (e) {
                            console.error("Invalid preset cookie", e);
                        }
                    }
                }
                return null;
            }

            function listPresets() {
                return document.cookie.split(";").map(c => c.trim().split("=")[0]);
            }

            // Collect current settings from inputs

            // Collect current settings from inputs
            function exportCurrentSettings() {
                const inputs = document.querySelectorAll('input, select'); // query inside function
                const settings = {};
                inputs.forEach(input => {
                    if (input.type === 'checkbox') {
                        settings[input.id] = input.checked;
                    } else {
                        settings[input.id] = input.value;
                    }
                });
                settings.Mode = Vmode; // keep as number: 0, 1, 2
                return settings;
            }

            // Apply settings back to inputs
            function importSettings(obj) {
                Object.keys(obj).forEach(key => {
                    if (key === "Mode" || key === "Vmode") {
                        Vmode = obj[key];
                        return;
                    }
                    const el = document.getElementById(key);
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = obj[key] === true || obj[key] === "true";
                        } else {
                            el.value = obj[key];
                        }
                        el.dispatchEvent(new Event('input'));
                        el.dispatchEvent(new Event('change'));
                    }
                });
            }


            // --- Your existing code with preset integration ---
            document.getElementById('ViewProperties').addEventListener('click', function() {
                const inputs = document.querySelectorAll('input, select');
                const fileInputs = document.querySelectorAll('input[type="file"]');
                const properties = [];
                const fileInfo = [];



                // Collect input values
                inputs.forEach(input => {
                    if (input.type === 'range' || input.type === 'number' || input.type === 'checkbox' || input.tagName === 'SELECT') {
                        properties.push(`${input.id}: ${input.value}`);
                    }
                });
                properties.push(`Mode: ${['FFT Mode','Analog Mode','4orm Mode'][Vmode]}`); // Add Vmode as a property
                // Collect file input details
                fileInputs.forEach(fileInput => {
                    const file = fileInput.files[0];
                    if (file) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            audioContext.decodeAudioData(e.target.result, function(buffer) {
                                const duration = buffer.duration.toFixed(2);
                                fileInfo.push(`
                                    <h2>${file.name}</h2>
                                    <li>Size: ${(file.size / 1024).toFixed(2)} KB</li>
                                    <li>Duration: ${Math.floor(duration / 60)}:${Math.floor(duration % 60).toString().padStart(2, '0')}:${Math.floor((duration % 1) * 1000).toString().padStart(3, '0')} (${duration} seconds)</li>
                                    <li>Sample Rate: ${buffer.sampleRate} Hz</li>
                                    <li>Channels: ${buffer.numberOfChannels}</li>
                                    <li>Codec: ${(co=file.type.split('/')[1]|| 'failed to get Codec') , file.type === 'audio/wav' || file.type.includes('pcm') ? co + ` (PCM ${buffer.getChannelData(0).BYTES_PER_ELEMENT * 8})`: co}</li>
                                `);

                                // Update the popup content dynamically
                                const popup = document.querySelector('div[style*="z-index: 1000"]');
                                if (popup) {
                                    popup.innerHTML = `
                                        <h1>Properties</h1>
                                        ${fileInfo.join('')}
                                        <br>
                                        <h1>Input Values</h1>
                                        <ul>${properties.map(prop => `<li>${prop}</li>`).join('')}</ul>
                                        <br>
                                        <div>
                                            <button id="ExportJSON">Export JSON</button> |
                                            <button id="ImportJSON">Import JSON</button> 
                                            <br>
                                            note that this uses Cookies/localStorage
                                            <br>
                                            <button id="SavePreset">Save Preset</button> |
                                            <button id="LoadPreset">Load Preset</button> 
                                            <br>
                                            <button id="closePropertiesButton">Close</button>
                                        </div>
                                    `;

                                    // Reattach the close button event listener
                                    document.getElementById('closePropertiesButton').addEventListener('click', function() {
                                        document.body.removeChild(popup);
                                    });

                                    // Add ExportJSON functionality
                                    document.getElementById('ExportJSON').addEventListener('click', function() {
                                        const inputs = document.querySelectorAll('input, select'); // query inside the function
                                        const jsonObject = {};

                                        inputs.forEach(input => {
                                            if (input.type === 'checkbox') {
                                                jsonObject[input.id] = input.checked; // boolean
                                            } else {
                                                jsonObject[input.id] = input.value;   // string
                                            }
                                        });

                                        // Numeric Mode
                                        jsonObject.Mode = Vmode; // 0, 1, 2

                                        const jsonBlob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                                        const jsonUrl = URL.createObjectURL(jsonBlob);
                                        const downloadLink = document.createElement('a');
                                        downloadLink.href = jsonUrl;
                                        downloadLink.download = 'properties.json';
                                        downloadLink.click();
                                        URL.revokeObjectURL(jsonUrl);
                                    });

                                    // Import JSON
                                    document.getElementById('ImportJSON').addEventListener('click', function() {
                                        const input = document.createElement('input');
                                        input.type = 'file';
                                        input.accept = 'application/json';
                                        input.addEventListener('change', function(event) {
                                            const file = event.target.files[0];
                                            if (!file) return;

                                            const reader = new FileReader();
                                            reader.onload = function(e) {
                                                try {
                                                    const jsonObject = JSON.parse(e.target.result);
                                                    Object.keys(jsonObject).forEach(key => {
                                                        if (key === 'Mode' || key === 'Vmode') {
                                                            window.Vmode = jsonObject[key]; // numeric mode
                                                            return;
                                                        }
                                                        const inputElement = document.getElementById(key);
                                                        if (inputElement) {
                                                            if (inputElement.type === 'checkbox') {
                                                                inputElement.checked = jsonObject[key] === true;
                                                            } else {
                                                                inputElement.value = jsonObject[key];
                                                            }
                                                            inputElement.dispatchEvent(new Event('input'));
                                                            inputElement.dispatchEvent(new Event('change'));
                                                        }
                                                    });
                                                    alert('Properties imported successfully!');
                                                } catch (error) {
                                                    alert('Invalid JSON file. Please select a valid properties file.');
                                                }
                                            };
                                            reader.readAsText(file);
                                        });
                                        input.click();
                                    });

                                }
                            });
                        };
                        reader.readAsArrayBuffer(file);
                    } else {
                        fileInfo.push(`
                            <h2>${fileInput.id}</h2>
                            <li>No file selected</li>
                        `);
                    }
                });

                const popup = document.createElement('div');
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = '#333';
                popup.style.color = '#fff';
                popup.style.padding = '20px';
                popup.style.borderRadius = '10px';
                popup.style.width = '90vw';
                popup.style.maxWidth = '600px';
                popup.style.minWidth = '220px';
                popup.style.maxHeight = '80vh';
                popup.style.overflowY = 'auto';
                popup.style.zIndex = '1000';

                // Build popup content
                popup.innerHTML = `
                    <h2>Properties</h2>
                    ${fileInfo.join('')}
                    <h2>Input Values</h2>
                    <ul>${properties.map(p => `<li>${p}</li>`).join('')}</ul>
                    <br>
                    <div>
                        <button id="ExportJSON">Export JSON</button> |
                        <button id="ImportJSON">Import JSON</button> 
                        <br>
                        note that this uses Cookies/localStorage
                        <br>
                        <button id="SavePreset">Save Preset</button> |
                        <button id="LoadPreset">Load Preset</button> 
                        <br>
                        <button id="closePropertiesButton">Close</button>
                    </div>
                `;

                document.body.appendChild(popup);

                // Close button
                document.getElementById('closePropertiesButton').addEventListener('click', () => {
                    document.body.removeChild(popup);
                });

                // Export JSON
                document.getElementById('ExportJSON').addEventListener('click', () => {
                    const jsonObject = {};
                    inputs.forEach(input => {
                        if (input.type === 'range' || input.type === 'number' || input.tagName === 'SELECT') {
                            jsonObject[input.id] = input.value;
                        } else if (input.type === 'checkbox') {
                            jsonObject[input.id] = input.checked;
                        }
                    });
                    jsonObject.Mode = Vmode;
                    const blob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = "properties.json";
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // Import JSON
                document.getElementById('ImportJSON').addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    input.onchange = e => {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = e => {
                            try {
                                const obj = JSON.parse(e.target.result);
                                applyPreset(obj);
                                alert("Imported successfully");
                            } catch {
                                alert("Invalid JSON");
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                });

                // Load presets from cookie/localStorage
                function getPresets() {
                    const data = localStorage.getItem("presets");
                    return data ? JSON.parse(data) : {};
                }

                    console.log("Loaded presets:", localStorage.getItem("presets"));

                // Save presets to storage
                function savePresets(presets) {
                    localStorage.setItem("presets", JSON.stringify(presets));
                    updatePresetList();
                }

                function updatePresetList() {
                    const presets = getPresets();
                    const presetList = document.getElementById("presetList");
                    if (!presetList) return; // <-- prevents null errors

                    presetList.innerHTML = `<option value="">-- Select a preset --</option>`;
                    for (const key in presets) {
                        const opt = document.createElement("option");
                        opt.value = key;
                        opt.textContent = key;
                        presetList.appendChild(opt);
                    }
                }


                // Save preset
                document.getElementById("SavePreset").addEventListener("click", () => {
                    const name = prompt("Enter a preset name:");
                    if (!name) return;
                    const presets = getPresets();
                    presets[name] = exportCurrentSettings(); // <-- replace with your export function
                    savePresets(presets);
                });

                // Load preset
                document.getElementById("LoadPreset").addEventListener("click", () => {
                    // Check if the dropdown already exists
                    if (!document.getElementById("presetList")) {
                        const container = document.createElement("div");
                        container.style.marginTop = "10px";
                        container.innerHTML = `
                            <label for="presetList">Presets: </label>
                            <select id="presetList">
                                <option value="">-- Select a preset --</option>
                            </select>
                            <button id="ConfirmLoadPreset">Load</button>
                        `;
                        popup.appendChild(container);

                        updatePresetList(); // ✅ safe now, dropdown exists

                        // Confirm load action
                        document.getElementById("ConfirmLoadPreset").addEventListener("click", () => {
                            const presetList = document.getElementById("presetList");
                            const name = presetList.value;
                            if (!name) {
                                alert("Please select a preset from the list.");
                                return;
                            }
                            const presets = getPresets();
                            if (presets[name]) {
                                importSettings(presets[name]);
                                alert(`Preset "${name}" loaded successfully.`);
                            }
                        });
                    }
                });



                // Initialize dropdown on page load
                updatePresetList();


                // Apply preset to inputs
                function applyPreset(obj) {
                    Object.keys(obj).forEach(key => {
                        if (key === "Mode" || key === "Vmode") {
                            Vmode = obj[key];
                            return;
                        }
                        const el = document.getElementById(key);
                        if (el) {
                            if (el.type === 'checkbox') {
                                el.checked = obj[key] === true || obj[key] === "true";
                            } else {
                                el.value = obj[key];
                            }
                            el.dispatchEvent(new Event('input'));
                            el.dispatchEvent(new Event('change'));
                        }
                    });
                }
            });

        </script>
    <script>
        let audioContext, analyser, source, processedBuffer, audioData, carrierBuffer;
        let loadedAudioBuffer = null;
        let loadedCarrierBuffer = null;
        let playbackSource = null;

        function extractAudioFromVideo(file, callback) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.play();

            video.addEventListener('canplaythrough', function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                const recorder = new MediaRecorder(destination.stream);
                const chunks = [];

                recorder.ondataavailable = function(event) {
                    chunks.push(event.data);
                };

                recorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(blob);
                };

                recorder.start();
                video.play();
                setTimeout(() => {
                    recorder.stop();
                    video.pause();
                    URL.revokeObjectURL(video.src);
                }, video.duration * 1000);
            });
        }

        function handleFileInput(event, callback) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    extractAudioFromVideo(file, callback);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        document.getElementById('audioInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioData = e.target.result;
                    audioContext.decodeAudioData(audioData, function(buffer) {
                        loadedAudioBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding carrier audio data:', error);
                        alert('Error decoding carrier audio data. Please select a valid audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // this fixed the issue of requireing the carrier file to be loaded first
        function tryProcessAudio(B) {
            if (loadedCarrierBuffer && loadedAudioBuffer) {
                processAudio(B);
            }
        }

        document.getElementById('carrierInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const carrierData = e.target.result;
                    audioContext.decodeAudioData(carrierData, function(buffer) {
                        loadedCarrierBuffer = buffer;
                        carrierBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding modular audio data:', error);
                        alert('Error decoding modular audio data. Please select a valid input audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('reprocessButton').addEventListener('click', function() {
            if (loadedAudioBuffer && loadedCarrierBuffer) {
                processAudio(loadedAudioBuffer);
            } else {
                alert('Please load both audio and input files first.');
            }
        });

        document.getElementById('Harmonics').addEventListener('input', (e) => {
            /*const text = e.target.value;
            let parsed = [];

            try {
                const result = eval(text);
                if (Array.isArray(result)) {
                    parsed = result;
                    console.log("Harmonics array:", parsed);
                } else {
                    console.warn("Harmonics input did not return an array.");
                }
            } catch (err) {
                console.error("Failed to evaluate harmonics:", err);
            }*/

            updateURLParams()
        })

        function createLoopedBuffer(buffer, targetLength) {
            const sampleRate = buffer.sampleRate;
            const numberOfChannels = buffer.numberOfChannels;
            const newBuffer = audioContext.createBuffer(numberOfChannels, targetLength, sampleRate);
            
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const nowBuffering = newBuffer.getChannelData(channel);
                const originalData = buffer.getChannelData(channel);
                
                for (let i = 0; i < targetLength; i++) {
                    nowBuffering[i] = originalData[i % originalData.length];
                }
            }
            
            return newBuffer;
        }

        function showProcessPOP_UP(text, block = true, bar = false, per) {
            let popup = document.getElementById('processPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'processPopup';
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = '#222';
                popup.style.color = '#fff';
                popup.style.padding = '30px 40px';
                popup.style.borderRadius = '12px';
                popup.style.boxShadow = '0 4px 24px #000a';
                popup.style.zIndex = '2000';
                popup.style.fontSize = '1.2em';
                popup.style.textAlign = 'center';
                popup.style.display = 'flex';
                popup.style.flexDirection = 'column';
                popup.style.alignItems = 'center';
                popup.style.justifyContent = 'center';
                popup.style.width = '90vw';        // Responsive width
                popup.style.maxWidth = '600px';    // Maximum width
                popup.style.minWidth = '220px';    // Minimum width for usability
                popup.style.maxHeight = '90vh';    // Responsive height
                //popup.style.overflowY = 'auto';    // Enable vertical scroll if needed
                document.body.appendChild(popup);
            }

            // Clear popup content
            popup.innerHTML = '';

            // Add text
            const textDiv = document.createElement('div');
            textDiv.innerHTML = text.replace(/\n/g, '<br>');
            popup.appendChild(textDiv);

            // Add or update progress bar
            if (bar) {
                let progressBar = document.getElementById('progressBar');
                let progressFill = document.getElementById('progressFill');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.id = 'progressBar';
                    progressBar.style.width = '100%';
                    progressBar.style.height = '20px';
                    progressBar.style.backgroundColor = '#444';
                    progressBar.style.borderRadius = '10px';
                    progressBar.style.marginTop = '10px';

                    progressFill = document.createElement('div');
                    progressFill.id = 'progressFill';
                    progressFill.style.height = '100%';

                    const B255 = (Math.min(per/100*255, 255) / 255) ** 1.5 * 255;
                    progressFill.style.backgroundColor = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    progressFill.style.borderRadius = '10px';

                    progressBar.appendChild(progressFill);
                    popup.appendChild(progressBar);
                }
                // Always update width
                progressFill.style.width = `${per || 0}%`;
            }

            // Remove any fixed height so it grows/shrinks automatically
            popup.style.height = '';

            popup.style.display = block && text ? 'block' : 'none';
        }

        function showProcessPOP_UP_WL(message, visible = true, showProgress = false, progress = 0) {
            let popup = document.getElementById("processPopup");

            // Flex layout: gif on the left, text on the right
            popup.innerHTML = `
                <div style="display:flex;align-items:center;gap:15px;">
                    <img src="Load.gif" alt="Loading..." style="width:75px;height:75px;flex-shrink:0;">
                    <div style="flex:1;">
                        <p style="margin:0;white-space:pre-line;">${message || "Processing..."}</p>
                        ${showProgress ? `
                            <div id="progressWrapper" style="margin-top:10px;width:100%;background:#222;border-radius:5px;overflow:hidden;height:12px;">
                                <div id="progressBar" style="height:100%;width:${progress || 0}%;background:#5ac8fa;"></div>
                            </div>` : ""}
                    </div>
                </div>
            `;
            popup.style.display = "block";

            if (showProgress) {
                let per = Math.max(0, Math.min(progress, 100)); // clamp 0-100
                const progressBar = popup.querySelector("#progressBar");
                if (progressBar) {
                    progressBar.style.width = per + "%";

                    // 🎨 Color formula
                    const B255 = (Math.min(per / 100 * 255, 255) / 255) ** 1.5 * 255;
                    progressBar.style.backgroundColor =
                        `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                }
            }

            if (!popup) {
                popup = document.createElement("div");
                popup.id = "processPopup";
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.background = "rgba(34, 34, 34, 0.95)";
                popup.style.color = "#fff";
                popup.style.padding = "20px 30px";
                popup.style.borderRadius = "15px";
                popup.style.zIndex = "6000";
                popup.style.textAlign = "left";
                popup.style.boxShadow = "0 10px 40px rgba(0,0,0,0.6)";
                popup.style.minWidth = "320px";
                popup.style.maxWidth = "500px";
                document.body.appendChild(popup);
            }

            if (!visible) {
                popup.style.display = "none";
                return;
            }
        }


        async function processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer) {
            await new Promise(resolve => setTimeout(resolve, 20));
            if (iterations >= 2) {
                if (iterations == 69) {
                    showProcessPOP_UP_WL(`nice, 1/${iterations}`, true, true, 1 / iterations * 100);
                } else {
                    showProcessPOP_UP_WL(`Processing... this will take a while (website is frozen so you can do anything until it\'s done) \n1/${iterations} iterations`, true, true, 1 / iterations * 100);
                }
            } else {
                showProcessPOP_UP_WL('Processing... this will take a while (website is frozen so you can do anything until it\'s done)', true);
            }
            for (let i = 0; i < iterations; i++) {
                
                if (iterations >= 2) {
                    if (iterations == 69) {
                        showProcessPOP_UP_WL(`nice, ${i + 1}/${iterations}`, true, true, (i + 1) / iterations * 100);
                    } else {
                        showProcessPOP_UP_WL(`Processing... this will take a while (website is frozen so you can do anything until it\'s done) \n${i + 1}/${iterations} iterations`, true, true, i / iterations * 100);
                    }
                } else {
                    showProcessPOP_UP_WL('Processing... this will take a while (website is frozen so you can do anything until it\'s done)', true);
                }

                // Pause for 10ms (adjust as needed)
                await new Promise(resolve => setTimeout(resolve, 10));

                    if (Vmode == 0) {
                        processedBuffer = applyFFTLogic(
                            offlineContext,
                            inputLeft,
                            inputRight,
                            carrierLeft,
                            carrierRight,
                            buffer.sampleRate
                        );
                    } else if (Vmode == 1) {
                        processedBuffer = applyAnalogLogic(
                            offlineContext,
                            inputLeft,
                            inputRight,
                            carrierLeft,
                            carrierRight,
                            buffer.sampleRate
                        );
                    } else if (Vmode == 2) {
                        processedBuffer = apply4ormLogic(
                            offlineContext,
                            inputLeft,
                            inputRight,
                            carrierLeft,
                            carrierRight,
                            buffer.sampleRate
                        );
                    }

                    // For all modes, update input and carrier for next iteration
                    inputLeft = processedBuffer.getChannelData(0);
                    inputRight = processedBuffer.numberOfChannels > 1
                        ? processedBuffer.getChannelData(1)
                        : processedBuffer.getChannelData(0);

                    carrierLeft = inputLeft;
                    carrierRight = inputRight;
                }
            // Hide popup when done
            showProcessPOP_UP_WL('', false);
        }

        function apply4ormLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outL = outputBuffer.getChannelData(0);
            const outR = outputBuffer.getChannelData(1);

            // UI Parameters
            const ag = parseFloat(document.getElementById('Ag')?.value || 0.1);
            const res = parseFloat(document.getElementById('Resonance4orm')?.value || 0.999);
            const useArrLength = document.getElementById('UseArrLength')?.checked;
            const maxHarmonics = parseInt(document.getElementById('MaxHarm')?.value || 100);
            const harmExpr = document.getElementById('Harmonics')?.value || '[0,2,3,7].map(i => 2**(i/12))';
            const volume = parseFloat(document.getElementById('4ormVolume')?.value || 1.0);
            const _4ormFilterType = parseInt(document.getElementById('4ormFilterType')?.value || 0);
            const HZ = context.sampleRate

            // Parse harmonic array
            let harmonics;
            try {
                harmonics = eval(harmExpr);
                if (!Array.isArray(harmonics)) throw 'Not an array';
            } catch (e) {
                harmonics = [0, 2, 3, 7].map(i => 2 ** (i / 12));
            }

            // Clamp and slice harmonics to MaxHarm
            const harmonicList = harmonics;

            // Use array length as number of stages or default to 8
            const stages = useArrLength ? harmonicList.length : maxHarmonics;

            // Clear previous state
            z9 = [];
            z10 = [];
            z11 = []

            z5_4 = [];

            function peak(a, decayF, call) {
                z5_4[call] ??= { var1: 0 };
                z5_4[call].var1 = Math.max(Math.abs(a), z5_4[call].var1 - Math.sqrt(decayF) / 2);
                return z5_4[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5_4[call] ??= { var1: 0 };
                z5_4[call].var1 = (1 - decayF) * z5_4[call].var1 + decayF * a * a;
                return Msth.sqrt(z5_4[call].var1);
            }

            // Helper function: Repeats & wraps harmonic array with scaled octave down
            function repeatArr(inp, i) {
                return inp[i % inp.length] * 2 ** (-Math.floor(i / inp.length));
            }

            // Local filter function (special purpose)
            function $ap(inputY, ag = 0, res = 0, callCount = 0) {
                if (callCount >= z9.length || !z9[callCount]?.ap?.[0]) {
                    z9[callCount] = {
                        ap: Array.from({ length: 1 }, () => ({ p1: 0, p2: 0, p3: 0, p4: 0, pi: 0 }))
                    };
                }

                const state = z9[callCount].ap;
                const nres = 1 - res;
                const mr = 1 - nres * (0.5 + nres / 2);

                let out = 0;
                let i = 0;
                const stageAg = ag;
                const a = Math.min(Math.max(1 - (stageAg * stageAg / 4), 0), 0.9999);
                const s = state[i];

                const input = inputY - s.pi * mr;

                const y1 = -a * input + s.p1 + a * s.p2;
                s.p1 = input;
                s.p2 = y1;

                const y2 = -a * y1 + s.p3 + a * s.p4;
                s.p3 = y1;
                s.p4 = y2;

                s.pi = -y2;

                out = (s.pi + input);

                return out;
            }

            function $lp(d, c, r = 0, callCount = 0) {
                if (!z10[callCount]) {
                    z10[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                }

                const z = z10[callCount];
                let y = 0;
                let i = 0;
                let cc = Math.min(Math.max(c, 0), 0.9999);
                const fbv = r + r / (1 - cc);
                z.lp[i] += cc * (d - z.lp[i] + fbv * (z.lp[i] - z.fp[i]));
                z.fp[i] += cc * (z.lp[i] - z.fp[i]);
                y = z.fp[i];

                return y;
            }

            function $bp(d, c, r = 0, callCount = 0) {
                if (!z11[callCount]) {
                    z11[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                }

                const z = z11[callCount];
                let y = 0;
                let i = 0;
                let cc = Math.min(Math.max(c, 0), 0.9999);
                const fbv = r + r / (1 - cc);
                z.lp[i] += cc * (d - z.lp[i] + fbv * (z.lp[i] - z.fp[i]));
                z.fp[i] += cc * (z.lp[i] - z.fp[i]);
                y = (z.fp[i] - z.lp[i]);

                return y;
            }

            let tt = 0;
            const PWMwidth = parseFloat(document.getElementById('PWMwidth')?.value || 0.5);
            function generator(p, inp) {
                const gen_type = parseInt(document.getElementById('gen_type')?.value || 0);
                let wave = null;
                switch (gen_type) {
                    case 0: // input 2
                        wave = (t) => inp;
                        break;
                    case 1: // Sine wave
                        wave = (t) => Math.sin(2 * Math.PI * t );
                        break;
                    case 4: // Square wave
                        wave = (t) => (t % 1 < PWMwidth ? 1 : -1);
                        break;
                    case 3: // Sawtooth wave
                        wave = (t) => (t % 1) - 1;
                        break;
                    case 2: // Triangle wave
                        wave = (t) => Math.abs((t % 1)*2-1) * 2 - 1;
                        break;
                    case 5: // Noise
                        wave = (t) => Math.random() * 2 - 1;
                        break;
                    default:
                        wave = (t) => Math.sin(2 * Math.PI * t);
                        break;
                }
                tt += 1;
                return wave(tt*p/Math.PI/4);
            }
            const rel = parseFloat(document.getElementById('release')?.value || 0.0);
            const pitch = parseFloat(document.getElementById('pitch')?.value || 0.0);
            const pitchV = 2 ** (-pitch / 12);
            const resonance2 = parseFloat(document.getElementById('resonance2')?.value || 0.999);
            const $FUNC = (IP, c, r, stages, arr, call , IP2) => {
                let F;
                switch (_4ormFilterType) {
                    case 0: F = $lp; break;
                    case 1: F = $ap; break;
                    case 2: F = $bp; break;
                    default: F = $lp;
                }
                let out = 0;
                for (let i = 0; i < stages; i++) {
                    let tt=0
                    const Fcall = call * stages*2 + i
                    const stageAg = ag * repeatArr(arr, i);
                    if (document.getElementById('use_gen')?.checked) {
                        const GENi = generator(stageAg/stages, IP2)*stages;
                        let GEN = 0
                        if (resonance2 == 0) {
                            GEN = GENi;
                        } else {
                            GEN = F(GENi, stageAg, resonance2, Fcall+stages)/2;
                        }


                        out += GEN*peak(Math.abs(F(IP, stageAg*pitchV, res, Fcall))/2,2**-((rel*5)**2)/800,Fcall);
                    } else {
                        // Use the input directly
                        out += F(IP, stageAg, res, Fcall);
                    }
                }
                return out/stages;
            }
            // Apply processing
            for (let t = 0; t < inputLeft.length; t++) {
                const inL = carrierLeft[t];
                const inR = carrierRight[t];

                const inCL = inputLeft[t];
                const inCR = inputRight[t];

                //const $FUNC = [$lp, $ap, $bp][_4ormFilterType];

                const valL = $FUNC(inL*volume, ag, res, stages, harmonicList, 0, inCL) / 8;
                const valR = $FUNC(inR*volume, ag, res, stages, harmonicList, 1, inCR) / 8;

                outL[t] = valL;
                outR[t] = valR;
            }

            return outputBuffer;
        }

        function processAudio(buffer) {
            if (!loadedCarrierBuffer) {
                alert('Please select a carrier audio file.');
                return;
            }
            if (!loadedAudioBuffer) {
                alert('Please select a Modular audio file.');
                return;
            }

            // Get the number of iterations
            const iterations = parseInt(document.getElementById('iterations').value);
            if (iterations < 1) {
                alert('Please enter a valid number of iterations.');
                return;
            }
            
            // Create looped version of input to match the carrier length
            const carrierDuration = loadedCarrierBuffer.length / loadedCarrierBuffer.sampleRate;
            const targetLength = Math.ceil(carrierDuration * buffer.sampleRate);
            buffer = createLoopedBuffer(buffer, targetLength);

            // Set up analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Float32Array(bufferLength);

            // Create a buffer source for the original audio
            source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Perform FFT and reconstruct audio using the provided logic
            const offlineContext = new OfflineAudioContext(2, buffer.length, buffer.sampleRate); // Stereo
            let offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = buffer;

            const offlineAnalyser = offlineContext.createAnalyser();
            offlineAnalyser.fftSize = 2048;
            const offlineFrequencyData = new Uint8Array(offlineAnalyser.frequencyBinCount);

            offlineSource.connect(offlineAnalyser);
            offlineAnalyser.connect(offlineContext.destination);

            offlineSource.start();
            offlineContext.startRendering().then(function(renderedBuffer) {
                let inputLeft = buffer.getChannelData(0);
                let inputRight = buffer.numberOfChannels > 1 ? buffer.getChannelData(1) : buffer.getChannelData(0);
                let carrierLeft = loadedCarrierBuffer.getChannelData(0);
                let carrierRight = loadedCarrierBuffer.numberOfChannels > 1 ? loadedCarrierBuffer.getChannelData(1) : loadedCarrierBuffer.getChannelData(0);

                processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer);

                // Enable buttons
                document.getElementById('playButton').disabled = false;
                document.getElementById('pauseButton').disabled = false;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('reprocessButton').disabled = false;

                // Visualize the sine wave volumes
                visualize(offlineAnalyser, offlineFrequencyData);

                // Hide processing indicator
                showProcessPOP_UP('', false);
            });
        }

        /**
         * Visualize the frequency response of the analog filters based on current analog control properties.
         * Draws the response on the #filterView canvas.
         */


        const clamp=(minn,maxx,value)=>Math.min(Math.max(value,minn),maxx)

        function studyAnalogFilters() {
            let z2S=[{lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0}]
            let z3S=[{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}]
            let z4S=[{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}]
            let z8S=[{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}]
            let z7S=[{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
            let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))}]

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2S[callCount]) {
                    z2S[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2S[callCount].lp6 += cc * (f - z2S[callCount].lp6 + fbv * (z2S[callCount].lp6 - z2S[callCount].lp12));
                z2S[callCount].lp12 += cc * (z2S[callCount].lp6 - z2S[callCount].lp12);
                z2S[callCount].lp18 += cc * (z2S[callCount].lp12 - z2S[callCount].lp18);
                z2S[callCount].lp24 += cc * (z2S[callCount].lp18 - z2S[callCount].lp24);
                z2S[callCount].lp30 += cc * (z2S[callCount].lp24 - z2S[callCount].lp30);
                z2S[callCount].lp36 += cc * (z2S[callCount].lp30 - z2S[callCount].lp36);
                z2S[callCount].lp42 += cc * (z2S[callCount].lp36 - z2S[callCount].lp42);
                z2S[callCount].lp48 += cc * (z2S[callCount].lp42 - z2S[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2S[callCount].lp6;
                    case 2:  return z2S[callCount].lp12;
                    case 3:  return z2S[callCount].lp18;
                    case 4:  return z2S[callCount].lp24;
                    case 5:  return z2S[callCount].lp30;
                    case 6:  return z2S[callCount].lp36;
                    case 7:  return z2S[callCount].lp42;
                    case 8:  return z2S[callCount].lp48;
                    default: return z2S[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3S[callCount]) {
                    z3S[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3S[callCount].hp6 += cc * (f - z3S[callCount].hp6 + fbv * (z3S[callCount].hp6 - z3S[callCount].hp12));
                z3S[callCount].hp12 += cc * (z3S[callCount].hp6 - z3S[callCount].hp12);
                x = f - ((dbv >= 2) ? z3S[callCount].hp12 : z3S[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3S[callCount].hp18 += cc * (x - z3S[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3S[callCount].hp24 += cc * (x - z3S[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3S[callCount].hp30 += cc * (x - z3S[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3S[callCount].hp36 += cc * (x - z3S[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3S[callCount].hp42 += cc * (x - z3S[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3S[callCount].hp48 += cc * (x - z3S[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.5, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (callCount >= z4S.length) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4S[callCount].bp1 += cc * (f - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2));
                    z4S[callCount].bp2 += cc * (z4S[callCount].bp1 - z4S[callCount].bp2);
                    z4S[callCount].bp3 += cc * (z4S[callCount].bp2 - z4S[callCount].bp3);
                    z4S[callCount].bp4 += cc * (z4S[callCount].bp3 - z4S[callCount].bp4);
                    z4S[callCount].bp5 += cc * (z4S[callCount].bp4 - z4S[callCount].bp5);
                    z4S[callCount].bp6 += cc * (z4S[callCount].bp5 - z4S[callCount].bp6);
                    z4S[callCount].bp7 += cc * (z4S[callCount].bp6 - z4S[callCount].bp7);
                    z4S[callCount].bp8 += cc * (z4S[callCount].bp7 - z4S[callCount].bp8);
                    z4S[callCount].bp9 += cc * (z4S[callCount].bp8 - z4S[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4S[callCount].bp1 - z4S[callCount].bp2; break;
                        case 2: out = z4S[callCount].bp2 - z4S[callCount].bp3; break;
                        case 3: out = z4S[callCount].bp3 - z4S[callCount].bp4; break;
                        case 4: out = z4S[callCount].bp4 - z4S[callCount].bp5; break;
                        case 5: out = z4S[callCount].bp5 - z4S[callCount].bp6; break;
                        case 6: out = z4S[callCount].bp6 - z4S[callCount].bp7; break;
                        case 7: out = z4S[callCount].bp7 - z4S[callCount].bp8; break;
                        case 8: out = z4S[callCount].bp8 - z4S[callCount].bp9; break;
                        default: out = z4S[callCount].bp2 - z4S[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w=1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4S[callCount].bp3 += clamp(-1, 1, f - z4S[callCount].bp3) * cc;
                            z4S[callCount].bp1 += clamp(-1, 1, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4S[callCount].bp3 += clamp(-cc, cc, f - z4S[callCount].bp3);
                            z4S[callCount].bp1 += clamp(-cc, cc, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)));
                            break;
                    }
                    z4S[callCount].bp2 += clamp(-1, 1, z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    //z4S[callCount].bp3 += (f - z4S[callCount].bp3) * cc * (4 + cc * 1) / 5;
                    z4S[callCount].bp1 += (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)) * cc;
                    z4S[callCount].bp2 += (z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1 - z4S[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/32 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (callCount >= z7S.length) {
                        z7S.push({
                            p1: 0, p2: 0, p3: 0, p4: 0,
                            p5: 0, p6: 0, p7: 0, p8: 0,
                            pi: 0
                        });
                    }
                    const s = z7S[callCount];

                    const nres = 1 - res;
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const a = clamp(0, 0.9999, 1 - (ag*ag / 4));

                    const input = inputY - s.pi * mr;
                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input ;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;
                

                    s.pi = -y2;  // You can choose [y2, y4] for smoother vs sharper

                    callCount++;
                    return (y2+input)/64*(1+ag*8);
                } catch (e) {
                    throw e;
                }
            }

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPCS[callCount];
                
                    let f=d

                    div=(1-r**100*.99)
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    f = st.bp1 - st.bp2; // feed forward into next stage
                    o=f / (1-cc**2)*1.25 / (r/2+.5)

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                        st.bp2 += cc * (st.bp1 - st.bp2);
                        f = (st.bp1 - st.bp2) * (1-r**2) / (1-cc**2)*1.25 / (r/2+.5); // feed forward into next stage
                        o=f
                    }

                    return o*(.25+cc*2) // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r

                    const s = zBPCS[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)
                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc)
                        f*=1-fb
                        o=f
                    }

                    return o*(.25+cc*2)*8 // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            const canvas = document.getElementById('filterView');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get analog control values
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const resonance = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const bpwidth = parseFloat(document.getElementById('BPwidth').value);
            const altBP = parseInt(document.getElementById('Alt_BP').value) || 0;

            // Frequency range (log scale)
            const minFreq = 20, maxFreq = 20000;
            const sampleRate = 44100;
            const points = canvas.width;
            let testInput = 0;

            // Prepare for drawing
            ctx.save();
            ctx.strokeStyle = "#4af";
            ctx.lineWidth = 2;
            ctx.beginPath();

            // For each frequency, compute filter response
            // Smoothing window size (must be odd)
            const SMOOTH_WINDOW = 9;
            const halfWindow = Math.floor(SMOOTH_WINDOW / 2);
            const dbVals = [];

            // First, calculate all dB values (unsmoothed)
            for (let x = 0; x < points; x++) {
                // Logarithmic frequency mapping
                const freq = minFreq * Math.pow(maxFreq / minFreq, x / (points - 1));
                const FLTcutoff = .1;

                // Reset filter state for each frequency
                let z2S = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
                let z3S = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
                let z4S = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
                let z8S = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
                let z7S = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
                let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];

                //console.log(altBP)

                // Sine wave test: run for several cycles and measure output amplitude
                const cycles = 1;
                const samplesPerCycle = Math.round(sampleRate / freq);
                const totalSamples = cycles * samplesPerCycle;
                let maxOut = 0;

                for (let t = 0; t < totalSamples; t++) {
                    const testInput = Math.sin(2 * Math.PI * freq * t / sampleRate);
                    let out = 0;
                    
                    switch (altBP) {
                        case 0:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 1:
                            out = bp2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 2:
                            out = bp3(testInput*4, FLTcutoff, resonance, db, 0);
                            break;
                        case 3:
                            out = bp4(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 4:
                            out = bp5(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 5:
                            out = ap(testInput, FLTcutoff, resonance, 0);
                            break;
                        case 6:
                            out = bpTC(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 7:
                            out = bpTC2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        default:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                    }
                    // Use peak amplitude (or accumulate RMS if you prefer)
                    if (t > totalSamples - samplesPerCycle) { // Only last cycle for steady-state
                        maxOut = Math.max(maxOut, Math.abs(out));
                    }
                }

                // Convert to dB
                let dbVal = 20 * Math.log10(maxOut + 1e-8);
                dbVals[x] = dbVal-20;   //it goes off grapth so i subtract it by 20
            }

            // Now, smooth the dB values using a moving average
            const smoothedDbVals = [];
            for (let x = 0; x < points; x++) {
                let sum = 0, count = 0;
                for (let k = -halfWindow; k <= halfWindow; k++) {
                    const idx = x + k;
                    if (idx >= 0 && idx < points) {
                        sum += dbVals[idx];
                        count++;
                    }
                }
                smoothedDbVals[x] = sum / count;
            }

            // Draw the smoothed graph
            for (let x = 0; x < points; x++) {
                // Normalize to canvas height (0 dB at 1/4 from top, -60 dB at bottom)
                const y = canvas.height * 0.25 + (canvas.height * 0.75) * (1 - (smoothedDbVals[x] + 60) / 60);

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            // Draw frequency grid
            ctx.save();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.font = "10px Arial";
            ctx.fillStyle = "#aaa";
            for (let f of [50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000]) {
                const x = Math.log(f / minFreq) / Math.log(maxFreq / minFreq) * (canvas.width - 1);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.fillText(f + "Hz", x + 2, canvas.height - 2);
            }
            ctx.restore();
        }

        // Draw on page load
        document.addEventListener('DOMContentLoaded', studyAnalogFilters);

        function applyAnalogLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Helper functions and state
            const min = Math.min, max = Math.max, abs = Math.abs, pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, PI = Math.PI;
            const clamp = (minn, maxx, value) => min(max(value, minn), maxx);

            let z2 = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
            let z3 = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
            let z4 = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
            let z8 = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
            let z5 = [{var1:0}];
            let z7 = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}];
            let zBPC = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];
            
            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2[callCount]) {
                    z2[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2[callCount].lp6 += cc * (f - z2[callCount].lp6 + fbv * (z2[callCount].lp6 - z2[callCount].lp12));
                z2[callCount].lp12 += cc * (z2[callCount].lp6 - z2[callCount].lp12);
                z2[callCount].lp18 += cc * (z2[callCount].lp12 - z2[callCount].lp18);
                z2[callCount].lp24 += cc * (z2[callCount].lp18 - z2[callCount].lp24);
                z2[callCount].lp30 += cc * (z2[callCount].lp24 - z2[callCount].lp30);
                z2[callCount].lp36 += cc * (z2[callCount].lp30 - z2[callCount].lp36);
                z2[callCount].lp42 += cc * (z2[callCount].lp36 - z2[callCount].lp42);
                z2[callCount].lp48 += cc * (z2[callCount].lp42 - z2[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2[callCount].lp6;
                    case 2:  return z2[callCount].lp12;
                    case 3:  return z2[callCount].lp18;
                    case 4:  return z2[callCount].lp24;
                    case 5:  return z2[callCount].lp30;
                    case 6:  return z2[callCount].lp36;
                    case 7:  return z2[callCount].lp42;
                    case 8:  return z2[callCount].lp48;
                    default: return z2[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3[callCount]) {
                    z3[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3[callCount].hp6 += cc * (f - z3[callCount].hp6 + fbv * (z3[callCount].hp6 - z3[callCount].hp12));
                z3[callCount].hp12 += cc * (z3[callCount].hp6 - z3[callCount].hp12);
                x = f - ((dbv >= 2) ? z3[callCount].hp12 : z3[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3[callCount].hp18 += cc * (x - z3[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3[callCount].hp24 += cc * (x - z3[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3[callCount].hp30 += cc * (x - z3[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3[callCount].hp36 += cc * (x - z3[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3[callCount].hp42 += cc * (x - z3[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3[callCount].hp48 += cc * (x - z3[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);
                    z4[callCount].bp3 += cc * (z4[callCount].bp2 - z4[callCount].bp3);
                    z4[callCount].bp4 += cc * (z4[callCount].bp3 - z4[callCount].bp4);
                    z4[callCount].bp5 += cc * (z4[callCount].bp4 - z4[callCount].bp5);
                    z4[callCount].bp6 += cc * (z4[callCount].bp5 - z4[callCount].bp6);
                    z4[callCount].bp7 += cc * (z4[callCount].bp6 - z4[callCount].bp7);
                    z4[callCount].bp8 += cc * (z4[callCount].bp7 - z4[callCount].bp8);
                    z4[callCount].bp9 += cc * (z4[callCount].bp8 - z4[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4[callCount].bp1 - z4[callCount].bp2; break;
                        case 2: out = z4[callCount].bp2 - z4[callCount].bp3; break;
                        case 3: out = z4[callCount].bp3 - z4[callCount].bp4; break;
                        case 4: out = z4[callCount].bp4 - z4[callCount].bp5; break;
                        case 5: out = z4[callCount].bp5 - z4[callCount].bp6; break;
                        case 6: out = z4[callCount].bp6 - z4[callCount].bp7; break;
                        case 7: out = z4[callCount].bp7 - z4[callCount].bp8; break;
                        case 8: out = z4[callCount].bp8 - z4[callCount].bp9; break;
                        default: out = z4[callCount].bp2 - z4[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w = 1,callCount) {
                try {
                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;
                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4[callCount].bp3 += clamp(-1, 1, f - z4[callCount].bp3) * cc;
                            z4[callCount].bp1 += clamp(-1, 1, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4[callCount].bp3 += clamp(-cc, cc, f - z4[callCount].bp3);
                            z4[callCount].bp1 += clamp(-cc, cc, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2)));
                            break;
                    }
                    z4[callCount].bp2 += clamp(-1, 1, z4[callCount].bp1 - z4[callCount].bp2) * cc;

                    out = z4[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0});
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);

                    let out=0;
                    out = z4[callCount].bp1 - z4[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/128 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (!z7[callCount]) {
                        z7[callCount] = {p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0};
                    }
                    const s = z7[callCount];

                    const nres = 1 - res;
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);

                    const a = clamp(0, 0.9999, 1 - (ag * ag / 4));

                    const input = inputY - s.pi * mr;

                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;

                    s.pi = -y2;

                    return (y2+input)/64*(1+ag*8)
                } catch (e) {
                    throw e;
                }
            };

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d

                    div=(1-r**100*.99)
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    f = st.bp1 - st.bp2; // feed forward into next stage
                    o=f / (1-cc**2)*1.25 / (r/2+.5)

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                        st.bp2 += cc * (st.bp1 - st.bp2);
                        f = (st.bp1 - st.bp2) * (1-r**2) / (1-cc**2)*1.25 / (r/2+.5); // feed forward into next stage
                        o=f
                    }

                    return o*(.25+cc*2); // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r //+ r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)

                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc) * (1-fb)
                        o=f
                    }

                    return o*(.25+cc)*8// Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            // UI values
            const sel = parseInt(document.getElementById('decayType').value)-1;
            const rel = parseFloat(document.getElementById('release').value);
            const fb = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const dw = parseFloat(document.getElementById('BPwidth').value);
            const vol = parseFloat(document.getElementById('Volboost').value);
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const flip = document.getElementById('FreqFlip').checked;
            const pitch = parseFloat(document.getElementById('pitch').value);
            const decayByFreq = parseInt(document.getElementById('decayByFreq').value) || 0;
            const freqCurve = parseFloat(document.getElementById('freqCurve').value) || 0;
            const UseResBasedOnDistance = document.getElementById('UseResBasedOnDistance').checked;
            const addLPtoLowEnd = document.getElementById('addLPtoLowEnd').checked;

            // Envelope followers
            function peak(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = Math.max(abs(a), z5[call].var1 - sqrt(decayF) / 2);
                return z5[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = (1 - decayF) * z5[call].var1 + decayF * a * a;
                return sqrt(z5[call].var1);
            }
            
            function bandFrequency(bands, index, sampleRate, convertToFloat = true) {
                const fmin = 20;                         // lowest frequency
                const fmax = sampleRate / 2.205;         // Nyquist-ish limit
                const ratio = Math.pow(fmax / fmin, 1 / bands); // geometric step

                // center frequency of this band
                let freq = fmin * Math.pow(ratio, index + 0.5);

                // optionally normalize to [0,1]
                if (convertToFloat) {
                    freq = freq / (sampleRate / 2);
                }
                return freq;
            }

            let modulatedValue = 1
            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
            const duration = inputLeft.length / sampleRate;

            function curve(i, nv) {
                switch (freqCurve) {
                    case 0:
                        ic = i / nv;
                        EQvol = 1;
                        distance = (i+1)/nv - i/nv;
                        break;
                    case 1:
                        ic = Math.log(i/nv+1)/Math.LOG2E;
                        EQvol = 1-ic/10;
                        distance = (Math.log((i+1)/nv+1)/Math.LOG2E) - ic;
                        break;
                    case 2:
                        ic = Math.exp(i/nv*Math.LN2)-1;
                        EQvol = .9+ic/10;
                        distance = (Math.exp((i+1)/nv*Math.LN2)-1) - ic;
                        break;
                    case 3:
                        ic = 2**(i/nv*8-8);
                        EQvol = .5+ic*2;
                        distance = 2**((i+1)/nv*8-8) - ic
                        break;
                    case 4:
                        ic = (i/nv)**2;
                        EQvol = .9+ic/10;
                        distance = ((i+1)/nv)**2 - ic;
                        break;
                    case 5:
                        ic = bandFrequency(nv,i,48000)**.5
                        EQvol = 1+4*(1-i/nv)
                        distance = bandFrequency(nv,i+1,48000)**.5 - ic;
                        break;
                    default:
                        ic = i/nv;
                        EQvol = 1;
                        distance = (i+1)/nv - ic;
                        break;
                }

                return {ic, distance, EQvol};
            }

            // Vocoder function
            function vocoder(inp, car, bool=false) {
                let relv = 0, nv = n, volv = vol, fbv = fb, dbv = db, dww = dw, selv = sel;
                let p = [rms, peak][max(min(selv, 2), 0)];
                let result = 0;
                let carrierSum = 0, modSum = 0;
                const Alt_BP=parseInt(document.getElementById('Alt_BP').value) || 0;
                let distance = 0;
                let EQvol = 1;

                for (let i = 1; i <= nv; i++) {

                    // Filter input (modulator) and carrier
                    const filter = (v, m, f = 0, dwo, FRQ) => {
                        // Flip FRQ if f flag is set
                        FRQ = f ? 1 - FRQ : FRQ;

                        if (Alt_BP === 0) {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 1) {
                            return bp2(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 2) {
                            return bp3(v * 256, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 3) {
                            return bp4(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 4) {
                            return bp5(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 5) {
                            return ap(v * 64, FRQ, fbv, m);
                        } else if (Alt_BP === 6) {
                            return bpTC(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 7) {
                            return bpTC2(v * 64, FRQ, fbv, dbv, m);
                        } else {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        }
                    };

                    let vol = 1;

                    // Get curve values
                    let { ic, distance, EQvol} = curve(i, nv);


                    //console.log(i, ic, distance)
                    if (UseResBasedOnDistance && (freqCurve==5 || freqCurve==6 || freqCurve==7)) {
                        fbv = fb * (1 - distance*1.75);
                        //EQvol = 1
                    }

                    switch (decayByFreq) {
                        case 0:
                            relv = rel;
                            break;
                        case 1:
                            relv = rel + ic/4;
                            break;
                        case 2:
                            relv = rel + (1-ic)/4;
                            break;
                        default:
                            relv = rel;
                    }

                    const g = ic / 2**(pitch/12);

                    const modFiltered = filter(inp, i + 0 + bool*n*3, flip, dww, g)*EQvol;
                    const carFiltered = filter(car, i + n + bool*n*3, false, dww, ic)*EQvol;

                    const absFilterX = abs(modFiltered);
                    const mod = p(absFilterX, 2**-((relv*3)**2)/400, i + bool*n*3);

                    // For debugging: sum up mod and carrier
                    //modSum += mod;
                    //carrierSum = carFiltered;
                    //combined = modFiltered/512

                    // If mod is always zero, you will only hear silence or the modular
                    const combined = mod * carFiltered * (1 - fbv) / sqrt(nv * 10) * (1 - g);
                    result += combined * volv;

                    //console.log(result, mod, carFiltered, combined, inp, car, i, nv, modulatedValue);
                }

                let LPOUT = 0
                if (addLPtoLowEnd) {
                    let { ic, distance, EQvol: eqv } = curve(1, nv);

                    fbvv = UseResBasedOnDistance?fb*(1-distance*1.75):fb
                    LPC = lp(car*64, ic, fbv, dbv, n*2+2 + bool*n*3);
                    LPM = lp(inp*64, ic, fbv, dbv, n*2+3 + bool*n*3);

                    ABSLPC = abs(LPM);
                    LPOUT = LPC * p(ABSLPC, 2**-((rel*3)**2)/400, n*2+2)
                }

                let LOUT = LPOUT * volv / 8 * dbv + result*n/2;

                // Prevent NaN/Infinity
                if (!isFinite(result) || isNaN(result)) result = 0;
                return LOUT / 128;
            }

            // Output buffer
            const bufferLen = inputLeft.length;
            const outputBuffer = context.createBuffer(2, bufferLen, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);
            // Analog vocoder processing
            for (let idx = 0; idx < bufferLen; idx++) {
                const idxL = idx % carrierLeft.length;
                const idxR = idx % carrierRight.length;
                outputLeft[idx] = vocoder(carrierLeft[idxL], inputLeft[idx], 0);
                outputRight[idx] = vocoder(carrierRight[idxR], inputRight[idx], 1);
            }

            return outputBuffer;
        }

        function applyFFTLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            const FFTsize = document.getElementById('FFTsize').value;
            const SIZE = 2 ** FFTsize;
            const OVERLAP = 4;
            const HOP_SIZE = SIZE / OVERLAP;
            const PI = Math.PI;
            const cos = Math.cos;
            const sin = Math.sin;
            const asin = Math.asin;
            const abs = Math.abs;

            const X = o => {
                switch (parseInt(document.getElementById('BR_voc_Type').value)) {
                    default:
                        return { r: cos(o), i: sin(o) }
                    case 1:
                        return { r: asin(cos(o)) / PI * 2.25, i: asin(sin(o)) / PI * 2.25 };
                    case 2:
                        return { r: sin(cos(o) * 2) * .9 , i: sin(sin(o) * 2) * .9};
                    case 3:
                        return { r: cos(o * 2) * .9, i: sin(o * 2) * .9};
                    case 4:
                        return { r: cos(o * 3) * .8, i: sin(o * 3) * .8}
                    case 5:
                        return { r: o / PI + PI / 4 & 1 ? 0.65 : -0.65, i: o / PI & 1 ? 0.65 : -0.65 }
                    case 6:
                        return { r: ((o / PI + PI / 4) % 2 - 1)/1.4 , i: ((o / PI)% 2 - 1) / 1.4 }
                    case 7:
                        return { r: sin(sin(cos(o) * 2) * 2) * .8 , i: sin(sin(sin(o) * 2) * 2) * .8}
                    case 8:
                        return { r: cos(o / 2) * 0.9, i: sin(o / 2) * 0.9}
                    case 9:
                        return { r: cos(o ** 2) * 0.95, i: sin(o ** 2) * 0.95 }
                    case 10:
                        return { r: cos(o) ** 2, i: sin(o) ** 2 }
                    case 11:
                        return { r: (-abs(cos(o / 2)) + 0.5) * 1.7, i: (-abs(sin(o / 2)) + 0.5) * 1.7}
                    case 12:
                        return { r: (abs(sin(o / 2 + PI / 2) ** 3) - 0.5) * 1.8, i: (abs(sin(o / 2 + PI / 4) ** 3) - 0.5) * 1.8 } // i genuinely have no idea what this is
                    case 13:
                        return { r: cos(rand(o/1e10)*PI)*.9, i: sin(rand(o/1e10)*PI)*.9 }
                    case 14:
                        return { r: cos(o) ** 3 * 1.15, i: sin(o) ** 3 * 1.15 }
                    case 15:
                        return { r: cos(o*cos(o)), i: sin(o*sin(o))/2 }
                    case 16:
                        return { r: harm(o+PI/2) * 0.8, i: harm(o) * 0.8 }
                    case 17:
                        return { r: harmS(o+PI/2) * 0.9, i: harmS(o) * 0.9 }
                    case 18:
                        return { r: cos((o*128/PI&o*127/PI)/128*PI), i: sin((o*128/PI|o*127/PI)/128*PI) }
                    case 19:
                        return { r: cos((o*4/PI|0)/4*PI), i: sin((o*4/PI|0)/4*PI) }
                }
            };
            const X2 = o => ({ r: cos(o), i: sin(o) }); //back up
            const M = (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + b.r * a.i });
            const A = (a, b) => ({ r: a.r + b.r, i: a.i + b.i });

            const FFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = { r: I[ii], i: 0 };
                else {
                    FFT(O, I, oi, ii, N / 2, s * 2);
                    FFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(-2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            const IFFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = I[ii];
                else {
                    IFFT(O, I, oi, ii, N / 2, s * 2);
                    IFFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            // Calculate the duration of the audio buffer
            const duration = inputLeft.length / sampleRate;

            // Create output buffer (stereo)
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);

            // Initialize buffers
            const I = Array.from({ length: SIZE }, () => 0);
            const O = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));
            const I2 = Array.from({ length: SIZE }, () => 0);
            const O2 = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));

            const pitch = parseInt(document.getElementById('pitch').value);
            const Shift = parseInt(document.getElementById('BandShift').value)
            const divbands = parseInt(document.getElementById('divbands').value);

            const DecayType = parseInt(document.getElementById('decayType').value);
            const Release = parseFloat(document.getElementById('release').value) ** (1 / (4 + (divbands - 1) * 2));
            const BassBoost = parseFloat(document.getElementById('BassBoost').value);

            const envelopeStateLeft = Array(SIZE).fill(0);
            const envelopeStateRight = Array(SIZE).fill(0);

            const window = Array.from({ length: SIZE }, (_, i) =>
                0.5 * (1 - Math.cos(2 * Math.PI * i / (SIZE - 1)))
            );

            const clampOut = parseFloat(document.getElementById('clamp_output').value);
            const Threshold = parseFloat(document.getElementById('threshold').value);

            // Process left and right channels separately
            const processChannel = (inputData, carrierData, outputData, envelopeState) => {
                const startTime = performance.now();
                const Break = document.getElementById('BandBreak').checked;
                const flip = document.getElementById('FreqFlip').checked

                for (let t = 0; t < inputData.length; t += HOP_SIZE) {
                    const currentTime = (performance.now() - startTime) / 1000; // Current time in seconds

                    // Fill input buffer for input data with windowing
                    for (let i = 0; i < SIZE; i++) {
                        I[i] = (inputData[t + i] || 0) * window[i];
                        I2[i] = (carrierData[t + i] || 0) * window[i];
                    }

                    // Perform FFT on input data
                    FFT(O, I, 0, 0, SIZE, 1);

                    // Perform FFT on carrier data
                    FFT(O2, I2, 0, 0, SIZE, 1);

                    // Modulate frequency components
                    for (let i = 0; i < SIZE; i++) {
                        let timer = currentTime; // Timer value between 0 and 1
                        const speedType = parseInt(document.getElementById('speedType').value)

                        switch (speedType) {
                            case 0:
                                timer = currentTime / 8;
                                break;
                            case 1:
                                timer = currentTime / duration;
                                break;
                            case 2:
                                timer = currentTime * parseFloat(document.getElementById('userSpeed').value);
                                break;
                        }

                        // Apply envelope following
                        let envelope = 0;
                        const mag1 = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                        let mag2 = 0;
                        let ip = 0;
                        let ip_ = 0;
                        const Ratio = (SIZE / 1024);

                        let callCount = 0;

                        const lin = (a, b, t) => a * (1 - t) + b * t;

                        // divide bands
                        for (let j = 0; j <= divbands; j++) {
                            ip = (i / 2 ** (pitch / 12) | 0);
                            const weight = 1 - abs(j - divbands / 2) / divbands;
                            
                            ip_ = Math.round(ip + (j - divbands / 2) + Shift);

                            if (flip) {
                                ip_=Math.round(SIZE/16-ip_)
                            }

                            if (ip_ >= 0 && ip_ < SIZE && O2[ip_]) {
                                mag2 += Math.sqrt(O2[ip_].r * O2[ip_].r + O2[ip_].i * O2[ip_].i) * weight;
                            } else {
                                mag2 += 0;
                            }

                            const REL = Math.min((1 - Release) * Ratio, 1);

                            switch (DecayType) {
                                case 1: // RMS
                                    envelopeState[i] = (1 - REL) * envelopeState[i] + REL * mag2 * mag2;
                                    envelope += Math.sqrt(envelopeState[i]);
                                    break;
                                case 2: // Peak
                                    envelopeState[i] = Math.max(mag2, envelopeState[i] * (1 - REL));
                                    envelope += envelopeState[i];
                                    break;
                            }
                            // somehow (1 + 2 / divbands / 2) solved the volume issue
                            envelope /= divbands * ((1 + 2 / divbands) / 2);
                        }

                        // Apply modulation with normalization and volume with BassBoost
                        const BassCurveType = parseInt(document.getElementById('BassCurve').value);
                        const normEQcurveType = parseInt(document.getElementById('EQType').value);

                        let BassCurve = 0;
                        switch (BassCurveType) {
                            case 0:
                                BassCurve = 1;
                                break;
                            case 1:
                                BassCurve = 10 / (i + 1);
                                break;
                            case 2:
                                BassCurve = ((1 - i / SIZE) ** 2);
                                break;
                        }

                        let normEQcurve = 0;
                        switch (normEQcurveType) {
                            case 0:
                                normEQcurve = Math.min(1, (i < SIZE / 2 ? i : SIZE - i) / (SIZE / 4));
                                break;
                            case 1:
                                normEQcurve = Math.sin(i / SIZE * PI);
                                break;
                        }

                        // Example calculation using the timer
                        let modulatedValue = 1
                        const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
                        const modulatedInput = i*((timer*256|0)/256);

                        switch (simpleChorus) {
                            case 1:
                                modulatedValue = sin(modulatedInput*PI);
                                break;
                            case 2:
                                modulatedValue = cos(modulatedInput*PI);
                                break;
                            case 3:
                                modulatedValue = asin(sin(modulatedInput*PI));
                                break;
                            case 4:
                                modulatedValue = asin(cos(modulatedInput*PI));
                                break;
                        }

                        soundgoodizer = parseFloat(document.getElementById('SoundGoodizer').value);
                        const normEQ = (normEQcurve + BassBoost * BassCurve / (Math.sqrt(Ratio)*1024) * 20) * modulatedValue * lin(1, ((i/SIZE)**150*15+((i/SIZE)**150-1)*2-sin(i/SIZE*PI)*4)/2, soundgoodizer)

                        // Apply modulation based on BR_out value
                        switch (parseInt(document.getElementById('BR_out').value)) {
                            case 1:
                                O[i] = M(O[i], X(2 * PI * i / SIZE));
                                O2[i] = M(O2[i], X(2 * PI * i / SIZE));
                                break;
                            case 3:
                                O[i] = M(O[i], X2(2 * PI * i / SIZE));
                                break;
                            case 2:
                                O2[i] = M(O2[i], X2(2 * PI * i / SIZE));
                                break;
                        }

                        const volume = document.getElementById('volume').value / Math.sqrt(Ratio);

                        const steps = parseFloat(document.getElementById('steps').value);
                        const RoundType = [Math.floor, Math.round, Math.ceil][parseInt(document.getElementById('RoundType').value)];
                        envelope = steps ? RoundType(envelope * (steps / 16)) / (steps / 16) : envelope;

                        O[i].r *= envelope * volume * normEQ;
                        O[i].i *= envelope * volume * normEQ;

                        if (clampOut == 2) {
                            O[i].r = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].r));
                            O[i].i = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].i));
                        }
                    }

                    let frequencyMagnitudes = Array(SIZE).fill(0);
                    if (clampOut == 4) {
                        for (let i = 0; i < SIZE; i++) {
                            const ratio = 2; // Compression ratio

                            // Calculate the magnitude of the frequency component
                            const magni = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                            frequencyMagnitudes[i] = Math.sqrt((frequencyMagnitudes[i] ** 2 * 24 + magni ** 2) / 25);
                            let level = frequencyMagnitudes[i];

                            let gain = Math.min(1, (Threshold / level) ** (ratio - 1)); // Compute gain reduction

                            O[i].r *= gain;
                            O[i].i *= gain;
                        }
                    }

                    if (Break) {
                        // Reverse the second half of the spectrum
                        for (let i = 1; i < SIZE / 2; i++) {
                            let tmp = O[i];
                            O[i] = O[SIZE - i];
                            O[SIZE - i] = tmp;
                        }
                        // discard the second half of the spectrum
                        for (let i = SIZE / 2; i < SIZE; i++) {
                            O[i].r = 0;
                            O[i].i = 0;
                        }
                    }

                    // Perform IFFT
                    IFFT(I, O, 0, 0, SIZE, 1);

                    // Overlap-add with windowing
                    for (let i = 0; i < SIZE; i++) {
                        const inputt =  outputData[t + i] + I[i].r / SIZE * window[i];
                        if (clampOut == 1) {
                            outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt));
                        } else {
                            outputData[t + i] += (I[i].r / SIZE) * window[i];
                        }
                    }
                }
            };

            // Process left channel
            processChannel(inputLeft, carrierLeft, outputLeft, envelopeStateLeft);

            // Process right channel
            processChannel(inputRight, carrierRight, outputRight, envelopeStateRight);

            return outputBuffer;
        }

        function visualize(analyser, dataArray) {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;

            function draw() {
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i];
                const B255 = (Math.min(barHeight, 255) / 255) ** 1.5 * 255;
                ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                ctx.fillRect(x, canvas.height - barHeight * 1.56, barWidth, barHeight * 1.56);

                x += barWidth + 1;
            }

            requestAnimationFrame(draw);
            }

            draw();
        }

        document.getElementById('playButton').addEventListener('click', function() {
            if (processedBuffer) {
                playbackSource = audioContext.createBufferSource();
                playbackSource.buffer = processedBuffer; // Play the processed buffer stored in RAM
                playbackSource.connect(audioContext.destination);

                // Set up a new analyser for playback visualization
                const playbackAnalyser = audioContext.createAnalyser();
                playbackAnalyser.fftSize = 2048;
                const playbackFrequencyData = new Uint8Array(playbackAnalyser.frequencyBinCount);

                playbackSource.connect(playbackAnalyser);
                playbackAnalyser.connect(audioContext.destination);

                // Visualize the playback audio
                visualize(playbackAnalyser, playbackFrequencyData);

                playbackSource.start();
            }
        });

        document.getElementById('pauseButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('stopButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('downloadButton').addEventListener('click', function() {
            const carrierInput = document.getElementById('carrierInput');
            const audioInput = document.getElementById('audioInput');
            let carrierName = 'No name';
            let modularName = 'No name';

            if (carrierInput.files.length > 0) {
                carrierName = carrierInput.files[0].name.split('.').slice(0, -1).join('.');
            }
            if (audioInput.files.length > 0) {
                modularName = audioInput.files[0].name.split('.').slice(0, -1).join('.');
            }

            if (processedBuffer) {
                const wavBuffer = bufferToWav(processedBuffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${carrierName} (${modularName}).wav`;
                a.click();
                URL.revokeObjectURL(url);
            }
        });

        function bufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = loadedCarrierBuffer.length * numOfChan * 2 + 44; // Use carrier buffer length
            const bufferArray = new ArrayBuffer(length);
            const view = new DataView(bufferArray);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length

            // Write interleaved audio data
            let offset = 44;
            for (let i = 0; i < loadedCarrierBuffer.length; i++) { // Use carrier buffer length
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
