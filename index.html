<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="Icon.png">
    <title>Crappy FFT Vocoder</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #fff;
        }
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            padding: 10px;
            background-color: #111;
            border-radius: 10px;
        }
        #processingIndicator {
            display: none;
            margin-top: 20px;
            color: #ff0;
        }
        @media (max-width: 600px) {
            #controls {
                width: 90%;
            }
            canvas {
                width: 100%;
                height: auto;
            }
        }
        #controls2 {
            width: 96%;
            margin-top: 20px;
            padding: 10px;
            background-color: #222;
            border-radius: 10px;
            text-align: center;
            align-items: center;
            gap: 10px;
        }
        #controls2 > * {
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #iterations {
            width: 50px;
        }
        #helpPopup {
            display: none;
            position: fixed;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 5px 20px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #666;
        }
        button:disabled {
            background-color: #333;
            cursor: not-allowed;
        }
        input[type="file"] {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 2px 3px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="file"]::file-selector-button {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 3px 10px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #666;
        }
        select {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        select:hover {
            background-color: #666;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 125px;
            margin: 10px 0;
            background-color: #444;
            border-radius: 5px;
            height: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background-color: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background-color: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-moz-range-thumb:hover {
            background-color: #666;
        }

        input[type="range"]::-webkit-slider-runnable-track,
        input[type="range"]::-moz-range-track {
            background-color: #444;
            border-radius: 5px;
            height: 5px;
        }
        input[type="number"] {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 4px 5px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        
        .drag-over {
            border: 2px dashed #fff;
            background-color: #333;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .expanded {
            transform: scale(1.1);
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="controls" style="overflow-y: auto; max-height: 80vh;">
        <h1>Crappy FFT Vocoder</h1>
        <div id="processingIndicator">Processing... thiss may take a while (website is frozen so you can do anything until it's done)</div>
        <canvas id="visualizer" width="800" height="400"></canvas>
        <div id="controls2">
        <input type="file" id="carrierInput" accept="audio/*,video/*" title="Choose an Input audio or video file" placeholder="Select Input audio or video file" />
        |
        <input type="file" id="audioInput" accept="audio/*,video/*" title="Choose an Carrier file for input" placeholder="Select Carrier audio file" />
        <br>
        <label for="decayType">Decay Type:</label>
        <select id="decayType">
            <option value="1">RMS</option>
            <option value="2">Peak</option>
        </select>
        |
        <label for="release">Release:</label>
        <input type="range" id="release" value="0" min="0" max="0.99" step="0.01" />
        |
        <label for="pitch">Pitch: 000</label>
        <input type="range" id="pitch" value="0" min="-24" max="24" step="1" />
        <br>
        <label for="BR_voc_Type">Broken vocoder:</label>
        <select id="BR_voc_Type"> <!--anything with F  L  A  T, i don't recomend using for vocoding -->
            <option value="0">OFF</option>
            <!--waveforms-->
            <option value="1">Triangle</option> <!--Best sounding (sounds like it's bit-crushed)-->
            <option value="5">Square</option> <!--F  L  A  T-->
            <option value="6">Sawtooth</option> <!--F  L  A  T  2-->
            <option value="11">semi-sine</option> <!--0 bass at all it's all treble (don't recomend for vocoding)-->
            <!--repeated functions-->
            <option value="2">double sine</option> <!--no bass (still good tho)-->
            <option value="7">triple sine</option> <!--same as double sine-->
            <option value="8">half sine</option> <!--it sounds like the bands are wide-->
            <option value="10">sine squared</option> <!--F  L  A  T  3-->
            <option value="14">sine cubed</option> <!--kinda like the trianle one-->
            <!--multiplication (sin(o*2))-->
            <option value="3">2 sine</option> <!--it's half sine but with more bass and it's wider-->
            <option value="4">3 sine</option> <!--B  A  S  S-->
            <option value="9">squared sine</option> <!--F  L  A  T  4-->
            <!--Special waves-->
            <option value="12">IDK</option> <!--i genuinely have no idea what this is but it sounds like a retro game comming from an old TV-->
            <option value="13">Noise</option> <!--F  L  A  T  5-->
            <option value="15">sine sine</option> <!--this is a joke, sin(o*sin(o))-->
            <option value="16">harmonics sq</option> <!--harmonic serries-->
            <option value="17">harmonics saw</option> <!--harmonic serries-->
            <option value="18">Bitwise</option> <!--sounds like Triangle but more bit-crushed-->
            <option value="19">Floor</option> <!--sounds like Triangle but more bit-crushed-->
        </select>
        |
        <label for="BR_out">Broken vocoder out</label>
        <select id="BR_out">
            <option value="1">Both</option>
            <option value="2">Input</option>
            <option value="3">Carrier</option>
        </select>
        <br>
        <label for="iterations">Iterations:</label>
        <input type="number" id="iterations" value="1" min="1" />
        it may get loud (or not, i don't recomend using this with long audio files)
        <br>
        <label for="volume">volume: 1.00</label>
        <input type="range" id="volume" value="1" min="0" max="2" step="0.01" />
        |
        <label for="clamp_output">Clamp out</label>
        <select id="clamp_output">
            <option value="0">Off</option>
            <option value="1">On</option>
            <option value="2">individual</option>
            <!--option value="3">Compressor</option-->
            <option value="4">individual (soft)</option>
        </select>
        |
        <label for="threshold">Clamp Threshold: 1.00</label>
        <input type="range" id="threshold" value="1" min="0" max="1" step="0.01"/>
        <br>
        <label for="divbands">Divide bands: 1</label>
        <input type="range" id="divbands" value="1" min="1" max="64"/>
        |
        <label for="FFTsize">FFT size: 2^10 (1024)</label>
        <input type="range" id="FFTsize" value="10" min="2" max="14" step="1"/>
        <br>
        <label for="BassBoost">Bass Boost: 0.00</label>
        <input type="range" id="BassBoost" value="0" min="-4" max="4" step=".01"/>
        |
        <label for="BassCurve">Bass Curve</label>
        <select id="BassCurve">
            <option value="0">+1</option>
            <option value="1">x/i</option>
            <option value="2">quadratic</option>
        </select>
        |
        <label for="EQType">Norm EQ type</label>
        <select id="EQType">
            <option value="0">original</option>
            <option value="1">sin</option>
        </select>
        <br>
        <label for="steps">Steps: OFF</label>
        <input type="range" id="steps" value="0" min="0" max="16" step="1"/>
        |
        <label for ="RoundType">Round Type</label>
        <select id="RoundType">
            <option value="0">Floor</option>
            <option value="1">Round</option>
            <option value="2">Ceil</option>
        </select>
        |
        <label for="SoundGoodizer">SoundGoodizer? OFF:</label>
        <input type="range" id="SoundGoodizer" value="0" min="0" max="1" step="0.01"/>
        <br>
        <label for="simpleChorus">simple Chorus</label>
        <select id="simpleChorus">
            <option value="0">OFF</option>
            <option value="1">sin</option>
            <option value="2">cos</option>
            <option value="3">asin</option>
            <option value="4">acos</option>
        </select>
        |
        <label for="speedType">speed</label>
        <select id="speedType">
            <option value="0">Auto</option>
            <option value="1">file length</option>
            <option value="2">user</option>
        </select>
        <label for="userSpeed">| speed: 1.00 Hz</label>
        <input type="range" id="userSpeed" value="1" min="0" max="100" step="0.01"/>
        <br>
        <button id="playButton" disabled>Play Audio</button>
        <button id="pauseButton" disabled>Pause Audio</button>
        <button id="stopButton" disabled>Stop Audio</button>
        <button id="downloadButton" disabled>Download Audio</button>
        <button id="reprocessButton" disabled>Reprocess Audio</button>
        <button id="helpButton">Help</button>
        </div>
        
        <div id="helpPopup" style="display: none;">
            <div style="background-color: #333; padding: 20px; border-radius: 10px; color: #fff; max-width: 600px; text-align: left; max-height: 80vh; overflow-y: auto;">
            <h2>Help</h2>
            <p>Welcome to the Crappy FFT Vocoder! Here are some instructions to get you started:</p>
            <ul>
            <li><strong>Decay Type:</strong> Choose between RMS and Peak for the decay type.</li>
            <li><strong>Release:</strong> Adjust the release time for the vocoder (0 is no release and 1 is max release).</li>
            <li><strong>Pitch:</strong> Adjust the pitch of the vocoded audio (input only).</li>
            <li><strong>Broken Vocoder Type:</strong> Select the type of broken vocoder effect.</li>
            <ul>
                <p>All the types with it's desciption I added</p>
                <li>Triangle: Best sounding (sounds like it's bit-crushed)</li>
                <li>Square: F L A T</li>
                <li>Sawtooth: F L A T 2</li>
                <li>semi-sine: 0 bass at all it's all treble (don't recommend for vocoding)</li>
                <li>double sine: no bass (still good tho)</li>
                <li>triple sine: same as double sine</li>
                <li>half sine: it sounds like the bands are wide</li>
                <li>sine squared: F L A T 3</li>
                <li>sine cubed: kinda like the triangle one</li>
                <li>2 sine: it's half sine but with more bass and it's wider</li>
                <li>3 sine: B A S S</li>
                <li>squared sine: F L A T 4</li>
                <li>IDK: i genuinely have no idea what this is but it sounds like a retro game coming from an old TV</li>
                <li>Noise: F L A T 5</li>
                <li>sine sine: this is a joke, sin(o*sin(o)) also very flat</li>
                <li>harmonics saw: harmonic series of a sawtooth also it's phase shifted by 90</li>
                <li>harmonics sq: harmonic series of a square also it's phase shifted by 90</li>
                <li>Bitwise: sounds like Triangle but more bit-crushed</li>
                <li>Floor: sounds like Triangle but more bit-crushed</li>
            </ul>
            <br>
            <li><strong>Broken Vocoder Out:</strong> Choose which audio to output (Both, Input, Carrier).</li>
            <li><strong>Iterations:</strong> Set the number of iterations for processing.</li>
            <li><strong>Volume:</strong> Adjust the volume of the output audio.</li>
            <li><strong>Divide Bands:</strong> Adjust the number of bands to divide the audio into.</li>
            <li><strong>Clamp Out:</strong> Choose whether to clamp the output audio (Off, On, individual bands).</li>
            <li><strong>Clamp Threshold:</strong> Adjust the threshold for clamping the output audio.</li>
            <li><strong>FFT Size:</strong> Adjust the size of the FFT (Fast Fourier Transform) used for processing.</li>
            <li><strong>Bass Boost:</strong> Adjust the Bass boost level for the audio. (putting it in the negatives won't decrease it, it will increase it in a different way)</li>
            <li><strong>Steps:</strong> Adjust the number of steps for quantizing the envelope (OFF means no quantization).</li>
            <li><strong>Round Type:</strong> Choose the rounding type for the steps (Floor, Round, Ceil).</li>
            <li><strong>Simple Chorus:</strong> Choose the type of simple chorus effect.</li>
            <li><strong>Speed:</strong> Choose the speed type for the chorus effect.</li>
            <li><strong>User Speed:</strong> Adjust the user-defined speed for the chorus effect.</li>
            <br>
            version 1.1 <!--current version-->
            Made by D3nschot (DX3050)
            <link rel="icon" type="image/png" href="favicon.png">
            </ul>
            <button id="closeHelpButton">Close</button>
            </div>
        </div>
        <script>
            const cornerElement = document.createElement('a');
            cornerElement.href = 'https://github.com/D3nschot/crappy-FFT-vocoder';
            cornerElement.style.position = 'fixed';
            cornerElement.style.bottom = '10px';
            cornerElement.style.right = '10px';
            cornerElement.style.backgroundColor = '#444';
            cornerElement.style.color = '#fff';
            cornerElement.style.padding = '10px';
            cornerElement.style.borderRadius = '5px';
            cornerElement.style.zIndex = '1000';
            cornerElement.textContent = 'Fork me on GitHub :)';
            document.body.appendChild(cornerElement);

            document.getElementById('helpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').style.display = 'block';
            });

            document.getElementById('closeHelpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').style.display = 'none';
            });

            function handleDragOver(event) {
                event.preventDefault();
                event.target.classList.add('drag-over');
                event.target.classList.add('expanded');
            }

            function handleDragLeave(event) {
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
                const fileInput = event.target;
                const files = event.dataTransfer.files;
                fileInput.files = files;

                // Trigger change event manually
                const changeEvent = new Event('change');
                fileInput.dispatchEvent(changeEvent);
            }

            document.getElementById('carrierInput').addEventListener('dragover', handleDragOver);
            document.getElementById('carrierInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('carrierInput').addEventListener('drop', handleDrop);

            document.getElementById('audioInput').addEventListener('dragover', handleDragOver);
            document.getElementById('audioInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('audioInput').addEventListener('drop', handleDrop);

            document.getElementById('speedType').addEventListener('change', function(event) {
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                if (event.target.value == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            });

            // Initialize the visibility of the speed slider based on the current selection
            document.getElementById('speedType').dispatchEvent(new Event('change'));
        </script></div>
    </div>
    <script>
        let audioContext, analyser, source, processedBuffer, audioData, carrierBuffer;
        let loadedAudioBuffer = null;
        let loadedCarrierBuffer = null;
        let playbackSource = null;

        function extractAudioFromVideo(file, callback) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.play();

            video.addEventListener('canplaythrough', function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                const recorder = new MediaRecorder(destination.stream);
                const chunks = [];

                recorder.ondataavailable = function(event) {
                    chunks.push(event.data);
                };

                recorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(blob);
                };

                recorder.start();
                video.play();
                setTimeout(() => {
                    recorder.stop();
                    video.pause();
                    URL.revokeObjectURL(video.src);
                }, video.duration * 1000);
            });
        }

        function handleFileInput(event, callback) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    extractAudioFromVideo(file, callback);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        document.getElementById('audioInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioData = e.target.result;
                    audioContext.decodeAudioData(audioData, function(buffer) {
                        loadedAudioBuffer = buffer;
                        processAudio(buffer);
                    }, function(error) {
                        console.error('Error decoding audio data:', error);
                        alert('Error decoding audio data. Please select a valid audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });


        document.getElementById('carrierInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const carrierData = e.target.result;
                    audioContext.decodeAudioData(carrierData, function(buffer) {
                        loadedCarrierBuffer = buffer;
                        carrierBuffer = buffer;
                    }, function(error) {
                        console.error('Error decoding input audio data:', error);
                        alert('Error decoding input audio data. Please select a valid input audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('reprocessButton').addEventListener('click', function() {
            if (loadedAudioBuffer && loadedCarrierBuffer) {
                processAudio(loadedAudioBuffer);
            } else {
                alert('Please load both audio and input files first.');
            }
        });

        document.getElementById('pitch').addEventListener('input', function(event) {
            document.querySelector('label[for="pitch"]').textContent = `Pitch: ${(parseFloat(event.target.value)<=0?parseFloat(event.target.value)==0?'0':'-':'+')+Math.abs(parseFloat(event.target.value)).toString().padStart(2, '0')}`;
        });

        document.getElementById('volume').addEventListener('input', function(event) {
            document.querySelector('label[for="volume"]').textContent = `volume: ${parseFloat(event.target.value).toFixed(2)}`;
        });
        
        document.getElementById('divbands').addEventListener('input', function(event) {
            document.querySelector('label[for="divbands"]').textContent = `Divide bands: ${parseFloat(event.target.value)}`;
        });

        document.getElementById('FFTsize').addEventListener('input', function(event) {
            document.querySelector('label[for="FFTsize"]').textContent = `FFT size: 2^${parseFloat(event.target.value)} (${2**parseFloat(event.target.value)})`;
        });
        
        document.getElementById('BassBoost').addEventListener('input', function(event) {
            document.querySelector('label[for="BassBoost"]').textContent = `Bass Boost: ${parseFloat(event.target.value).toFixed(2)}`;
        });

        document.getElementById('steps').addEventListener('input', function(event) {
            document.querySelector('label[for="steps"]').textContent = `Steps: ${parseFloat(event.target.value)?parseFloat(event.target.value).toFixed(2):'OFF'}`;
        });
        
        document.getElementById('threshold').addEventListener('input', function(event) {
            document.querySelector('label[for="threshold"]').textContent = `Clamp Threshold: ${parseFloat(event.target.value).toFixed(2)}`;
        });

        document.getElementById('userSpeed').addEventListener('input', function(event) {
            document.querySelector('label[for="userSpeed"]').textContent = `| speed: ${parseFloat(event.target.value).toFixed(2)} Hz`;
        });

        document.getElementById('SoundGoodizer').addEventListener('input', function(event) {
            document.querySelector('label[for="SoundGoodizer"]').textContent = `SoundGoodizer? ${parseFloat(event.target.value)!==0?parseFloat(event.target.value).toFixed(2):'OFF'}`;
        });

        function createLoopedBuffer(buffer, targetLength) {
            const sampleRate = buffer.sampleRate;
            const numberOfChannels = buffer.numberOfChannels;
            const newBuffer = audioContext.createBuffer(numberOfChannels, targetLength, sampleRate);
            
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const nowBuffering = newBuffer.getChannelData(channel);
                const originalData = buffer.getChannelData(channel);
                
                for (let i = 0; i < targetLength; i++) {
                    nowBuffering[i] = originalData[i % originalData.length];
                }
            }
            
            return newBuffer;
        }

        

        function processAudio(buffer) {
            if (!loadedCarrierBuffer) {
                alert('Please select a carrier audio file.');
                return;
            }

            // Show processing indicator
            document.getElementById('processingIndicator').style.display = 'block';

            // Get the number of iterations
            const iterations = parseInt(document.getElementById('iterations').value);
            if (iterations < 1) {
                alert('Please enter a valid number of iterations.');
                return;
            }

            if (iterations > 2) {
                if (iterations == 69) {
                    document.getElementById('processingIndicator').textContent = 'nice (this will take ages, it\'s frozen for longer too and probably loud af)';
                } else {
                    document.getElementById('processingIndicator').textContent = 'Processing... this will take a longer to process (website is frozen so you can do anything until it\'s done)';
                }
            }

            // Create looped version of input to match the carrier length
            const carrierDuration = loadedCarrierBuffer.length / loadedCarrierBuffer.sampleRate;
            const targetLength = Math.ceil(carrierDuration * buffer.sampleRate);
            buffer = createLoopedBuffer(buffer, targetLength);

            // Set up analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Float32Array(bufferLength);

            // Create a buffer source for the original audio
            source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Perform FFT and reconstruct audio using the provided logic
            const offlineContext = new OfflineAudioContext(2, buffer.length, buffer.sampleRate); // Stereo
            let offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = buffer;

            const offlineAnalyser = offlineContext.createAnalyser();
            offlineAnalyser.fftSize = 2048;
            const offlineFrequencyData = new Uint8Array(offlineAnalyser.frequencyBinCount);

            offlineSource.connect(offlineAnalyser);
            offlineAnalyser.connect(offlineContext.destination);

            offlineSource.start();
            offlineContext.startRendering().then(function(renderedBuffer) {
                let inputLeft = buffer.getChannelData(0);
                let inputRight = buffer.numberOfChannels > 1 ? buffer.getChannelData(1) : buffer.getChannelData(0);
                let carrierLeft = loadedCarrierBuffer.getChannelData(0);
                let carrierRight = loadedCarrierBuffer.numberOfChannels > 1 ? loadedCarrierBuffer.getChannelData(1) : loadedCarrierBuffer.getChannelData(0);

                for (let i = 0; i < iterations; i++) {
                    // Apply the provided logic to process the audio
                    processedBuffer = applyFFTLogic(offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer.sampleRate);

                    // Use the processed buffer as the new carrier for the next iteration
                    carrierLeft = processedBuffer.getChannelData(0);
                    carrierRight = processedBuffer.numberOfChannels > 1 ? processedBuffer.getChannelData(1) : processedBuffer.getChannelData(0);
                }

                // Enable buttons
                document.getElementById('playButton').disabled = false;
                document.getElementById('pauseButton').disabled = false;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('reprocessButton').disabled = false;

                // Hide processing indicator
                document.getElementById('processingIndicator').style.display = 'none';

                // Visualize the sine wave volumes
                visualize(offlineAnalyser, offlineFrequencyData);
            });
        }

        function applyFFTLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            const FFTsize = document.getElementById('FFTsize').value;
            const SIZE = 2 ** FFTsize;
            const OVERLAP = 4;
            const HOP_SIZE = SIZE / OVERLAP;
            const PI = Math.PI;
            const cos = Math.cos;
            const sin = Math.sin;
            const asin = Math.asin;
            const abs = Math.abs;

            const X = o => {
                switch (parseInt(document.getElementById('BR_voc_Type').value)) {
                    default:
                        return { r: cos(o), i: sin(o) }
                    case 1:
                        return { r: asin(cos(o)) / PI * 2.25, i: asin(sin(o)) / PI * 2.25 };
                    case 2:
                        return { r: sin(cos(o) * 2) * .9 , i: sin(sin(o) * 2) * .9};
                    case 3:
                        return { r: cos(o * 2) * .9, i: sin(o * 2) * .9};
                    case 4:
                        return { r: cos(o * 3) * .8, i: sin(o * 3) * .8}
                    case 5:
                        return { r: o / PI + PI / 4 & 1 ? 0.65 : -0.65, i: o / PI & 1 ? 0.65 : -0.65 }
                    case 6:
                        return { r: ((o / PI + PI / 4) % 2 - 1)/1.4 , i: ((o / PI)% 2 - 1) / 1.4 }
                    case 7:
                        return { r: sin(sin(cos(o) * 2) * 2) * .8 , i: sin(sin(sin(o) * 2) * 2) * .8}
                    case 8:
                        return { r: cos(o / 2) * 0.9, i: sin(o / 2) * 0.9}
                    case 9:
                        return { r: cos(o ** 2) * 0.95, i: sin(o ** 2) * 0.95 }
                    case 10:
                        return { r: cos(o) ** 2, i: sin(o) ** 2 }
                    case 11:
                        return { r: (-abs(cos(o / 2)) + 0.5) * 1.7, i: (-abs(sin(o / 2)) + 0.5) * 1.7}
                    case 12:
                        return { r: (abs(sin(o / 2 + PI / 2) ** 3) - 0.5) * 1.8, i: (abs(sin(o / 2 + PI / 4) ** 3) - 0.5) * 1.8 } // i genuinely have no idea what this is
                    case 13:
                        return { r: cos(rand(o/1e10)*PI)*.9, i: sin(rand(o/1e10)*PI)*.9 }
                    case 14:
                        return { r: cos(o) ** 3 * 1.15, i: sin(o) ** 3 * 1.15 }
                    case 15:
                        return { r: cos(o*cos(o)), i: sin(o*sin(o))/2 }
                    case 16:
                        return { r: harm(o+PI/2) * 0.8, i: harm(o) * 0.8 }
                    case 17:
                        return { r: harmS(o+PI/2) * 0.9, i: harmS(o) * 0.9 }
                    case 18:
                        return { r: cos((o*128/PI&o*127/PI)/128*PI), i: sin((o*128/PI|o*127/PI)/128*PI) }
                    case 19:
                        return { r: cos((o*4/PI|0)/4*PI), i: sin((o*4/PI|0)/4*PI) }
                }
            };
            const X2 = o => ({ r: cos(o), i: sin(o) }); //back up
            const M = (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + b.r * a.i });
            const A = (a, b) => ({ r: a.r + b.r, i: a.i + b.i });

            const FFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = { r: I[ii], i: 0 };
                else {
                    FFT(O, I, oi, ii, N / 2, s * 2);
                    FFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(-2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            const IFFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = I[ii];
                else {
                    IFFT(O, I, oi, ii, N / 2, s * 2);
                    IFFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            // Calculate the duration of the audio buffer
            const duration = inputLeft.length / sampleRate;

            // Create output buffer (stereo)
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);

            // Initialize buffers
            const I = Array.from({ length: SIZE }, () => 0);
            const O = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));
            const I2 = Array.from({ length: SIZE }, () => 0);
            const O2 = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));

            const pitch = parseInt(document.getElementById('pitch').value);
            const divbands = parseInt(document.getElementById('divbands').value);

            const DecayType = parseInt(document.getElementById('decayType').value);
            const Release = parseFloat(document.getElementById('release').value) ** (1 / (4 + (divbands - 1) * 2));
            const BassBoost = parseFloat(document.getElementById('BassBoost').value);

            const envelopeStateLeft = Array(SIZE).fill(0);
            const envelopeStateRight = Array(SIZE).fill(0);

            const window = Array.from({ length: SIZE }, (_, i) =>
                0.5 * (1 - Math.cos(2 * Math.PI * i / (SIZE - 1)))
            );

            const clampOut = parseFloat(document.getElementById('clamp_output').value);
            const Threshold = parseFloat(document.getElementById('threshold').value);

            // Process left and right channels separately
            const processChannel = (inputData, carrierData, outputData, envelopeState) => {
                const startTime = performance.now();

                for (let t = 0; t < inputData.length; t += HOP_SIZE) {
                    const currentTime = (performance.now() - startTime) / 1000; // Current time in seconds

                    // Fill input buffer for input data with windowing
                    for (let i = 0; i < SIZE; i++) {
                        I[i] = (inputData[t + i] || 0) * window[i];
                        I2[i] = (carrierData[t + i] || 0) * window[i];
                    }

                    // Perform FFT on input data
                    FFT(O, I, 0, 0, SIZE, 1);

                    // Perform FFT on carrier data
                    FFT(O2, I2, 0, 0, SIZE, 1);

                    // Modulate frequency components
                    for (let i = 0; i < SIZE; i++) {
                        let timer = currentTime; // Timer value between 0 and 1
                        const speedType = parseInt(document.getElementById('speedType').value)

                        switch (speedType) {
                            case 0:
                                timer = currentTime / 8;
                                break;
                            case 1:
                                timer = currentTime / duration;
                                break;
                            case 2:
                                timer = currentTime * parseFloat(document.getElementById('userSpeed').value);
                                break;
                        }

                        // Apply envelope following
                        let envelope = 0;
                        const mag1 = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                        let mag2 = 0;
                        let ip = 0;
                        let ip_ = 0;
                        const Ratio = (SIZE / 1024);

                        let callCount = 0;

                        const lin = (a, b, t) => a * (1 - t) + b * t;

                        // divide bands
                        for (let j = 0; j <= divbands; j++) {
                            ip = (i * 2 ** (-pitch / 12) | 0);
                            const weight = 1 - abs(j - divbands / 2) / divbands;

                            ip_ = Math.round(ip + (j - divbands / 2));
                            if (ip_ < 0) ip_ = 0;

                            mag2 += ((ip_ < SIZE) ? Math.sqrt(O2[ip_].r * O2[ip_].r + O2[ip_].i * O2[ip_].i) : 0) * weight;

                            const REL = Math.min((1 - Release) * Ratio, 1);

                            switch (DecayType) {
                                case 1: // RMS
                                    envelopeState[i] = (1 - REL) * envelopeState[i] + REL * mag2 * mag2;
                                    envelope += Math.sqrt(envelopeState[i]);
                                    break;
                                case 2: // Peak
                                    envelopeState[i] = Math.max(mag2, envelopeState[i] * (1 - REL));
                                    envelope += envelopeState[i];
                                    break;
                            }
                            // somehow (1 + 2 / divbands / 2) solved the volume issue
                            envelope /= divbands * ((1 + 2 / divbands) / 2);
                        }

                        // Apply modulation with normalization and volume with BassBoost
                        const BassCurveType = parseInt(document.getElementById('BassCurve').value);
                        const normEQcurveType = parseInt(document.getElementById('EQType').value);

                        let BassCurve = 0;
                        switch (BassCurveType) {
                            case 0:
                                BassCurve = 1;
                                break;
                            case 1:
                                BassCurve = 10 / (i + 1);
                                break;
                            case 2:
                                BassCurve = ((1 - i / SIZE) ** 2);
                                break;
                        }

                        let normEQcurve = 0;
                        switch (normEQcurveType) {
                            case 0:
                                normEQcurve = Math.min(1, (i < SIZE / 2 ? i : SIZE - i) / (SIZE / 4));
                                break;
                            case 1:
                                normEQcurve = Math.sin(i / SIZE * PI);
                                break;
                        }

                        // Example calculation using the timer
                        let modulatedValue = 1
                        const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
                        const modulatedInput = i*((timer*256|0)/256);

                        switch (simpleChorus) {
                            case 1:
                                modulatedValue = cos(modulatedInput*PI);
                                break;
                            case 2:
                                modulatedValue = cos(modulatedInput*PI);
                                break;
                            case 3:
                                modulatedValue = asin(sin(modulatedInput*PI));
                                break;
                            case 4:
                                modulatedValue = asin(cos(modulatedInput*PI));
                                break;
                        }

                        soundgoodizer = parseFloat(document.getElementById('SoundGoodizer').value);
                        const normEQ = (normEQcurve + BassBoost * BassCurve / (Math.sqrt(Ratio)*1024) * 20) * modulatedValue * lin(1, ((i/SIZE)**150*15+((i/SIZE)**150-1)*2-sin(i/SIZE*PI)*4)/2, soundgoodizer)

                        // Apply modulation based on BR_out value
                        switch (parseInt(document.getElementById('BR_out').value)) {
                            case 1:
                                O[i] = M(O[i], X(2 * PI * i / SIZE));
                                O2[i] = M(O2[i], X(2 * PI * i / SIZE));
                                break;
                            case 3:
                                O[i] = M(O[i], X2(2 * PI * i / SIZE));
                                break;
                            case 2:
                                O2[i] = M(O2[i], X2(2 * PI * i / SIZE));
                                break;
                        }

                        const volume = document.getElementById('volume').value / Math.sqrt(Ratio);

                        const steps = parseFloat(document.getElementById('steps').value);
                        const RoundType = [Math.floor, Math.round, Math.ceil][parseInt(document.getElementById('RoundType').value)];
                        envelope = steps ? RoundType(envelope * (steps / 16)) / (steps / 16) : envelope;

                        O[i].r *= envelope * volume * normEQ;
                        O[i].i *= envelope * volume * normEQ;

                        if (clampOut == 2) {
                            O[i].r = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].r));
                            O[i].i = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].i));
                        }
                    }

                    let frequencyMagnitudes = Array(SIZE).fill(0);
                    if (clampOut == 4) {
                        for (let i = 0; i < SIZE; i++) {
                            const ratio = 2; // Compression ratio

                            // Calculate the magnitude of the frequency component
                            const magni = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                            frequencyMagnitudes[i] = Math.sqrt((frequencyMagnitudes[i] ** 2 * 24 + magni ** 2) / 25);
                            let level = frequencyMagnitudes[i];

                            let gain = Math.min(1, (Threshold / level) ** (ratio - 1)); // Compute gain reduction

                            O[i].r *= gain;
                            O[i].i *= gain;
                        }
                    }
                    // Perform IFFT
                    IFFT(I, O, 0, 0, SIZE, 1);

                    // Overlap-add with windowing
                    for (let i = 0; i < SIZE; i++) {
                        const inputt =  outputData[t + i] + I[i].r / SIZE * window[i];
                        if (clampOut == 1) {
                            outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt));
                        } else {
                            outputData[t + i] += (I[i].r / SIZE) * window[i];
                        }
                    }
                }
            };

            // Process left channel
            processChannel(inputLeft, carrierLeft, outputLeft, envelopeStateLeft);

            // Process right channel
            processChannel(inputRight, carrierRight, outputRight, envelopeStateRight);

            return outputBuffer;
        }

        function visualize(analyser, dataArray) {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;

            function draw() {
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i];
                const B255 = (Math.min(barHeight, 255) / 255) ** 1.5 * 255;
                ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                ctx.fillRect(x, canvas.height - barHeight * 1.56, barWidth, barHeight * 1.56);

                x += barWidth + 1;
            }

            requestAnimationFrame(draw);
            }

            draw();
        }

        document.getElementById('playButton').addEventListener('click', function() {
            if (processedBuffer) {
                playbackSource = audioContext.createBufferSource();
                playbackSource.buffer = processedBuffer; // Play the processed buffer stored in RAM
                playbackSource.connect(audioContext.destination);

                // Set up a new analyser for playback visualization
                const playbackAnalyser = audioContext.createAnalyser();
                playbackAnalyser.fftSize = 2048;
                const playbackFrequencyData = new Uint8Array(playbackAnalyser.frequencyBinCount);

                playbackSource.connect(playbackAnalyser);
                playbackAnalyser.connect(audioContext.destination);

                // Visualize the playback audio
                visualize(playbackAnalyser, playbackFrequencyData);

                playbackSource.start();
            }
        });

        document.getElementById('pauseButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('stopButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('downloadButton').addEventListener('click', function() {
            const carrierName = document.getElementById('carrierInput').files[0].name.split('.').slice(0, -1).join('.');
            if (processedBuffer) {
            const wavBuffer = bufferToWav(processedBuffer);
            const blob = new Blob([wavBuffer], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${carrierName} (vocoded).wav`;
            a.click();
            URL.revokeObjectURL(url);
            }
        });

        function bufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = loadedCarrierBuffer.length * numOfChan * 2 + 44; // Use carrier buffer length
            const bufferArray = new ArrayBuffer(length);
            const view = new DataView(bufferArray);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length

            // Write interleaved audio data
            let offset = 44;
            for (let i = 0; i < loadedCarrierBuffer.length; i++) { // Use carrier buffer length
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
