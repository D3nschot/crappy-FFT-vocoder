<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="https://d3nschot.github.io/crappy-FFT-vocoder/IconCFFTV.png">
    <title>Crappy FFT Vocoder</title>
    <style>
        /* Base text styling */
        label, span, p, h1, h2, h3, h4, h5, h6 {
            color: #ddd;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Bold or strong text */
        strong, b {
            color: #fff;
        }

        /* Headings */
        h1, h2, h3 {
            color: #fff;
            margin: 0.5em 0;
            font-weight: bold;
        }

        /* Subtle/inactive or muted text */
        .text-muted {
            color: #888;
            font-size: 0.9em;
            font-style: italic;
        }

        /* Informational (e.g. helper text) */
        .text-info {
            color: #5ac8fa;
            font-size: 0.95em;
        }

        /* For sliders and live values */
        .value-label {
            margin-left: 6px;
            color: #aaa;
            font-family: monospace;
            font-size: 0.95em;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-height: 100vh;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Header Section */
        .header-section {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #Title {
            font-size: clamp(24px, 5vw, 48px);
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #5ac8fa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        #Title:hover {
            transform: scale(1.05);
        }

        #what_is {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .author {
            color: #aaa;
            font-size: 12px;
        }

        #randomQuote {
            margin-top: 15px;
            padding: 10px;
            background: rgba(90, 200, 250, 0.1);
            border-radius: 8px;
            font-style: italic;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #randomQuote:hover {
            background: rgba(90, 200, 250, 0.2);
        }

        /* Canvas and Visualizer */
        .visualizer-section {
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #visualizer, #filterView {
            max-width: 100%;
            height: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Controls Layout */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(90, 200, 250, 0.3);
            font-size: 18px;
        }

        /* Form Controls */
        .form-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .form-group:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .form-group label {
            min-width: 120px;
            flex-shrink: 0;
            font-weight: 500;
        }

        .form-control {
            flex: 1;
            min-width: 100px;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* File Inputs */
        input[type="file"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
            font-size: 14px;
        }

        input[type="file"]:hover {
            border-color: #5ac8fa;
            background: rgba(90, 200, 250, 0.1);
        }

        input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            margin-right: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        input[type="file"]::file-selector-button:hover {
            background: linear-gradient(135deg, #007acc 0%, #005999 100%);
            transform: scale(1.05);
        }

        /* Select Dropdowns */
        select {
            background: rgba(68, 68, 68, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 120px;
        }

        select:hover, select:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Range Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            min-width: 120px;
            height: 6px;
            background: rgba(68, 68, 68, 0.8);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 15px rgba(90, 200, 250, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
        }

        /* Number Inputs */
        input[type="number"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }

        input[type="number"]:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Text Inputs and Textareas */
        input[type="text"], textarea {
            background: rgba(34, 34, 34, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            width: 100%;
            resize: vertical;
            min-height: 60px;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #5ac8fa;
            box-shadow: 0 0 10px rgba(90, 200, 250, 0.2);
        }

        /* Checkboxes */
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #5ac8fa;
        }

        /* Keyboard Section */
        .keyboard-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .keyboard-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 2px;
        }

        .key-button {
            position: relative;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            text-align: center;
            padding-top: 30px;
        }

        .key-button.white {
            background: #fff;
            color: #000;
            width: 40px;
            height: 120px;
        }

        .key-button.black {
            background: #222;
            color: #ccc;
            width: 25px;
            height: 80px;
            z-index: 2;
            margin-left: -12px;
            margin-right: -12px;
        }

        .key-button:hover {
            transform: translateY(-2px);
        }

        .key-button.active {
            background: #0055ff !important;
            color: #fff !important;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-top: 20px;
        }

        .action-buttons button {
            min-width: 120px;
        }

        /* Drag and Drop */
        .drag-over {
            border-color: #5ac8fa !important;
            background: rgba(90, 200, 250, 0.1) !important;
            transform: scale(1.02);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .form-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .form-group label {
                min-width: unset;
                width: 100%;
                margin-bottom: 5px;
            }

            .form-control {
                width: 100%;
            }

            input[type="range"] {
                min-width: unset;
            }

            .action-buttons {
                flex-direction: column;
            }

            .action-buttons button {
                min-width: unset;
                width: 100%;
            }

            #visualizer {
                width: 100%;
                height: 200px;
            }

            .keyboard-row {
                overflow-x: auto;
                padding-bottom: 10px;
            }

            .key-button.white {
                width: 35px;
                height: 100px;
            }

            .key-button.black {
                width: 20px;
                height: 65px;
                margin-left: -10px;
                margin-right: -10px;
            }
        }

        @media (max-width: 480px) {
            .control-panel {
                padding: 15px;
            }

            #Title {
                font-size: 24px;
            }

            button {
                padding: 12px 16px;
                font-size: 16px;
            }

            .form-group {
                margin-bottom: 20px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1200px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .main-container {
                padding: 20px;
            }
        }

        /* Dark mode enhancements */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            }
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-panel {
            animation: fadeIn 0.6s ease-out;
        }

        /* Utility classes */
        .hidden { display: none !important; }
        .visible { display: block !important; }
        
        /* Separator */
        .separator {
            display: inline-block;
            margin: 0 10px;
            color: #666;
        }

        /* Value display */
        .auto-value-span {
            color: #5ac8fa;
            font-family: monospace;
            font-weight: 500;
        }

        /* Corner GitHub link */
        .github-corner {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            padding: 12px 16px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .github-corner:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #666 0%, #888 100%);
        }

        @media (max-width: 768px) {
            .github-corner {
                bottom: 10px;
                right: 10px;
                padding: 10px 12px;
                font-size: 12px;
            }
        }

        /* New styles for the thinner synth keyboard */
        #synthKeyboardContainer .key-button.white {
            width: 15px; /* Thinner width for white keys */
            height: 80px; /* Height remains the same */
            padding-top: 15px; /* Padding for text */
            font-size: 8px; /* Smaller font size */
        }

        #synthKeyboardContainer .key-button.black {
            width: 10px; /* Thinner width for black keys */
            height: 40px; /* Height remains the same */
            font-size: 8px; /* Smaller font size */
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header Section -->
        <div class="header-section">
            <div id="Title">Crappy 4ormulator clone</div>
            <div id="what_is">an 4ormulator clone</div>
            <div class="author">by DX3050/D3nschot</div>
            <div id="randomQuote" style="display: none;">FFT? I only know it as Functional Family Therapy</div>
        </div>

        <!-- Visualizer Section -->
        <div class="visualizer-section">
            <canvas id="visualizer" width="800" height="400"></canvas>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button id="playButton" disabled>Play Audio</button>
            <button id="pauseButton" disabled>Pause Audio</button>
            <button id="stopButton" disabled>Stop Audio</button>
            <button id="downloadButton" disabled>Download Audio</button>
            <button id="reprocessButton" disabled>Reprocess Audio</button>
            <button id="helpButton">Help</button>
        </div>

        <!-- Controls Grid -->
        <div class="controls-grid">
            <!-- Mode Control Panel -->
            <div class="control-panel">
                <h3>Mode & Files</h3>
                
                <div class="form-group">
                    <button id="changeBackButton">Change to FFT Mode</button>
                    <button id="ViewProperties">View Properties</button>
                </div>

                <!--it's swaped, i ain't gonna fix it-->
                <div class="form-group">
                    <label for="carrierInput">Audio Input:</label>
                    <input type="file" id="carrierInput" class="form-control" draggable="true">
                </div>

                <div class="form-group">
                    <label for="audioInput">Carrier Input:</label>
                    <input type="file" id="audioInput" class="form-control" draggable="true">
                </div>
            </div>

            <!--synth-->
            <div class="control-panel">
                <h3>Synth</h3>
                
                <div class="form-group">
                    <label for="enableSynth">Enable Synth:</label>
                    <input type="checkbox" id="enableSynth">
                </div>

                <div class="form-group">
                    <label for="synthWaveform">Waveform:</label>
                    <select id="synthWaveform" class="form-control">
                        <option value="0">sine</option>
                        <option value="1">triangle</option>
                        <option value="2" selected>sawtooth</option>
                        <option value="3">square</option>
                        <option value="4">PWM</option>
                        <option value="5">Brigth noise</option>
                        <option value="6">OV tri</option>
                        <option value="7">OV indigo</option>
                        <option value="8">TriSaw</option>
                        <option value="10">OV indigo min</option>
                        <option value="11">OV strings</option>
                        <option value="12">OV unisono</option>
                        <option value="13">OV strings + unisono</option>
                        <option value="14">VX Power (Not Perfect)</option>
                        <option value="15">damped saw</option>
                        <option value="16">VX Phased</option>
                        <option value="17">VX chip (Arp)</option>
                        <option value="9">Noise</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="synthVolume">Synth Volume:</label>
                    <input type="range" id="synthVolume" min="0" max="2" step="0.01" value="0.5">
                </div>

                <div class="form-group">
                    <label for="synthOctave">Octave Shift:</label>
                    <input type="range" id="synthOctave" min="-3" max="3" step="1" value="0">
                </div>

                <div class="form-group">
                    <label for="synthDetune">Detune Amount:</label>
                    <input type="range" id="synthDetune" min="0" max="1" step="0.01" value="0.02">
                </div>

                <div class="form-group">
                    <label for="synthVoices">Voice Count:</label>
                    <input type="range" id="synthVoices" min="1" max="8" step="1" value="1">
                </div>

                <div class="form-group">
                    <label for="OVDistort">Orange Distort</label>
                    <input type="range" id="OVDistort" min="0" max="1" step="0.01" value="0">
                </div>

                <div class="form-group">
                    <label for="SynthOnly">Synth only:</label>
                    <input type="checkbox" id="SynthOnly">
                </div>

                <label>Synth Keyboard:</label>
                <div class="keyboard-section">
                    <div class="keyboard-container" id="synthKeyboardContainer"></div>
                </div>
            </div>



                <script>
                    // Re-using the semitoneNames and heldNotes from the original script
                    const semitoneNames = [
                        { name: 'C', black: false },
                        { name: 'C#', black: true },
                        { name: 'D', black: false },
                        { name: 'D#', black: true },
                        { name: 'E', black: false },
                        { name: 'F', black: false },
                        { name: 'F#', black: true },
                        { name: 'G', black: false },
                        { name: 'G#', black: true },
                        { name: 'A', black: false },
                        { name: 'A#', black: true },
                        { name: 'B', black: false },
                    ];

                    const synthHeldNotes1 = new Set(); // Use a separate set for the first synth notes
                    const synthKeyboardContainer1 = document.getElementById("synthKeyboardContainer");
                    const synthTotalKeys = 72; // Total number of keys
                    const synthBaseNote = 48; // Starting from C3 (MIDI note 48)

                    // Render the synth keyboard
                    function renderSynthKeyboard(container, heldNotes) {
                        container.innerHTML = '';
                        
                        const synthTotalKeys = 72;
                        const synthBaseNote = 36; // C2 instead of C3 for more range
                        const synthKeysPerRow = 24;

                        let currentRowDiv;

                        for (let k = 0; k < synthTotalKeys; k++) {
                            if (k % synthKeysPerRow === 0) {
                                currentRowDiv = document.createElement("div");
                                currentRowDiv.className = "keyboard-row";
                                container.appendChild(currentRowDiv);
                            }

                            const midiNote = synthBaseNote + k;
                            const noteIndexInOctave = k % 12;
                            const name = semitoneNames[noteIndexInOctave];
                            const isBlack = name.black;

                            const btn = document.createElement("button");
                            btn.className = `key-button ${isBlack ? 'black' : 'white'}`;
                            btn.dataset.note = midiNote;
                            btn.textContent = name.name;

                            if (isBlack) {
                                btn.style.marginLeft = "-25px";
                                btn.style.marginRight = "-25px";
                            } else {
                                btn.style.marginLeft = "0";
                                btn.style.marginRight = "0";
                            }

                            if (heldNotes.has(midiNote)) {
                                btn.classList.add('active');
                            }

                            btn.addEventListener("click", () => {
                                if (heldNotes.has(midiNote)) {
                                    heldNotes.delete(midiNote);
                                    btn.classList.remove('active');
                                    //console.log(`Synth Note Off: ${midiNote}`);
                                } else {
                                    heldNotes.add(midiNote);
                                    btn.classList.add('active');
                                    //console.log(`Synth Note On: ${midiNote}`);
                                }
                            });

                            currentRowDiv.appendChild(btn);
                        }
                    }

                    // Call the render function for the keyboard when the DOM is loaded
                    document.addEventListener('DOMContentLoaded', () => {
                        renderSynthKeyboard(synthKeyboardContainer1, synthHeldNotes1);
                        // Add event listener for window resize to re-render if layout changes
                        window.addEventListener('resize', () => {
                            renderSynthKeyboard(synthKeyboardContainer1, synthHeldNotes1);
                        });
                    });

                    // Global synth state
                    const synthState = {
                        heldNotes: new Set(),
                        enabled: false,
                        waveform: 0,
                        volume: 0.5,
                        octave: 0,
                        detune: 0,
                        voices: 1,
                        t: 0 // Global time counter
                    };
                </script>


            </div>

            <!-- Basic Controls Panel -->
            <div class="control-panel">
                <h3>Basic Controls</h3>
                
                <div class="form-group">
                    <label for="decayType">Decay Type:</label>
                    <select id="decayType" class="form-control">
                        <option value="1">RMS</option>
                        <option value="2">Peak</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="release">Release:</label>
                    <input type="range" id="release" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="pitch">Pitch:</label>
                    <input type="range" id="pitch" value="0" min="-24" max="24" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BandShift">Shift:</label>
                    <input type="range" id="BandShift" value="0" min="-100" max="100" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FreqFlip">Flip:</label>
                    <input type="checkbox" id="FreqFlip">
                </div>

                <div class="form-group">
                    <label for="SoundGoodizer">SoundGoodizer:</label>
                    <input type="range" id="SoundGoodizer" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>
            </div>

            <!-- FFT Controls Panel -->
            <div id="FFTcontrols" class="control-panel hidden">
                <h3>FFT Vocoder Settings</h3>

                <div class="form-group">
                    <label for="FFTmode">FFT Mode:</label>
                    <select id="FFTmode" class="form-control">
                        <option value="0">OVDX</option>
                        <option value="1">Colorized</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="BandBreak">Band Break:</label>
                    <input type="checkbox" id="BandBreak">
                </div>

                <div class="form-group">
                    <label for="BR_voc_Type">Broken vocoder:</label>
                    <select id="BR_voc_Type" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">Triangle</option>
                        <option value="5">Square</option>
                        <option value="6">Sawtooth</option>
                        <option value="11">semi-sine</option>
                        <option value="2">double sine</option>
                        <option value="7">triple sine</option>
                        <option value="8">half sine</option>
                        <option value="10">sine squared</option>
                        <option value="14">sine cubed</option>
                        <option value="3">2 sine</option>
                        <option value="4">3 sine</option>
                        <option value="9">squared sine</option>
                        <option value="12">IDK</option>
                        <option value="13">Noise</option>
                        <option value="15">sine sine</option>
                        <option value="16">harmonics sq</option>
                        <option value="17">harmonics saw</option>
                        <option value="18">Bitwise</option>
                        <option value="19">Floor</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="BR_out">Broken vocoder out:</label>
                    <select id="BR_out" class="form-control">
                        <option value="1">Both</option>
                        <option value="2">Input</option>
                        <option value="3">Carrier</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="volume">Volume:</label>
                    <input type="range" id="volume" value="1" min="0" max="2" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="clamp_output">Clamp out:</label>
                    <select id="clamp_output" class="form-control">
                        <option value="0">Off</option>
                        <option value="1">On</option>
                        <option value="2">individual</option>
                        <!--option value="4">individual (soft)</option-->
                    </select>
                </div>

                <div class="form-group">
                    <label for="threshold">Clamp Threshold:</label>
                    <input type="range" id="threshold" value="1" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="divbands">Divide bands:</label>
                    <input type="range" id="divbands" value="1" min="1" max="64" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FFTsize">FFT size:</label>
                    <input type="range" id="FFTsize" value="10" min="2" max="14" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassBoost">Bass Boost:</label>
                    <input type="range" id="BassBoost" value="0" min="-4" max="4" step=".01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassCurve">Bass Curve:</label>
                    <select id="BassCurve" class="form-control">
                        <option value="0">+1</option>
                        <option value="1">x/i</option>
                        <option value="2">quadratic</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="reverbAMT">reverb amount</lebel>
                    <input type="range" id="reverbAMT" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <lebel for="reverbSIZE">reverb size (decay)</lebel>
                    <input type="range" id="reverbSIZE" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="EQType">Norm EQ type:</label>
                    <select id="EQType" class="form-control">
                        <option value="0">original</option>
                        <option value="1">sin</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="steps">Steps:</label>
                    <input type="range" id="steps" value="0" min="0" max="16" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="RoundType">Round Type:</label>
                    <select id="RoundType" class="form-control">
                        <option value="0">Floor</option>
                        <option value="1">Round</option>
                        <option value="2">Ceil</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="simpleChorus">Simple Chorus:</label>
                    <select id="simpleChorus" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">sin</option>
                        <option value="2">cos</option>
                        <option value="3">asin</option>
                        <option value="4">acos</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="speedType">Speed:</label>
                    <select id="speedType" class="form-control">
                        <option value="0">Auto</option>
                        <option value="1">file length</option>
                        <option value="2">user</option>
                    </select>
                </div>

                <div class="form-group hidden">
                    <label for="userSpeed">Speed:</label>
                    <input type="range" id="userSpeed" value="1" min="0" max="100" step="0.01" class="form-control">
                </div>
            </div>

            <!-- Analog Controls Panel -->
            <div id="analogControls" class="control-panel hidden">
                <h3>Analog Vocoder Settings</h3>

                <div class="form-group">
                    <label for="AutoUpdateFilters">Auto-update Filters:</label>
                    <input type="checkbox" id="AutoUpdateFilters" checked>
                    <button id="ManualStudyFilters" class="hidden">Update Study Filters</button>
                </div>

                <div class="visualizer-section">
                    <canvas id="filterView" width="700" height="100"></canvas>
                </div>

                <div class="form-group">
                    <label for="TotalBands">Total Bands:</label>
                    <input type="range" id="TotalBands" value="40" min="1" max="1024" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance">Resonance:</label>
                    <input type="range" id="Resonance" value=".9999" min="0" max=".9999" step="0.0001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BPwidth">Bandpass Width:</label>
                    <input type="range" id="BPwidth" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Volboost">Volume Boost:</label>
                    <input type="range" id="Volboost" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="DBperOct">dB per Octave:</label>
                    <input type="range" id="DBperOct" value="8" min="1" max="8" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Alt_BP">Alt Bandpass:</label>
                    <select id="Alt_BP" class="form-control">
                        <option value="0">Default</option>
                        <option value="1">normal</option>
                        <option value="2">weird</option>
                        <option value="3">fast</option>
                        <option value="4">3FLT</option>
                        <option value="5">ApLp</option>
                        <option value="6">True Cascade (slow)</option>
                        <option value="7" selected>True Cascade2 (slow)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="decayByFreq">Decay by Frequency:</label>
                    <select id="decayByFreq" class="form-control">
                        <option value="0">fixed</option>
                        <option value="1">High priority</option>
                        <option value="2">Low priority</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="freqCurve">Frequency Curve:</lebel>
                    <select id="freqCurve" class="form-control">
                        <option value="0">linear</option>
                        <!--option value="1">logarithmic</option>
                        <option value="2">exponential</option-->
                        <option value="3">exponential (base2)</option>
                        <option value="4">squared</option>
                        <option value="5" selected>Audaciy aproxinarion</option>
                        <option value="6">Vocodex aproxinarion</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="UseResBasedOnDistance">Use Resonance Based on Distance:</lebel>
                    <input type="checkbox" id="UseResBasedOnDistance" checked>
                </div>

                <!--adds -->
                <div class="form-group">
                    <label for="addLPtoLowEnd">Add LP to Low End:</label>
                    <input type="checkbox" id="addLPtoLowEnd">
                </div>

                <div class="form-group">
                    <label for="addHPtoHighEnd">Add HP to High End:</label>
                    <input type="checkbox" id="addHPtoHighEnd">
                </div>

                <div class="form-group">
                    <i>
                        Recommended settings for <strong>Analog Mode</strong>: <br>
                        this is primarily for the option <strong>Audaciy aproxinarion</strong> and <strong>Vocodex aproxinarion</strong>. <br>
                        Use <strong>20 Bands</strong> for an <strong>Audacity-like</strong> sound, or <strong>47 Bands</strong> for a <strong>Vocodex-like</strong> sound. <br>
                        Set the <strong>Filter Type</strong> to <strong>True Cascade2</strong> for <strong>Audacity-like</strong>, or <strong>True Cascade</strong> for <strong>Vocodex-like</strong>. <br>
                        Adjust <strong>Resonance</strong> to <strong>0.9999</strong> (with <strong>Use Resonance Based on Distance</strong>) for <strong>Audacity-like</strong>,  
                        or to <strong>0.85</strong> (without <strong>Use Resonance Based on Distance</strong>) for <strong>Vocodex-like</strong>. <br>
                        It is also recommended to enable <strong>SoundGoodizer</strong> at <strong>0.1-0.3</strong> for a <strong>Vocodex-like</strong> sound,  
                        but leave it <strong>off</strong> for <strong>Audacity-like</strong>. <br>
                        Finally set <strong>dB</strong> to <strong>48 dB per oct</strong> for both modes. <br>
                    </i>

                </div>
            </div>

            <!-- 4ormulator Controls Panel -->
            <div id="4ormClone" class="control-panel hidden">
                <h3>4ormulator Settings</h3>

                <div class="form-group">
                    <label for="Ag">Base frequency:</label>
                    <input type="range" id="Ag" value=".125" min="0" max="1" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance4orm">Resonance:</label>
                    <input type="range" id="Resonance4orm" value="0.999" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormFilterType">Filter Type:</label>
                    <select id="4ormFilterType" class="form-control">
                        <option value="0">ApLp</option>
                        <option value="1">Lp12</option>
                        <option value="2">BP12</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="UseArrLength">Use Array Length:</label>
                    <input type="checkbox" id="UseArrLength">
                </div>

                <div class="form-group">
                    <label for="MaxHarm">Max Harmonics:</label>
                    <input type="range" id="MaxHarm" value="16" min="1" max="1000" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormVolume">Volume:</label>
                    <input type="range" id="4ormVolume" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="use_gen">Use generator:</label>
                    <input type="checkbox" id="use_gen">
                </div>

                <div class="form-group">
                    <label for="gen_type">Generator (filtered):</label>
                    <select id="gen_type" class="form-control">
                        <option value="0">Input 2</option>
                        <option value="1">sine</option>
                        <option value="2">triangle</option>
                        <option value="3">sawtooth</option>
                        <option value="4">PWM</option>
                        <option value="5">Noise</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="PWMwidth">PWM width:</label>
                    <input type="range" id="PWMwidth" value="0.5" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="resonance2">Resonance 2:</label>
                    <input type="range" id="resonance2" value="0.99" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Harmonics">Offsets (Array only):</label>
                    <textarea id="Harmonics" class="form-control">[-5,2,7,10].map((i)=&gt;2**((i+3)/12)*Math.PI/128/HZ*2048*440)</textarea>
                </div>

                <!-- Harmonics Buttons -->
                <div class="keyboard-section">
                    <div id="harm">
                        <h3>Harmonics</h3>
                        <!-- This will be populated with buttons H1-H12 -->
                    </div>
                </div>

                <!-- Easy Mode Keyboard -->
                <div class="keyboard-section">
                    <div id="easyKeyboard">
                        <h3>Easy Mode Keyboard</h3>
                        <div class="keyboard-container" id="keyboardContainer">
                            <!-- Keyboard will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Processing Controls Panel -->
            <div class="control-panel">
                <h3>Processing</h3>
                
                <div class="form-group">
                    <label for="iterations">Iterations:</label>
                    <input type="number" id="iterations" value="1" min="1" class="form-control">
                    <small class="text-muted">It may get loud (or not, I don't recommend using this with long audio files)</small>
                </div>
            </div>
        </div>

        <!-- Help Popup -->
        <div id="helpPopup" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; display: flex; align-items: center; justify-content: center;">
            <div style="background: #333; padding: 30px; border-radius: 15px; color: #fff; max-width: 90vw; max-height: 90vh; overflow-y: auto; width: 600px;">
                <h2>Help</h2>
                <p>Welcome to the Crappy FFT Vocoder!</p>
                <p>This is a Fast Fourier Transform based vocoder that uses a lot of math to process audio files.</p>
                <p><strong>What is FFT?</strong></p>
                <p>The Fast Fourier Transform (FFT) is an algorithm that quickly converts a signal from its original time domain into a frequency domain. This allows the vocoder to analyze and manipulate the different frequency components of audio, enabling effects like filtering, modulation, and vocoding.</p>
                <p>Learn more about the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank" rel="noopener noreferrer" style="color:#4af;">Fast Fourier Transform (FFT)</a> on Wikipedia.</p>
                <p>This is why it's taking so long to process</p>
                <p>Fun fact: dividing the FFT index by 2 will multiply the pitch by 2, multiplying it will do the opposite</p>
                <p>Here are some instructions and information to get you started:</p>
                
                <h3>Basic Controls:</h3>
                <ul>
                    <li><strong>Decay Type:</strong> Choose between RMS and Peak for the decay type.</li>
                    <li><strong>Release:</strong> Adjust the release time for the vocoder (0 is no release and 1 is max release).</li>
                    <li><strong>Pitch:</strong> Adjust the pitch of the vocoded audio (input only).</li>
                    <li><strong>Shift:</strong> Shifts the FFT bands of the vocoded audio (input only)</li>
                </ul>

                <h3>FFT Vocoder Mode:</h3>
                <ul>
                    <li><strong>Band Break:</strong> This shifts the bands a couple of times</li>
                    <li><strong>Flip:</strong> Self explanatory, it flips the bands</li>
                    <li><strong>Broken Vocoder Type:</strong> Select the type of broken vocoder effect.</li>
                    <li><strong>Volume:</strong> Adjust the volume of the output audio.</li>
                    <li><strong>FFT Size:</strong> Adjust the size of the FFT used for processing.</li>
                </ul>

                <h3>Analog Vocoder Mode:</h3>
                <ul>
                    <li><strong>Total Bands:</strong> Sets the number of filter bands (more bands = more detailed vocoding).</li>
                    <li><strong>Resonance:</strong> Controls the sharpness of the bandpass filters.</li>
                    <li><strong>Volume Boost:</strong> Increases the output volume after processing.</li>
                </ul>

                <h3>4ormulator Mode:</h3>
                <ul>
                    <li><strong>Base frequency:</strong> Sets the base frequency of Offsets.</li>
                    <li><strong>Max Harmonics:</strong> Sets the maximum amount of harmonics</li>
                    <li><strong>Offsets:</strong> Sets the offset (shift) for the filter.</li>
                </ul>

                <div style="margin-top: 20px; font-size: 12px; color: #aaa;">
                    Version 1.2<br>
                    Made by D3nschot (DX3050)
                </div>
                
                <button id="closeHelpButton" style="margin-top: 20px;">Close</button>
            </div>
        </div>
    </div>
        <!--
            sample tables
            most of these tables are taken from orange vocoder
            I love working with tables :)
        -->
    <script>
        DistTable=``

        indigo = `\uDA52\uD88E\uDA86\uD9CC\uDDA0\uD826\uDC2E\uD92E\uDE0A\uDF2E\uDD86\uDA02\uD826\uD85A\uD998\uD8C4\uD85A\uD9CC\uD998\uD962\uD88E\uDA02\uD97E\uD8F8\uDA02\uDB5A\uDB5A\uD8DE\uDDBC\uDB74\uD9CC\uDFE8\uDEAA\uDF64\uDFCE\uDC98\uDBFA\uDD86\uD8C4\uDDBC\uDE40\uD840\uDF2E\uDEDE\uDE0A\uDFB2\uDDA0\uDAD6\uD9E8\uDFE8\uDE40\uDDF0\uDCE8\uDA6C\uDEDE\uDB26\uDF48\uDCCC\uDC64\uDCB2\uD826\uDA02\uDBFA\uDBDE\uD9CC\uD914\uD874\uDD52\uDBDE\uDB5A\x02\uDBFA\uDE90\uDC98\uDF64\uDF7E\uDF14\uDF98\uDFCE\uDEDE\uDDA0\uDCB2\uDAD6\uD914\uDAA0\uDF14\uDE5A\uDD52\uDB74\uD8AA\uDFCE\uDDF0\uDBAA\uDA52\uD9B2\uDA02\uDF48\uDA52\uDA52\uDB0A\uDA86\uDA6C\uD948\uDDF0\uDBDE\uD88E\uDD52\uDAA0\uD8F8\uDA86\uDABC\uDA36\uDA02\uDE74\uDFB2\uDC7E\uDA1C\uD97E\uDA1C\uDE90\uDEDE\uDB0A\uDCCC\uDA86\uDCCC\uDE40\uDAF0\uD9CC\uD914\uDDA0\uDE26\uDF2E\uDF98\uDEFA\uDEDE\uDE26\uDAA0\uDDBC\uDAD6\uDDA0\uD998\uDC98\uD9E8\uDA52\uD9E8\uDA52\uDC14\uDDD6\uDE0A\uD9CC\uD9B2\uDE74\uDEDE\uDF48\uDC7E\uD874\uD914\uD914\uDFE8\uDDF0\uDE74\uDF98\uDEC4\uDBC4\uD8DE\uDF64\uDE5A\uDC64\uD8C4\uDA1C\uDC64\uDD1C\uDB5A\uDF48\uDEDE\uDE40\uDA36\uD948\uDF48\uDEC4\uDB26\uDBC4\uDA36\uD8C4\uD8DE\uD962\uD998\uD9CC\uD962\uD874\uD8AA\uD8C4\uD85A\uD92E\uD97E\uDF14\uDCB2\uDAF0\uD85A\uD8F8\uDA02\uDEFA\uD92E\uD9E8\uDA6C\uD80A\uD80A\uD874\uD8DE`
        indigoMin =``,
        Strings = `lLR2gG'\gB2g`
        unisono = ``
        brTable = [..."0079850685948392161845741993690738738004613112014988597105295104562797936416726707708271267244569610146180066468705679378394527816778586099221871680046091761401251276118473148915368512820017681694695003335049804185950937414434026392499923365663756799911610"].map(c => parseInt(c)/4.5-1.0193333333)
        
    </script>

    <!-- GitHub Corner Link -->
    <a href="https://github.com/D3nschot/crappy-FFT-vocoder" class="github-corner">Fork me on GitHub :)</a>

    <script>
        // Quote system
        const quotes = [
            "FFT? I only know it as Functional Family Therapy",
            "I love math -D3nschot",
            "I love math -DX3050",
            "probably gonna make Crappy Analog Voc- oh wait, I already did",
            "A fast Fourier transform (FFT) is an algorithm that computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).",
            "Don't we love how long it takes to process audio files? :D",
            "new ui? because why not?",
            "I should really stop adding features",
            "synth -D3nschot",
            "synth -DX3050",
        ];

        document.getElementById('Title').addEventListener('click', function() {
            const quoteEl = document.getElementById('randomQuote');
            quoteEl.style.display = 'block';
            quoteEl.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        document.getElementById('randomQuote').addEventListener('click', function() {
            this.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        // Initialize quote
        document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];

        // Auto-value span system for sliders
        document.addEventListener('DOMContentLoaded', function() {
            const skipIds = ['FFTsize', 'DBperOct'];
            const offWhenZero = ['steps', 'SoundGoodizer'];

            document.querySelectorAll('input[type="range"]').forEach(slider => {
                let label = document.querySelector(`label[for="${slider.id}"]`);
                if (!label) return;

                let span = label.parentNode.querySelector(`.auto-value-span[data-for="${slider.id}"]`);
                if (!span) {
                    span = document.createElement('span');
                    span.className = 'auto-value-span value-label';
                    span.dataset.for = slider.id;
                    label.parentNode.appendChild(span);
                }

                // Add click-to-edit functionality
                if (!skipIds.includes(slider.id)) {
                    span.style.cursor = 'pointer';
                    span.title = 'Click to edit value';
                    span.addEventListener('click', function(e) {
                        if (span.querySelector('input')) return;
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.value = slider.value;
                        input.style.width = '60px';
                        input.style.fontSize = 'inherit';
                        input.style.background = 'rgba(68, 68, 68, 0.8)';
                        input.style.color = '#fff';
                        input.style.border = '1px solid #5ac8fa';
                        input.style.borderRadius = '4px';
                        input.style.padding = '2px 4px';
                        
                        span.textContent = '';
                        span.appendChild(input);
                        input.focus();
                        input.select();
                        
                        function finishEdit() {
                            let val = input.value;
                            if (slider.min !== '') val = Math.max(Number(slider.min), val);
                            if (slider.max !== '') val = Math.min(Number(slider.max), val);
                            slider.value = val;
                            slider.dispatchEvent(new Event('input'));
                            updateSpan();
                        }
                        
                        input.addEventListener('blur', finishEdit);
                        input.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') finishEdit();
                            else if (e.key === 'Escape') updateSpan();
                        });
                    });
                }

                function updateSpan() {
                    let val = slider.value;
                    if (offWhenZero.includes(slider.id) && (val === "0" || val === 0)) {
                        span.textContent = ' OFF';
                    } else {
                        if (skipIds.includes(slider.id)) {
                            switch (slider.id) {
                                case 'FFTsize':
                                    span.textContent = ' ' + (Math.pow(2, val)).toFixed(0);
                                    break;
                                case 'DBperOct':
                                    span.textContent = ' ' + val*6 + ' dB/oct';
                                    break;
                                default:
                                    span.textContent = '';
                            }
                        } else {
                            span.textContent = ' ' + val;
                        }
                    }
                }

                updateSpan();
                slider.addEventListener('input', updateSpan);
            });
        });

        // Mode switching system
        let Vmode = 0; // Start with 4ormulator mode

        function SetUpUI() {
            const controls = ['FFTcontrols', 'analogControls', '4ormClone'];
            const configs = [
                { title: 'Crappy FFT Vocoder', whatIs: 'a Fast Fourier Transform vocoder', button: 'Change to Analog Mode', show: 0 },
                { title: 'Crappy Analog Vocoder', whatIs: 'an Analog Vocoder', button: 'Change to 4ormulator Mode', show: 1 },
                { title: 'Crappy 4ormulator clone', whatIs: 'an 4ormulator clone', button: 'Change to FFT Mode', show: 2 }
            ];

            // Hide all controls
            controls.forEach(id => document.getElementById(id).classList.add('hidden'));
            
            // Show current mode
            const config = configs[Vmode];
            document.getElementById('Title').textContent = config.title;
            document.getElementById('what_is').textContent = config.whatIs;
            document.getElementById('changeBackButton').textContent = config.button;
            document.getElementById(controls[config.show]).classList.remove('hidden');
        }

        document.getElementById('changeBackButton').addEventListener('click', function() {
            Vmode = ((Number(Vmode) || 0) + 1) % 3;
            SetUpUI();
            
            const params = new URLSearchParams(window.location.search);
            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        });

        // Speed type visibility control
        document.getElementById('speedType').addEventListener('change', function(event) {
            const userSpeedGroup = document.querySelector('label[for="userSpeed"]').parentNode;
            if (event.target.value == '2') {
                userSpeedGroup.classList.remove('hidden');
            } else {
                userSpeedGroup.classList.add('hidden');
            }
        });

        // Auto-update filters toggle
        document.addEventListener('DOMContentLoaded', () => {
            const autoUpdateCheckbox = document.getElementById('AutoUpdateFilters');
            const manualStudyButton = document.getElementById('ManualStudyFilters');

            autoUpdateCheckbox.addEventListener('change', () => {
                if (autoUpdateCheckbox.checked) {
                    manualStudyButton.classList.add('hidden');
                } else {
                    manualStudyButton.classList.remove('hidden');
                }
            });

            manualStudyButton.addEventListener('click', () => {
                if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
            });

            ['TotalBands', 'Resonance', 'DBperOct', 'BPwidth', 'Alt_BP', 'AutoUpdateFilters'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    const handler = () => {
                        const autoUpdate = document.getElementById('AutoUpdateFilters');
                        if (!autoUpdate || autoUpdate.checked) {
                            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
                        }
                    };
                    el.addEventListener('input', handler);
                    el.addEventListener('change', handler);
                }
            });

            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
        });

        // Harmonics textarea tab support
        document.addEventListener('DOMContentLoaded', function() {
            const harmonicsTextarea = document.getElementById('Harmonics');
            if (harmonicsTextarea) {
                harmonicsTextarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = this.selectionStart;
                        const end = this.selectionEnd;
                        this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
                        this.selectionStart = this.selectionEnd = start + 1;
                    }
                });
            }
        });

        // Harmonic buttons system
        function createHarmonicButtons() {
            const harmDiv = document.getElementById('harm');
            if (!harmDiv) return;
            
            window.harmString = window.harmString || [];
            
            Array.from(harmDiv.querySelectorAll('button.harm-btn')).forEach(btn => btn.remove());
            
            for (let i = 1; i <= 12; i++) {
                const btn = document.createElement('button');
                btn.textContent = `H${i}`;
                btn.className = 'harm-btn';
                btn.dataset.harmonic = i;
                
                if (window.harmString.includes(i)) {
                    btn.style.backgroundColor = "#0055ff";
                    btn.style.color = "#fff";
                }
                
                btn.addEventListener("click", () => {
                    const idx = window.harmString.indexOf(i);
                    if (idx !== -1) {
                        window.harmString.splice(idx, 1);
                        btn.style.backgroundColor = "";
                        btn.style.color = "";
                    } else {
                        window.harmString.push(i);
                        btn.style.backgroundColor = "#0055ff";
                        btn.style.color = "#fff";
                    }
                    if (typeof updateHarmonicsText === 'function') updateHarmonicsText();
                });
                
                harmDiv.appendChild(btn);
            }
        }

        const heldNotes = new Set();
        const keyboard = document.getElementById("easyKeyboard");
        const totalKeys = 60;
        const base = -24;

        function updateHarmonicsText() {
            const harmonicsArea = document.getElementById("Harmonics");
            if (!harmonicsArea) return;

            const arr = Array.from(heldNotes).sort((a, b) => a - b);
            const harmArr = (window.harmString || []).slice().sort((a, b) => a - b);
            const arrString = `[${arr.join(",")}]`;
            const harmString = `[${harmArr.join(",")}]`;
            const mapFunctionString = `.flatMap((i)=>{\n    f=2**((i+3)/12)*Math.PI/128/HZ*2048*440;\n    return ${harmString}.map(a=>a*f);\n})`;
            harmonicsArea.value = arrString + mapFunctionString;
        }

        function renderKeyboard() {
            keyboard.innerHTML = '';
            
            let split = keyboard.offsetWidth < 600 || window.innerWidth < 700;
            let keysPerRow = split ? 12 : 24;
            
            for (let k = 0; k < totalKeys; k++) {
                if (k % keysPerRow === 0) {
                    var rowDiv = document.createElement("div");
                    rowDiv.className = "keyboard-row";
                    keyboard.appendChild(rowDiv);
                }

                const intVal = k + base;
                const name = semitoneNames[k % 12];
                const isBlack = name.black;

                const btn = document.createElement("button");
                btn.className = `key-button ${isBlack ? 'black' : 'white'}`;
                btn.dataset.note = intVal;
                if (isBlack) {
                    btn.style.marginLeft = "-21px";
                    btn.style.marginRight = "-21px";
                } else {
                    btn.style.marginLeft = "0";
                    btn.style.marginRight = "0";
                }


                if (heldNotes.has(intVal)) {
                    btn.classList.add('active');
                }

                btn.addEventListener("click", () => {
                    if (heldNotes.has(intVal)) {
                        heldNotes.delete(intVal);
                        btn.classList.remove('active');
                    } else {
                        heldNotes.add(intVal);
                        btn.classList.add('active');
                    }
                    updateHarmonicsText();
                });

                rowDiv.appendChild(btn);
            }
        }

        
        // Drag and drop system
        let draggingInputId = null;

        ['carrierInput', 'audioInput'].forEach(id => {
            const input = document.getElementById(id);
            if (!input) return;

            input.setAttribute('draggable', 'true');

            input.addEventListener('dragstart', e => {
                draggingInputId = id;
            });

            input.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                input.classList.add('drag-over');
            });

            input.addEventListener('dragleave', e => {
                input.classList.remove('drag-over');
            });

            input.addEventListener('drop', e => {
                e.preventDefault();
                input.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    input.files = files;
                    input.dispatchEvent(new Event('change'));
                }
            });
        });

        // URL parameter management
        function updateURLParams() {
            const params = new URLSearchParams();

            document.querySelectorAll('input, select, textarea').forEach(input => {
                const id = input.id;
                if (!id || input.type === 'file') return;

                if (input.type === 'checkbox') {
                    params.set(id, input.checked ? 'true' : 'false');
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    const encoded = btoa(unescape(encodeURIComponent(input.value)));
                    params.set(id, `base64~${encoded}`);
                } else {
                    params.set(id, input.value);
                }
            });

            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        }

        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);

            params.forEach((value, key) => {
                if (key === 'Vmode') {
                    window.Vmode = parseInt(value) || 0;
                    return;
                }

                const input = document.getElementById(key);
                if (!input) return;

                if (input.type === 'checkbox') {
                    input.checked = value === 'true';
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    if (value.startsWith('base64~')) {
                        try {
                            const b64 = value.slice(7);
                            input.value = decodeURIComponent(escape(atob(b64)));
                        } catch (e) {
                            input.value = '';
                        }
                    } else {
                        input.value = value;
                    }
                } else {
                    input.value = value;
                }

                input.dispatchEvent(new Event('input'));
            });
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            // Attach URL updating to all inputs
            document.querySelectorAll('input[type="range"], input[type="number"], input[type="checkbox"], select, textarea').forEach(input => {
                input.addEventListener('input', updateURLParams);
                input.addEventListener('change', updateURLParams);
            });

            loadStateFromURL();
            SetUpUI();
            createHarmonicButtons();
            renderKeyboard();
            updateHarmonicsText();

            // Handle window resize for keyboard
            window.addEventListener('resize', renderKeyboard);
        });

        // Help popup system
        document.getElementById('helpButton').addEventListener('click', function() {
            // Show the existing help popup
            document.getElementById('helpPopup').classList.remove('hidden');
        });

        // Close help popup
        document.getElementById('closeHelpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').classList.add('hidden');
        });

        // Function to clean up the URL by removing disallowed characters
            function CleanUpLink() {
                const DisAllowsCharacters = '(|^*%$#@!<>,/\\:\';\"{}[]~+")';
                const regex = new RegExp('[' + DisAllowsCharacters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']', 'g');
            
                const url = window.location.href;
                const [base, query] = url.split('?');
            
                if (query) {
                    const cleanedQuery = query.replace(regex, '');
                    const newUrl = `${base}?${cleanedQuery}`;
                    window.history.replaceState({}, '', newUrl);
                }
            }
            
            function handleDragOver(event) {
                event.preventDefault();
                event.target.classList.add('drag-over');
                event.target.classList.add('expanded');
            }

            function handleDragLeave(event) {
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
                const fileInput = event.target;
                const files = event.dataTransfer.files;
                fileInput.files = files;

                // Trigger change event manually
                const changeEvent = new Event('change');
                fileInput.dispatchEvent(changeEvent);
            }

            document.getElementById('carrierInput').addEventListener('dragover', handleDragOver);
            document.getElementById('carrierInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('carrierInput').addEventListener('drop', handleDrop);

            document.getElementById('audioInput').addEventListener('dragover', handleDragOver);
            document.getElementById('audioInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('audioInput').addEventListener('drop', handleDrop);

            document.getElementById('speedType').addEventListener('change', function(event) {
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                if (event.target.value == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            });

            const inputs='input[type="range"], input[type="number"], input[type="checkbox"], select'

            // Initialize the visibility of the speed slider based on the current selection
            document.getElementById('speedType').dispatchEvent(new Event('change'));

            // --- Cookie helpers ---
            function savePresetCookie(presetName, data, days = 30) {
                const json = JSON.stringify(data);
                const encoded = encodeURIComponent(json);
                let expires = "";
                if (days) {
                    const date = new Date();
                    date.setTime(date.getTime() + (days*24*60*60*1000));
                    expires = "; expires=" + date.toUTCString();
                }
                document.cookie = presetName + "=" + encoded + expires + "; path=/";
            }

            function loadPresetCookie(presetName) {
                const nameEQ = presetName + "=";
                const ca = document.cookie.split(';');
                for(let i=0; i < ca.length; i++) {
                    let c = ca[i].trim();
                    if (c.indexOf(nameEQ) === 0) {
                        try {
                            return JSON.parse(decodeURIComponent(c.substring(nameEQ.length)));
                        } catch (e) {
                            console.error("Invalid preset cookie", e);
                        }
                    }
                }
                return null;
            }

            function listPresets() {
                return document.cookie.split(";").map(c => c.trim().split("=")[0]);
            }

            // Collect current settings from inputs

            // Collect current settings from inputs
            function exportCurrentSettings() {
                const inputs = document.querySelectorAll('input, select'); // query inside function
                const settings = {};
                inputs.forEach(input => {
                    if (input.type === 'checkbox') {
                        settings[input.id] = input.checked;
                    } else {
                        settings[input.id] = input.value;
                    }
                });
                settings.Mode = Vmode; // keep as number: 0, 1, 2
                return settings;
            }

            // Apply settings back to inputs
            function importSettings(obj) {
                Object.keys(obj).forEach(key => {
                    if (key === "Mode" || key === "Vmode") {
                        Vmode = obj[key];
                        return;
                    }
                    const el = document.getElementById(key);
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = obj[key] === true || obj[key] === "true";
                        } else {
                            el.value = obj[key];
                        }
                        el.dispatchEvent(new Event('input'));
                        el.dispatchEvent(new Event('change'));
                    }
                });
            }


            // --- Your existing code with preset integration ---
            document.getElementById('ViewProperties').addEventListener('click', function() {
                const inputs = document.querySelectorAll('input, select');
                const fileInputs = document.querySelectorAll('input[type="file"]');
                const properties = [];
                const fileInfo = [];



                // Collect input values
                inputs.forEach(input => {
                    if (input.type === 'range' || input.type === 'number' || input.type === 'checkbox' || input.tagName === 'SELECT') {
                        properties.push(`${input.id}: ${input.value}`);
                    }
                });
                properties.push(`Mode: ${['FFT Mode','Analog Mode','4orm Mode'][Vmode]}`); // Add Vmode as a property
                // Collect file input details
                fileInputs.forEach(fileInput => {
                    const file = fileInput.files[0];
                    if (file) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            audioContext.decodeAudioData(e.target.result, function(buffer) {
                                const duration = buffer.duration.toFixed(2);
                                fileInfo.push(`
                                    <h2>${file.name}</h2>
                                    <li>Size: ${(file.size / 1024).toFixed(2)} KB</li>
                                    <li>Duration: ${Math.floor(duration / 60)}:${Math.floor(duration % 60).toString().padStart(2, '0')}:${Math.floor((duration % 1) * 1000).toString().padStart(3, '0')} (${duration} seconds)</li>
                                    <li>Sample Rate: ${buffer.sampleRate} Hz</li>
                                    <li>Channels: ${buffer.numberOfChannels}</li>
                                    <li>Codec: ${(co=file.type.split('/')[1]|| 'failed to get Codec') , file.type === 'audio/wav' || file.type.includes('pcm') ? co + ` (PCM ${buffer.getChannelData(0).BYTES_PER_ELEMENT * 8})`: co}</li>
                                `);

                                // Update the popup content dynamically
                                const popup = document.querySelector('div[style*="z-index: 1000"]');
                                if (popup) {
                                    popup.innerHTML = `
                                        <h1>Properties</h1>
                                        ${fileInfo.join('')}
                                        <br>
                                        <h1>Input Values</h1>
                                        <ul>${properties.map(prop => `<li>${prop}</li>`).join('')}</ul>
                                        <br>
                                        <div>
                                            <button id="ExportJSON">Export JSON</button> |
                                            <button id="ImportJSON">Import JSON</button> 
                                            <br>
                                            note that this uses Cookies/localStorage
                                            <br>
                                            <button id="SavePreset">Save Preset</button> |
                                            <button id="LoadPreset">Load Preset</button> 
                                            <br>
                                            <button id="closePropertiesButton">Close</button>
                                        </div>
                                    `;

                                    // Reattach the close button event listener
                                    document.getElementById('closePropertiesButton').addEventListener('click', function() {
                                        document.body.removeChild(popup);
                                    });

                                    // Add ExportJSON functionality
                                    document.getElementById('ExportJSON').addEventListener('click', function() {
                                        const inputs = document.querySelectorAll('input, select'); // query inside the function
                                        const jsonObject = {};

                                        inputs.forEach(input => {
                                            if (input.type === 'checkbox') {
                                                jsonObject[input.id] = input.checked; // boolean
                                            } else {
                                                jsonObject[input.id] = input.value;   // string
                                            }
                                        });

                                        // Numeric Mode
                                        jsonObject.Mode = Vmode; // 0, 1, 2

                                        const jsonBlob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                                        const jsonUrl = URL.createObjectURL(jsonBlob);
                                        const downloadLink = document.createElement('a');
                                        downloadLink.href = jsonUrl;
                                        downloadLink.download = 'properties.json';
                                        downloadLink.click();
                                        URL.revokeObjectURL(jsonUrl);
                                    });

                                    // Import JSON
                                    document.getElementById('ImportJSON').addEventListener('click', function() {
                                        const input = document.createElement('input');
                                        input.type = 'file';
                                        input.accept = 'application/json';
                                        input.addEventListener('change', function(event) {
                                            const file = event.target.files[0];
                                            if (!file) return;

                                            const reader = new FileReader();
                                            reader.onload = function(e) {
                                                try {
                                                    const jsonObject = JSON.parse(e.target.result);
                                                    Object.keys(jsonObject).forEach(key => {
                                                        if (key === 'Mode' || key === 'Vmode') {
                                                            window.Vmode = jsonObject[key]; // numeric mode
                                                            return;
                                                        }
                                                        const inputElement = document.getElementById(key);
                                                        if (inputElement) {
                                                            if (inputElement.type === 'checkbox') {
                                                                inputElement.checked = jsonObject[key] === true;
                                                            } else {
                                                                inputElement.value = jsonObject[key];
                                                            }
                                                            inputElement.dispatchEvent(new Event('input'));
                                                            inputElement.dispatchEvent(new Event('change'));
                                                        }
                                                    });
                                                    alert('Properties imported successfully!');
                                                } catch (error) {
                                                    alert('Invalid JSON file. Please select a valid properties file.');
                                                }
                                            };
                                            reader.readAsText(file);
                                        });
                                        input.click();
                                    });

                                }
                            });
                        };
                        reader.readAsArrayBuffer(file);
                    } else {
                        fileInfo.push(`
                            <h2>${fileInput.id}</h2>
                            <li>No file selected</li>
                        `);
                    }
                });

                const popup = document.createElement('div');
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = '#333';
                popup.style.color = '#fff';
                popup.style.padding = '20px';
                popup.style.borderRadius = '10px';
                popup.style.width = '90vw';
                popup.style.maxWidth = '600px';
                popup.style.minWidth = '220px';
                popup.style.maxHeight = '80vh';
                popup.style.overflowY = 'auto';
                popup.style.zIndex = '1000';

                // Build popup content
                popup.innerHTML = `
                    <h2>Properties</h2>
                    ${fileInfo.join('')}
                    <h2>Input Values</h2>
                    <ul>${properties.map(p => `<li>${p}</li>`).join('')}</ul>
                    <br>
                    <div>
                        <button id="ExportJSON">Export JSON</button> |
                        <button id="ImportJSON">Import JSON</button> 
                        <br>
                        note that this uses Cookies/localStorage
                        <br>
                        <button id="SavePreset">Save Preset</button> |
                        <button id="LoadPreset">Load Preset</button> 
                        <br>
                        <button id="closePropertiesButton">Close</button>
                    </div>
                `;

                document.body.appendChild(popup);

                // Close button
                document.getElementById('closePropertiesButton').addEventListener('click', () => {
                    document.body.removeChild(popup);
                });

                // Export JSON
                document.getElementById('ExportJSON').addEventListener('click', () => {
                    const jsonObject = {};
                    inputs.forEach(input => {
                        if (input.type === 'range' || input.type === 'number' || input.tagName === 'SELECT') {
                            jsonObject[input.id] = input.value;
                        } else if (input.type === 'checkbox') {
                            jsonObject[input.id] = input.checked;
                        }
                    });
                    jsonObject.Mode = Vmode;
                    const blob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = "properties.json";
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // Import JSON
                document.getElementById('ImportJSON').addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    input.onchange = e => {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = e => {
                            try {
                                const obj = JSON.parse(e.target.result);
                                applyPreset(obj);
                                alert("Imported successfully");
                            } catch {
                                alert("Invalid JSON");
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                });

                // Load presets from cookie/localStorage
                function getPresets() {
                    const data = localStorage.getItem("presets");
                    return data ? JSON.parse(data) : {};
                }

                    console.log("Loaded presets:", localStorage.getItem("presets"));

                // Save presets to storage
                function savePresets(presets) {
                    localStorage.setItem("presets", JSON.stringify(presets));
                    updatePresetList();
                }

                function updatePresetList() {
                    const presets = getPresets();
                    const presetList = document.getElementById("presetList");
                    if (!presetList) return; // <-- prevents null errors

                    presetList.innerHTML = `<option value="">-- Select a preset --</option>`;
                    for (const key in presets) {
                        const opt = document.createElement("option");
                        opt.value = key;
                        opt.textContent = key;
                        presetList.appendChild(opt);
                    }
                }


                // Save preset
                document.getElementById("SavePreset").addEventListener("click", () => {
                    const name = prompt("Enter a preset name:");
                    if (!name) return;
                    const presets = getPresets();
                    presets[name] = exportCurrentSettings(); // <-- replace with your export function
                    savePresets(presets);
                });

                // Load preset
                document.getElementById("LoadPreset").addEventListener("click", () => {
                    // Check if the dropdown already exists
                    if (!document.getElementById("presetList")) {
                        const container = document.createElement("div");
                        container.style.marginTop = "10px";
                        container.innerHTML = `
                            <label for="presetList">Presets: </label>
                            <select id="presetList">
                                <option value="">-- Select a preset --</option>
                            </select>
                            <button id="ConfirmLoadPreset">Load</button>
                        `;
                        popup.appendChild(container);

                        updatePresetList(); //  safe now, dropdown exists

                        // Confirm load action
                        document.getElementById("ConfirmLoadPreset").addEventListener("click", () => {
                            const presetList = document.getElementById("presetList");
                            const name = presetList.value;
                            if (!name) {
                                alert("Please select a preset from the list.");
                                return;
                            }
                            const presets = getPresets();
                            if (presets[name]) {
                                importSettings(presets[name]);
                                alert(`Preset "${name}" loaded successfully.`);
                            }
                        });
                    }
                });



                // Initialize dropdown on page load
                updatePresetList();


                // Apply preset to inputs
                function applyPreset(obj) {
                    Object.keys(obj).forEach(key => {
                        if (key === "Mode" || key === "Vmode") {
                            Vmode = obj[key];
                            return;
                        }
                        const el = document.getElementById(key);
                        if (el) {
                            if (el.type === 'checkbox') {
                                el.checked = obj[key] === true || obj[key] === "true";
                            } else {
                                el.value = obj[key];
                            }
                            el.dispatchEvent(new Event('input'));
                            el.dispatchEvent(new Event('change'));
                        }
                    });
                }
            });

        </script>
    <script>
        let audioContext, analyser, source, processedBuffer, audioData, carrierBuffer;
        let loadedAudioBuffer = null;
        let loadedCarrierBuffer = null;
        let playbackSource = null;

        function extractAudioFromVideo(file, callback) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.play();

            video.addEventListener('canplaythrough', function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                const recorder = new MediaRecorder(destination.stream);
                const chunks = [];

                recorder.ondataavailable = function(event) {
                    chunks.push(event.data);
                };

                recorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(blob);
                };

                recorder.start();
                video.play();
                setTimeout(() => {
                    recorder.stop();
                    video.pause();
                    URL.revokeObjectURL(video.src);
                }, video.duration * 1000);
            });
        }

        function handleFileInput(event, callback) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    extractAudioFromVideo(file, callback);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        document.getElementById('audioInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioData = e.target.result;
                    audioContext.decodeAudioData(audioData, function(buffer) {
                        loadedAudioBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding carrier audio data:', error);
                        alert('Error decoding carrier audio data. Please select a valid audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        let EnSynth=document.getElementById('enableSynth').checked;
        // this fixed the issue of requireing the carrier file to be loaded first
        function tryProcessAudio(B) {
            if ((loadedCarrierBuffer && loadedAudioBuffer) || (loadedCarrierBuffer && EnSynth)) {
                processAudio(B);
            }
        }

        document.getElementById('carrierInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const carrierData = e.target.result;
                    audioContext.decodeAudioData(carrierData, function(buffer) {
                        loadedCarrierBuffer = buffer;
                        carrierBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding modular audio data:', error);
                        alert('Error decoding modular audio data. Please select a valid input audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('reprocessButton').addEventListener('click', function() {
            if (loadedAudioBuffer && loadedCarrierBuffer) {
                processAudio(loadedAudioBuffer);
            } else {
                alert('Please load both audio and input files first.');
            }
        });

        document.getElementById('Harmonics').addEventListener('input', (e) => {
            /*const text = e.target.value;
            let parsed = [];

            try {
                const result = eval(text);
                if (Array.isArray(result)) {
                    parsed = result;
                    console.log("Harmonics array:", parsed);
                } else {
                    console.warn("Harmonics input did not return an array.");
                }
            } catch (err) {
                console.error("Failed to evaluate harmonics:", err);
            }*/

            updateURLParams()
        })

        function createLoopedBuffer(buffer, targetLength) {
            const sampleRate = buffer.sampleRate;
            const numberOfChannels = buffer.numberOfChannels;
            const newBuffer = audioContext.createBuffer(numberOfChannels, targetLength, sampleRate);
            
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const nowBuffering = newBuffer.getChannelData(channel);
                const originalData = buffer.getChannelData(channel);
                
                for (let i = 0; i < targetLength; i++) {
                    nowBuffering[i] = originalData[i % originalData.length];
                }
            }
            
            return newBuffer;
        }

        function showProcessPOP_UP(text, block = true, bar = false, per) {
            let popup = document.getElementById('processPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'processPopup';
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = '#222';
                popup.style.color = '#fff';
                popup.style.padding = '30px 40px';
                popup.style.borderRadius = '12px';
                popup.style.boxShadow = '0 4px 24px #000a';
                popup.style.zIndex = '2000';
                popup.style.fontSize = '1.2em';
                popup.style.textAlign = 'center';
                popup.style.display = 'flex';
                popup.style.flexDirection = 'column';
                popup.style.alignItems = 'center';
                popup.style.justifyContent = 'center';
                popup.style.width = '90vw';        // Responsive width
                popup.style.maxWidth = '600px';    // Maximum width
                popup.style.minWidth = '220px';    // Minimum width for usability
                popup.style.maxHeight = '90vh';    // Responsive height
                //popup.style.overflowY = 'auto';    // Enable vertical scroll if needed
                document.body.appendChild(popup);
            }

            // Clear popup content
            popup.innerHTML = '';

            // Add text
            const textDiv = document.createElement('div');
            textDiv.innerHTML = text.replace(/\n/g, '<br>');
            popup.appendChild(textDiv);

            // Add or update progress bar
            if (bar) {
                let progressBar = document.getElementById('progressBar');
                let progressFill = document.getElementById('progressFill');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.id = 'progressBar';
                    progressBar.style.width = '100%';
                    progressBar.style.height = '20px';
                    progressBar.style.backgroundColor = '#444';
                    progressBar.style.borderRadius = '10px';
                    progressBar.style.marginTop = '10px';

                    progressFill = document.createElement('div');
                    progressFill.id = 'progressFill';
                    progressFill.style.height = '100%';

                    const B255 = (Math.min(per/100*255, 255) / 255) ** 1.5 * 255;
                    progressFill.style.backgroundColor = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    progressFill.style.borderRadius = '10px';

                    progressBar.appendChild(progressFill);
                    popup.appendChild(progressBar);
                }
                // Always update width
                progressFill.style.width = `${per || 0}%`;
            }

            // Remove any fixed height so it grows/shrinks automatically
            popup.style.height = '';

            popup.style.display = block && text ? 'block' : 'none';
        }

        function showProcessPOP_UP_WL(message, visible = true, showProgress = false, progress = 0) {
            let popup = document.getElementById("processPopup");

            // Flex layout: gif on the left, text on the right
            popup.innerHTML = `
                <div style="display:flex;align-items:center;gap:15px;">
                    <img src="Load.gif" alt="Loading..." style="width:75px;height:75px;flex-shrink:0;">
                    <div style="flex:1;">
                        <p style="margin:0;white-space:pre-line;">${message || "Processing..."}</p>
                        ${showProgress ? `
                            <div id="progressWrapper" style="margin-top:10px;width:100%;background:#222;border-radius:5px;overflow:hidden;height:12px;">
                                <div id="progressBar" style="height:100%;width:${progress || 0}%;background:#5ac8fa;"></div>
                            </div>` : ""}
                    </div>
                </div>
            `;
            popup.style.display = "block";

            if (showProgress) {
                let per = Math.max(0, Math.min(progress, 100)); // clamp 0-100
                const progressBar = popup.querySelector("#progressBar");
                if (progressBar) {
                    progressBar.style.width = per + "%";

                    //  Color formula
                    const B255 = (Math.min(per / 100 * 255, 255) / 255) ** 1.5 * 255;
                    progressBar.style.backgroundColor =
                        `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                }
            }

            if (!popup) {
                popup = document.createElement("div");
                popup.id = "processPopup";
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.background = "rgba(34, 34, 34, 0.95)";
                popup.style.color = "#fff";
                popup.style.padding = "20px 30px";
                popup.style.borderRadius = "15px";
                popup.style.zIndex = "6000";
                popup.style.textAlign = "left";
                popup.style.boxShadow = "0 10px 40px rgba(0,0,0,0.6)";
                popup.style.minWidth = "320px";
                popup.style.maxWidth = "500px";
                document.body.appendChild(popup);
            }

            if (!visible) {
                popup.style.display = "none";
                return;
            }
        }

        function SoundGoodizer(input, amt, channel) {
            // initialize persistent states once per channel
            if (!SoundGoodizer._state) SoundGoodizer._state = {};
            if (!SoundGoodizer._state[channel]) {
                SoundGoodizer._state[channel] = {
                    z2MBC: [], // lowpass stages
                    z3MBC: [], // highpass stages
                    RMS:  []  // rms detectors
                };
            }
            const state = SoundGoodizer._state[channel];
            const { z2MBC, z3MBC, RMS } = state;

            // RMS / envelope follower
            function MBCrms(x, attack, release, call) {
                if (!RMS[call]) RMS[call] = 0;
                let e = RMS[call];
                let target = Math.abs(x);
                let coeff = target > e ? attack : release;
                e += coeff * (target - e);
                RMS[call] = e;
                return e;
            }


            function MBClp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2MBC[callCount]) {
                    z2MBC[callCount] = { lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0 };
                }
                const cc = Math.min(Math.max(c,0),0.9999);
                const fbv = r + r/(1-cc);
                const f = d;
                let s = z2MBC[callCount];
                s.lp6  += cc*(f - s.lp6 + fbv*(s.lp6 - s.lp12));
                s.lp12 += cc*(s.lp6 - s.lp12);
                s.lp18 += cc*(s.lp12 - s.lp18);
                s.lp24 += cc*(s.lp18 - s.lp24);
                s.lp30 += cc*(s.lp24 - s.lp30);
                s.lp36 += cc*(s.lp30 - s.lp36);
                s.lp42 += cc*(s.lp36 - s.lp42);
                s.lp48 += cc*(s.lp42 - s.lp48);
                switch(dbv){
                    case 1:return s.lp6;
                    case 2:return s.lp12;
                    case 3:return s.lp18;
                    case 4:return s.lp24;
                    case 5:return s.lp30;
                    case 6:return s.lp36;
                    case 7:return s.lp42;
                    case 8:return s.lp48;
                    default:return s.lp12;
                }
            }

            function MBChp(d, c, r = 0, dbv = 2, callCount) {
                if (!z3MBC[callCount]) {
                    z3MBC[callCount] = { hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0 };
                }
                const cc = Math.min(Math.max(c,0),0.9999);
                const fbv = r + r/(1-cc);
                let s = z3MBC[callCount];
                s.hp6  += cc*(d - s.hp6 + fbv*(s.hp6 - s.hp12));
                s.hp12 += cc*(s.hp6 - s.hp12);
                let x = d - (dbv>=2 ? s.hp12 : s.hp6);
                if (dbv===1||dbv===2) return x;
                x -= (s.hp18+= cc*(x-s.hp18)); if (dbv===3) return x;
                x -= (s.hp24+= cc*(x-s.hp24)); if (dbv===4) return x;
                x -= (s.hp30+= cc*(x-s.hp30)); if (dbv===5) return x;
                x -= (s.hp36+= cc*(x-s.hp36)); if (dbv===6) return x;
                x -= (s.hp42+= cc*(x-s.hp42)); if (dbv===7) return x;
                x -= (s.hp48+= cc*(x-s.hp48)); if (dbv===8) return x;
                return x;
            }

            compressor = (input, threshold, ratio, attack, decay,call) => {
                let level = MBCrms(input, attack, decay, call);
                threshold/=3
                //ratio/=1.2
                let gain = Math.min(1, (threshold / level) ** (ratio - 1));
                return input * gain;
            }

            function mbc(d, settings) {
                const {
                    lowFreq=.05, midLow=.1, midHigh=.2, HighFreq=0,
                    lowThreshold=20, midThreshold=20, highThreshold=20,
                    ratio=4, decay=.01, attack=0,db=2
                }=settings;

                d = MBChp(d,.01,0,3,channel*5);

                //natural sound ratios 1, 2 and 1.5
                let low=MBClp(d,lowFreq,0,db,0+channel*5);
                low=compressor(low,lowThreshold,ratio,attack,decay,0+channel*5);

                let mid=MBChp(MBClp(d/2,midHigh,0,db,1+channel*5),midLow,0,db,1+channel*5);
                mid=compressor(mid,midThreshold,ratio,attack,decay,1+channel*5);

                let high=MBChp(d/1.5,HighFreq,0,db,2+channel*5);
                high=compressor(high,highThreshold,ratio,attack,decay,2+channel*5);

                return low+mid+high;
            }

            const thres=1;
            const set={
                lowFreq:.05, midLow:.015, midHigh:.4, HighFreq:.1,
                lowThreshold:thres, midThreshold:thres, highThreshold:thres,
                ratio:2.0, decay:0.0005, attack:0.01, db:8
            };

            // rms(input,.01,.01,0) fine
            // to prevent cliping
            return compressor(mbc(input*(1+amt*100),set),thres,set.ratio,set.attack,set.decay,channel*5+3);
        }

// Wave shaper function
const OVDistort = document.getElementById("OVDistort");
const waveShaper = (t) => {
    t = t/2 + 10.5;
    return ((DistTable.charCodeAt(Math.floor(t * DistTable.length) % DistTable.length) / 2**14 - 1) * 2.47 - t%1 + 0.5) * 2;
}

// Main synthesis function
function polyFsawFromKeyboard(m, heldNotesSet, octaveShift, detuneAmount, waveformType, t) {
    if (heldNotesSet.size === 0) return [0, 0];

    const notesArray = Array.from(heldNotesSet).map(n => n - 69);
    const len = notesArray.length;
    const totalVoices = len * m;
    const sqrtM = Math.sqrt(m) * 2;
    const sqrtM2 = Math.sqrt(m-1)
    let sumL = 0, sumR = 0;
    const ratio = 1;
    const OVDistortVal = parseFloat(OVDistort.value) || 0;

    const waveformFn = (pitch, j,k) => {
        const detuneL = Math.sin(+j*2)/8;
        const detuneR = Math.sin(-j*2)/8;

        const phaseL = t * pitch * (1 + detuneL * detuneAmount / 100) + Math.abs(detuneL) * 1e10;
        const phaseR = t * pitch * (1 + detuneR * detuneAmount / 100) + Math.abs(detuneR) * 1e10;

        switch (waveformType) {
            case 0: return [Math.sin(phaseL / 128 * Math.PI), Math.sin(phaseR / 128 * Math.PI)];
            case 1: return [Math.asin(-Math.sin(phaseL / 128 * Math.PI)) / Math.PI * 2,
                            Math.asin(-Math.sin(phaseR / 128 * Math.PI)) / Math.PI * 2];
            case 2: return [phaseL / 128 % 2 - 1, phaseR / 128 % 2 - 1];
            case 3: return [((phaseL | phaseL) & 128)/128 - 0.5,
                            ((phaseR | phaseR) & 128)/128 - 0.5];
            case 4: {
                const phh = Math.acos(-Math.cos(t / 32768 * Math.PI)) / Math.PI * 128;
                return [((phaseL | (phaseL + phh)) & 128)/128 - phh/256 - 0.5,
                        ((phaseR | (phaseR + phh)) & 128)/128 - phh/256 - 0.5];
            }
            case 5: return [brTable[Math.floor(phaseL) & 255], brTable[Math.floor(phaseR) & 255]];
            case 6: return [customWaveform(pitch * (1 + detuneL * detuneAmount / 100), detuneL * 181.019335984, t),
                            customWaveform(pitch * (1 + detuneR * detuneAmount / 100), detuneR * 181.019335984, t)];
            case 7: return [indigo.charCodeAt(Math.floor(phaseL*indigo.length*2**(-2.6667/12-15)) % indigo.length)/(2**14)-2,
                            indigo.charCodeAt(Math.floor(phaseR*indigo.length*2**(-2.6667/12-15)) % indigo.length)/(2**14)-2];
            case 8: return [(((phaseL & 128) ? phaseL - 128 : ~phaseL*2) & 255)/170 - 0.56,
                            (((phaseR & 128) ? phaseR - 128 : ~phaseR*2) & 255)/170 - 0.56];
            case 9: return [Math.random()*2-1, Math.random()*2-1];
            case 10: return [
                (indigoMin.charCodeAt(Math.floor(phaseL*indigoMin.length/256) % indigoMin.length)/(2**15)
                - indigoMin.charCodeAt(Math.floor((phaseL*indigoMin.length/255 + indigoMin.length/2)) % indigoMin.length)/(2**15.5)+1)**2/2 - 1,
                (indigoMin.charCodeAt(Math.floor(phaseR*indigoMin.length/256) % indigoMin.length)/(2**15)
                - indigoMin.charCodeAt(Math.floor((phaseR*indigoMin.length/255 + indigoMin.length/2)) % indigoMin.length)/(2**15.5)+1)**2/2 - 1
            ];
            case 11: return [Strings.charCodeAt(Math.floor(phaseL*1.5/2.286) % Strings.length)/(2**14)-1,
                            Strings.charCodeAt(Math.floor(phaseR*1.5/2.286) % Strings.length)/(2**14)-1];
            case 12: return [unisono.charCodeAt(Math.floor(phaseL*1.5/2.286) % unisono.length)/(2**14)-1,
                            unisono.charCodeAt(Math.floor(phaseR*1.5/2.286) % unisono.length)/(2**14)-1];
            case 13: return [(unisono.charCodeAt(Math.floor(phaseL*1.5/2.286) % unisono.length) + Strings.charCodeAt(Math.floor(phaseL*1.5/2.286) % Strings.length))/2**15 - 1,
                            (unisono.charCodeAt(Math.floor(phaseR*1.5/2.286) % unisono.length) + Strings.charCodeAt(Math.floor(phaseR*1.5/2.286) % Strings.length))/2**15 - 1];
            case 14: return Power(phaseL, totalVoices, t);
            case 15: return [(Math.sin(-phaseL * Math.PI / 128 + Math.asin(Math.sin(-phaseL * Math.PI / 128 )) / 3))
                            ,(Math.sin(-phaseR * Math.PI / 128 + Math.asin(Math.sin(-phaseR * Math.PI / 128 )) / 3))];
            case 16: {
                const i = k % len;  // note index
                const j = Math.floor(k / len);  // voice index  
                const state = getPhasedState(j, i);
                return Phased(phaseL, t, len, state);
            }

            case 17: return Chip(notesArray,detuneL,detuneR,detuneAmount/100,m,t,octaveShift).map((x)=>x/len);
            default: return [Math.sin(phaseL / 128 * Math.PI), Math.sin(phaseR / 128 * Math.PI)];
        }
    };

    for (let k = 0; k < totalVoices; k++) {
        const i = k % len;
        const j = Math.floor(k / len);
        const pitch = 2 ** ((notesArray[i] - 9.23) / 12 + octaveShift) * ratio;
        const [vl, vr] = waveformFn(pitch, j, k);
        
        sumL += vl + waveShaper(vl) * OVDistortVal * 4;
        sumR += vr + waveShaper(vr) * OVDistortVal * 4;
    }

    return [sumL / m / 3, sumR / m / 3];
}

function customWaveform(y, ph, t) {
    const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
    const invHz = Math.PI / sampleRate;
    const mod = y;
    const x = t * y + ph;

    const rate1 = 1.60;
    const rate2 = 2.21;

    const s1 = Math.sin(t * rate1 * invHz);
    const s2 = -Math.sin(t * rate2 * invHz);

    const o1 = x + s1 * 1.4e4 * mod * 0.003 / rate1;
    const o2 = x * 2 ** (0.1/12) + s2 * 1.4e4 * mod * 0.003 / rate2;

    const tri1 = Math.tan(Math.sin(o1/128 * Math.PI)) * 82.125 + 128;
    const tri2 = Math.tan(Math.sin(o2/128 * Math.PI) * 1.3) * (64/1.81) + 128;

    const v = ((tri1 & 255) + (tri2 & 255)) * 0.5 - 128;

    return v / 128;
}

function Power(y, tt, t) {
    const PI = Math.PI;
    const itt = 8;
    const dtA = 1 / 64;
    const deClickAttack = Math.min(t/10000,1);

    const w = t => Math.max(Math.min(Math.acos(Math.sin(-t * PI * 2 + Math.asin(Math.sin(-t * PI * 2)) / 3)) / PI * 4 - 2, 1), -1);
    const v = t => Math.sin((t % 1) * 5 - 2.5) + Math.max(Math.min(Math.tan(t * PI + PI / 2) / 100, 2), -2);

    let sumL = 0, sumR = 0;
    const m = 8;

    for (let i = 0; i < m; i++) {
        const sqrtM = Math.sqrt(m);
        const detuneL = Math.sqrt(i*2) / (sqrtM*2);
        const detuneR = Math.sqrt(i*2 + 1) / (sqrtM*2);

        const baseL1 = y / 128 * (1 + detuneL * dtA) + detuneL * 1e10;
        const baseL2 = y / 256 * (1 + detuneL * dtA) + detuneL * 1e10;
        const baseL3 = y / 512 * (1 + detuneL * dtA) + detuneL * 1e10;

        const baseR1 = y / 128 * (1 + detuneR * dtA) + detuneR * 1e10;
        const baseR2 = y / 256 * (1 + detuneR * dtA) + detuneR * 1e10;
        const baseR3 = y / 512 * (1 + detuneR * dtA) + detuneR * 1e10;

        sumL += v(baseL1) + v(baseL2) + w(baseL2) * 3 + w(baseL3) * 4;
        sumR += v(baseR1) + v(baseR2) + w(baseR2) * 3 + w(baseR3) * 4;
    }

    sumL /= m * 2;
    sumR /= m * 2;

    if (Power._lpState1L === undefined) Power._lpState1L = 0;
    if (Power._lpState2L === undefined) Power._lpState2L = 0;
    if (Power._lpState1R === undefined) Power._lpState1R = 0;
    if (Power._lpState2R === undefined) Power._lpState2R = 0;

    const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
    const absT = Math.abs(t / sampleRate * PI / 6 % 2 - 1);
    const cutoff = Math.min((absT + 0.4) ** 2, 1 - 1e-5) / tt;
    let r = 0.5; r += r / (1 - cutoff);

    const lp1L = Power._lpState1L + cutoff * (sumL - Power._lpState1L + (Power._lpState1L - Power._lpState2L) * r);
    const lp2L = Power._lpState2L + cutoff * (lp1L - Power._lpState2L);
    Power._lpState1L = lp1L; Power._lpState2L = lp2L;

    const lp1R = Power._lpState1R + cutoff * (sumR - Power._lpState1R + (Power._lpState1R - Power._lpState2R) * r);
    const lp2R = Power._lpState2R + cutoff * (lp1R - Power._lpState2R);
    Power._lpState1R = lp1R; Power._lpState2R = lp2R;

    return [lp2L*deClickAttack, lp2R*deClickAttack];
}

// global cache
const phasedStates = {};
function getPhasedState(voiceIndex, noteIndex) {
    const key = `${voiceIndex}_${noteIndex}`;
    if (!phasedStates[key]) {
        phasedStates[key] = { L: {}, R: {} };
    }
    return phasedStates[key];
}


function createPhaserState(stages = 4) {
  return Array.from({ length: stages }, () => ({ p1: 0, p2: 0, p3: 0, p4: 0 }));
}



function Phaser(input, ag = 0, res = 0, stages = 4, state) {
  // Initialize per channel states properly
  if (!state.ap) {
    state.ap = [];
    state.fb = 0; // Feedback state for prob fb
    for (let i = 0; i < stages; i++) {
      state.ap.push({ p1: 0, p2: 0, p3: 0, p4: 0 });
    }
  }

  let x = input + state.fb * res; // Add feedback from previous output
  const a = Math.max(Math.min(1-ag, 1), 0);

  for (let i = 0; i < stages; i++) {
    const s = state.ap[i];

    // Standard all-pass chain
    const y1 = -a * x + s.p1 + a * s.p2;
    s.p1 = x;
    s.p2 = y1;

    const y2 = -a * y1 + s.p3 + a * s.p4;
    s.p3 = y1;
    s.p4 = y2;

    x = y2;
  }

  // Store output for feedback
  state.fb = x;

  return (input+x)/2; // isolated phaser output
}

function Phased(y, t, itt, state) {
    // LFO controlling the phaser depth
    let LFO = Math.acos(-Math.sin(t/44100*2*Math.PI/8)) / Math.PI *.7+.25

    // Spread for multiple voices
    let fL = 0, fR = 0;
    const m = 4;
    const sqrtM = Math.sqrt(m)*2;

    for (let k=0; k<m; k++) {
        const detuneL = Math.sqrt(k*2) / (sqrtM*2);
        const detuneR = Math.sqrt(k*2 + 1) / (sqrtM*2);
        fL += (y/128*(1+detuneL/64)+detuneL*1e10)%2-1;
        fR += (y/128*(1+detuneR/64)+detuneR*1e10)%2-1;
    }
    // fL /= m;
    // fR /= m;

    fL+=y/128%2-1
    fR+=y/128%2-1

    // Now apply phaser to the actual waveform
    const phasedL = Phaser(fL, LFO**2, 0.23, 6, state.L);
    const phasedR = Phaser(fR, LFO**2, 0.23, 6, state.R);

    return [phasedL, phasedR];
}

        // Modified processAudio function to use the synth
        function processAudio(buffer) {
            if (!loadedAudioBuffer) {
                alert('Please select a Modular audio file.');
                return;
            }

            // Check if Synth is enabled
            const synthEnabled = document.getElementById('enableSynth')?.checked || false;
            
            if (!synthEnabled && !loadedCarrierBuffer) {
                alert('Please select a carrier audio file or enable Synth.');
                return;
            }

            const iterations = parseInt(document.getElementById('iterations').value);
            if (iterations < 1) {
                alert('Please enter a valid number of iterations.');
                return;
            }

            // Carrier determines total length
            const carrierDuration = loadedCarrierBuffer.length / loadedCarrierBuffer.sampleRate;
            const targetLength = Math.ceil(carrierDuration * buffer.sampleRate);

            // Resize input to carrier duration
            if (!synthEnabled) {
                buffer = createLoopedBuffer(buffer, targetLength);
            }

            // Set up analyser (for live vis)
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Float32Array(bufferLength);

            source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Offline render context length = carrier length
            const offlineContext = new OfflineAudioContext(
                2,
                loadedCarrierBuffer.length,
                loadedCarrierBuffer.sampleRate
            );

            let offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = buffer;

            const offlineAnalyser = offlineContext.createAnalyser();
            offlineAnalyser.fftSize = 2048;
            const offlineFrequencyData = new Uint8Array(offlineAnalyser.frequencyBinCount);

            offlineSource.connect(offlineAnalyser);
            offlineAnalyser.connect(offlineContext.destination);

            offlineSource.start();
            offlineContext.startRendering().then(function(renderedBuffer) {

                let carrierLeft  = loadedCarrierBuffer.getChannelData(0);
                let carrierRight = loadedCarrierBuffer.numberOfChannels > 1
                    ? loadedCarrierBuffer.getChannelData(1)
                    : loadedCarrierBuffer.getChannelData(0);

                let inputLeft, inputRight;
                if (synthEnabled) {
                    showProcessPOP_UP('Rendering synth... this will take a second', true);

                    // synth must fill to carrier length
                    const length = loadedCarrierBuffer.length;
                    inputLeft  = new Float32Array(length);
                    inputRight = new Float32Array(length);

                    const volume   = parseFloat(document.getElementById('synthVolume').value);
                    const octave   = parseInt(document.getElementById('synthOctave').value);
                    const detune   = parseFloat(document.getElementById('synthDetune').value);
                    const voices   = parseInt(document.getElementById('synthVoices').value);
                    const waveform = parseInt(document.getElementById('synthWaveform').value);

                    for (let i = 0; i < length; i++) {
                        synthState.t = i;
                        const synthSample = polyFsawFromKeyboard(
                            voices,
                            synthState.heldNotes,
                            octave,
                            detune,
                            waveform,
                            i * (48000 / 44100) * (loadedCarrierBuffer.sampleRate / 44100),
                        );
                        inputLeft[i]  = synthSample[0] * volume;
                        inputRight[i] = synthSample[1] * volume;
                    }
                } else {
                    // looped input is already adjusted to carrier duration
                    inputLeft  = renderedBuffer.getChannelData(0);
                    inputRight = renderedBuffer.numberOfChannels > 1
                        ? renderedBuffer.getChannelData(1)
                        : renderedBuffer.getChannelData(0);
                }

                // process iterations  now both input + carrier aligned
                processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer);
            
                // Enable buttons
                document.getElementById('playButton').disabled = false;
                document.getElementById('pauseButton').disabled = false;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('reprocessButton').disabled = false;

                //visualize(offlineAnalyser, offlineFrequencyData);
                showProcessPOP_UP('', false);
            });
        }

        async function processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer) {
            await new Promise(resolve => setTimeout(resolve, 20));
            if (iterations >= 2) {
                if (iterations == 69) {
                    showProcessPOP_UP_WL(`nice, 1/${iterations}`, true, true, 1 / iterations * 100);
                } else {
                    showProcessPOP_UP_WL(`Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done) \n1/${iterations} iterations`, true, true, 1 / iterations * 100);
                }
            } else {
                showProcessPOP_UP_WL('Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done)', true);
            }
            for (let i = 0; i < iterations; i++) {
                
                if (iterations >= 2) {
                    if (iterations == 69) {
                        showProcessPOP_UP_WL(`nice, ${i + 1}/${iterations}`, true, true, (i + 1) / iterations * 100);
                    } else {
                        showProcessPOP_UP_WL(`Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done) \n${i + 1}/${iterations} iterations`, true, true, i / iterations * 100);
                    }
                } else {
                    showProcessPOP_UP_WL('Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done)', true);
                }

                // Pause for 10ms (adjust as needed)
                await new Promise(resolve => setTimeout(resolve, 10));
                const SynthOnly = document.getElementById('SynthOnly')?.checked || false;
                    if (!SynthOnly) {
                        if (Vmode == 0) {
                            processedBuffer = applyFFTLogic(
                                offlineContext,
                                inputLeft,
                                inputRight,
                                carrierLeft,
                                carrierRight,
                                buffer.sampleRate
                            );
                        } else if (Vmode == 1) {
                            processedBuffer = applyAnalogLogic(
                                offlineContext,
                                inputLeft,
                                inputRight,
                                carrierLeft,
                                carrierRight,
                                buffer.sampleRate
                            );
                        } else if (Vmode == 2) {
                            processedBuffer = apply4ormLogic(
                                offlineContext,
                                inputLeft,
                                inputRight,
                                carrierLeft,
                                carrierRight,
                                buffer.sampleRate
                            );
                        }
                    } else {
                        // for debugging synth
                        const outputBuffer = offlineContext.createBuffer(2, inputLeft.length, buffer.sampleRate);
                        const outL = outputBuffer.getChannelData(0);
                        const outR = outputBuffer.getChannelData(1);

                        for (let t = 0; t < inputLeft.length; t++) {
                            // Simple passthrough (debug): copy input directly
                            const valL = inputLeft[t] || 0;  
                            const valR = inputRight[t] || 0;

                            outL[t] = valL;
                            outR[t] = valR;
                        }

                        processedBuffer = outputBuffer;
                    }


                    // For all modes, update input and carrier for next iteration
                    inputLeft = processedBuffer.getChannelData(0);
                    inputRight = processedBuffer.numberOfChannels > 1
                        ? processedBuffer.getChannelData(1)
                        : processedBuffer.getChannelData(0);

                    carrierLeft = inputLeft;
                    carrierRight = inputRight;
                }

                soundgoodizerVal = parseFloat(document.getElementById('SoundGoodizer').value);
                // apply SoundGoodizer (MBC) at end of each iteration

                if (soundgoodizerVal > 0) {
                    for (let t = 0; t < inputLeft.length; t++) {
                        inputLeft[t]  = SoundGoodizer(inputLeft[t], soundgoodizerVal, 0);
                        inputRight[t] = SoundGoodizer(inputRight[t], soundgoodizerVal, 1);

                        carrierLeft = inputLeft;
                        carrierRight = inputRight;
                    }
                }

            // Hide popup when done
            showProcessPOP_UP_WL('', false);
        }

        function apply4ormLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outL = outputBuffer.getChannelData(0);
            const outR = outputBuffer.getChannelData(1);

            // UI Parameters
            const ag = parseFloat(document.getElementById('Ag')?.value || 0.1);
            const res = parseFloat(document.getElementById('Resonance4orm')?.value || 0.999);
            const useArrLength = document.getElementById('UseArrLength')?.checked;
            const maxHarmonics = parseInt(document.getElementById('MaxHarm')?.value || 100);
            const harmExpr = document.getElementById('Harmonics')?.value || '[0,2,3,7].map(i => 2**(i/12))';
            const volume = parseFloat(document.getElementById('4ormVolume')?.value || 1.0);
            const _4ormFilterType = parseInt(document.getElementById('4ormFilterType')?.value || 0);
            const decayType = parseInt(document.getElementById('DecayType')?.value || 0);
            const HZ = context.sampleRate

            // Parse harmonic array
            let harmonics;
            try {
                harmonics = eval(harmExpr);
                if (!Array.isArray(harmonics)) throw 'Not an array';
            } catch (e) {
                harmonics = [0, 2, 3, 7].map(i => 2 ** (i / 12));
            }

            // Clamp and slice harmonics to MaxHarm
            const harmonicList = harmonics;

            // Use array length as number of stages or default to 8
            const stages = useArrLength ? harmonicList.length : maxHarmonics;

            // Clear previous state
            z9 = [];
            z10 = [];
            z11 = []

            z5_4 = [];

            function peak(a, decayF, call) {
                z5_4[call] ??= { var1: 0 };
                z5_4[call].var1 = Math.max(Math.abs(a), z5_4[call].var1 - Math.sqrt(decayF) / 2);
                return z5_4[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5_4[call] ??= { var1: 0 };
                z5_4[call].var1 = (1 - decayF) * z5_4[call].var1 + decayF * a * a;
                return Math.sqrt(z5_4[call].var1);
            }

            // Helper function: Repeats & wraps harmonic array with scaled octave down
            function repeatArr(inp, i) {
                return inp[i % inp.length] * 2 ** (-Math.floor(i / inp.length));
            }

            // Local filter function (special purpose)
            function $ap(inputY, ag = 0, res = 0, callCount = 0) {
                if (callCount >= z9.length || !z9[callCount]?.ap?.[0]) {
                    z9[callCount] = {
                        ap: Array.from({ length: 1 }, () => ({ p1: 0, p2: 0, p3: 0, p4: 0, pi: 0 }))
                    };
                }

                const state = z9[callCount].ap;
                const nres = 1 - res;
                const mr = 1 - nres * (0.5 + nres / 2);

                let out = 0;
                let i = 0;
                const stageAg = ag;
                const a = Math.min(Math.max(1 - (stageAg * stageAg / 4), 0), 0.9999);
                const s = state[i];

                const input = inputY - s.pi * mr;

                const y1 = -a * input + s.p1 + a * s.p2;
                s.p1 = input;
                s.p2 = y1;

                const y2 = -a * y1 + s.p3 + a * s.p4;
                s.p3 = y1;
                s.p4 = y2;

                s.pi = -y2;

                out = (s.pi + input);

                return out;
            }

            function $lp(d, c, r = 0, callCount = 0) {
                if (!z10[callCount]) {
                    z10[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                }

                const z = z10[callCount];
                let y = 0;
                let i = 0;
                let cc = Math.min(Math.max(c, 0), 0.9999);
                const fbv = r + r / (1 - cc);
                z.lp[i] += cc * (d - z.lp[i] + fbv * (z.lp[i] - z.fp[i]));
                z.fp[i] += cc * (z.lp[i] - z.fp[i]);
                y = z.fp[i];

                return y;
            }

            function $bp(d, c, r = 0, callCount = 0) {
                if (!z11[callCount]) {
                    z11[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                }

                const z = z11[callCount];
                let y = 0;
                let i = 0;
                let cc = Math.min(Math.max(c, 0), 0.9999);
                const fbv = r + r / (1 - cc);
                z.lp[i] += cc * (d - z.lp[i] + fbv * (z.lp[i] - z.fp[i]));
                z.fp[i] += cc * (z.lp[i] - z.fp[i]);
                y = (z.fp[i] - z.lp[i]);

                return y;
            }

            let tt = 0;
            const PWMwidth = parseFloat(document.getElementById('PWMwidth')?.value || 0.5);
            function generator(p, inp) {
                const gen_type = parseInt(document.getElementById('gen_type')?.value || 0);
                let wave = null;
                switch (gen_type) {
                    case 0: // input 2
                        wave = (t) => inp;
                        break;
                    case 1: // Sine wave
                        wave = (t) => Math.sin(2 * Math.PI * t );
                        break;
                    case 4: // Square wave
                        wave = (t) => (t % 1 < PWMwidth ? 1 : -1);
                        break;
                    case 3: // Sawtooth wave
                        wave = (t) => (t % 1) - 1;
                        break;
                    case 2: // Triangle wave
                        wave = (t) => Math.abs((t % 1)*2-1) * 2 - 1;
                        break;
                    case 5: // Noise
                        wave = (t) => Math.random() * 2 - 1;
                        break;
                    default:
                        wave = (t) => Math.sin(2 * Math.PI * t);
                        break;
                }
                tt += 1;
                return wave(tt*p/Math.PI/4);
            }
            const rel = parseFloat(document.getElementById('release')?.value || 0.0);
            const pitch = parseFloat(document.getElementById('pitch')?.value || 0.0);
            const pitchV = 2 ** (-pitch / 12);
            const resonance2 = parseFloat(document.getElementById('resonance2')?.value || 0.999);
            const $FUNC = (IP, c, r, stages, arr, call , IP2) => {
                let F;
                switch (_4ormFilterType) {
                    case 0: F = $lp; break;
                    case 1: F = $ap; break;
                    case 2: F = $bp; break;
                    default: F = $lp;
                }
                let out = 0;
                for (let i = 0; i < stages; i++) {
                    let tt=0
                    const Fcall = call * stages*2 + i
                    const stageAg = ag * repeatArr(arr, i);
                    const dec=[rms,peak][decayType]
                    if (document.getElementById('use_gen')?.checked) {
                        const GENi = generator(stageAg/stages, IP2)*stages;
                        let GEN = 0
                        if (resonance2 == 0) {
                            GEN = GENi;
                        } else {
                            GEN = F(GENi, stageAg, resonance2, Fcall+stages)/2;
                        }


                        out += GEN*dec(Math.abs(F(IP, stageAg*pitchV, res, Fcall))/2,2**-((rel*3)**2)/400,Fcall);
                    } else {
                        // Use the input directly
                        out += F(IP, stageAg, res, Fcall);
                    }
                }
                return out/stages;
            }
            // Apply processing
            for (let t = 0; t < inputLeft.length; t++) {
                const inL = carrierLeft[t];
                const inR = carrierRight[t];

                const inCL = inputLeft[t];
                const inCR = inputRight[t];

                //const $FUNC = [$lp, $ap, $bp][_4ormFilterType];

                const valL = $FUNC(inL*volume, ag, res, stages, harmonicList, 0, inCL) / 8;
                const valR = $FUNC(inR*volume, ag, res, stages, harmonicList, 1, inCR) / 8;

                outL[t] = valL;
                outR[t] = valR;
            }

            return outputBuffer;
        }

        const clamp=(minn,maxx,value)=>Math.min(Math.max(value,minn),maxx)

        function studyAnalogFilters() {
            let z2S=[{lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0}]
            let z3S=[{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}]
            let z4S=[{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}]
            let z8S=[{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}]
            let z7S=[{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
            let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))}]

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2S[callCount]) {
                    z2S[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2S[callCount].lp6 += cc * (f - z2S[callCount].lp6 + fbv * (z2S[callCount].lp6 - z2S[callCount].lp12));
                z2S[callCount].lp12 += cc * (z2S[callCount].lp6 - z2S[callCount].lp12);
                z2S[callCount].lp18 += cc * (z2S[callCount].lp12 - z2S[callCount].lp18);
                z2S[callCount].lp24 += cc * (z2S[callCount].lp18 - z2S[callCount].lp24);
                z2S[callCount].lp30 += cc * (z2S[callCount].lp24 - z2S[callCount].lp30);
                z2S[callCount].lp36 += cc * (z2S[callCount].lp30 - z2S[callCount].lp36);
                z2S[callCount].lp42 += cc * (z2S[callCount].lp36 - z2S[callCount].lp42);
                z2S[callCount].lp48 += cc * (z2S[callCount].lp42 - z2S[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2S[callCount].lp6;
                    case 2:  return z2S[callCount].lp12;
                    case 3:  return z2S[callCount].lp18;
                    case 4:  return z2S[callCount].lp24;
                    case 5:  return z2S[callCount].lp30;
                    case 6:  return z2S[callCount].lp36;
                    case 7:  return z2S[callCount].lp42;
                    case 8:  return z2S[callCount].lp48;
                    default: return z2S[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3S[callCount]) {
                    z3S[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3S[callCount].hp6 += cc * (f - z3S[callCount].hp6 + fbv * (z3S[callCount].hp6 - z3S[callCount].hp12));
                z3S[callCount].hp12 += cc * (z3S[callCount].hp6 - z3S[callCount].hp12);
                x = f - ((dbv >= 2) ? z3S[callCount].hp12 : z3S[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3S[callCount].hp18 += cc * (x - z3S[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3S[callCount].hp24 += cc * (x - z3S[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3S[callCount].hp30 += cc * (x - z3S[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3S[callCount].hp36 += cc * (x - z3S[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3S[callCount].hp42 += cc * (x - z3S[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3S[callCount].hp48 += cc * (x - z3S[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.5, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (callCount >= z4S.length) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4S[callCount].bp1 += cc * (f - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2));
                    z4S[callCount].bp2 += cc * (z4S[callCount].bp1 - z4S[callCount].bp2);
                    z4S[callCount].bp3 += cc * (z4S[callCount].bp2 - z4S[callCount].bp3);
                    z4S[callCount].bp4 += cc * (z4S[callCount].bp3 - z4S[callCount].bp4);
                    z4S[callCount].bp5 += cc * (z4S[callCount].bp4 - z4S[callCount].bp5);
                    z4S[callCount].bp6 += cc * (z4S[callCount].bp5 - z4S[callCount].bp6);
                    z4S[callCount].bp7 += cc * (z4S[callCount].bp6 - z4S[callCount].bp7);
                    z4S[callCount].bp8 += cc * (z4S[callCount].bp7 - z4S[callCount].bp8);
                    z4S[callCount].bp9 += cc * (z4S[callCount].bp8 - z4S[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4S[callCount].bp1 - z4S[callCount].bp2; break;
                        case 2: out = z4S[callCount].bp2 - z4S[callCount].bp3; break;
                        case 3: out = z4S[callCount].bp3 - z4S[callCount].bp4; break;
                        case 4: out = z4S[callCount].bp4 - z4S[callCount].bp5; break;
                        case 5: out = z4S[callCount].bp5 - z4S[callCount].bp6; break;
                        case 6: out = z4S[callCount].bp6 - z4S[callCount].bp7; break;
                        case 7: out = z4S[callCount].bp7 - z4S[callCount].bp8; break;
                        case 8: out = z4S[callCount].bp8 - z4S[callCount].bp9; break;
                        default: out = z4S[callCount].bp2 - z4S[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w=1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4S[callCount].bp3 += clamp(-1, 1, f - z4S[callCount].bp3) * cc;
                            z4S[callCount].bp1 += clamp(-1, 1, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4S[callCount].bp3 += clamp(-cc, cc, f - z4S[callCount].bp3);
                            z4S[callCount].bp1 += clamp(-cc, cc, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)));
                            break;
                    }
                    z4S[callCount].bp2 += clamp(-1, 1, z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    //z4S[callCount].bp3 += (f - z4S[callCount].bp3) * cc * (4 + cc * 1) / 5;
                    z4S[callCount].bp1 += (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)) * cc;
                    z4S[callCount].bp2 += (z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1 - z4S[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/32 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (callCount >= z7S.length) {
                        z7S.push({
                            p1: 0, p2: 0, p3: 0, p4: 0,
                            p5: 0, p6: 0, p7: 0, p8: 0,
                            pi: 0
                        });
                    }
                    const s = z7S[callCount];

                    const nres = 1 - res;
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const a = clamp(0, 0.9999, 1 - (ag*ag / 4));

                    const input = inputY - s.pi * mr;
                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input ;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;
                

                    s.pi = -y2;  // You can choose [y2, y4] for smoother vs sharper

                    callCount++;
                    return (y2+input)/64*(1+ag*8);
                } catch (e) {
                    throw e;
                }
            }

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPCS[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    f = (st.bp1 - st.bp2) * (1+cc**2) * (1+cc**2+cc**7*2.75); // feed forward into next stage
                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                        st.bp2 += cc * (st.bp1 - st.bp2);
                        f = (st.bp1 - st.bp2) * (1-r**2) * (1+cc**2+cc**7*2.75); // feed forward into next stage
                        o=f
                    }

                    return o*(1+cc+cc**3*4)*4 // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r

                    const s = zBPCS[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)
                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc)
                        f*=1-fb
                        o=f
                    }

                    return o*(.25+cc*2)*8 // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            const canvas = document.getElementById('filterView');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get analog control values
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const resonance = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const bpwidth = parseFloat(document.getElementById('BPwidth').value);
            const altBP = parseInt(document.getElementById('Alt_BP').value) || 0;

            // Frequency range (log scale)
            const minFreq = 20, maxFreq = 20000;
            const sampleRate = 44100;
            const points = canvas.width;
            let testInput = 0;

            // Prepare for drawing
            ctx.save();
            ctx.strokeStyle = "#4af";
            ctx.lineWidth = 2;
            ctx.beginPath();

            // For each frequency, compute filter response
            // Smoothing window size (must be odd)
            const SMOOTH_WINDOW = 9;
            const halfWindow = Math.floor(SMOOTH_WINDOW / 2);
            const dbVals = [];

            // First, calculate all dB values (unsmoothed)
            for (let x = 0; x < points; x++) {
                // Logarithmic frequency mapping
                const freq = minFreq * Math.pow(maxFreq / minFreq, x / (points - 1));
                const FLTcutoff = .1;

                // Reset filter state for each frequency
                let z2S = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
                let z3S = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
                let z4S = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
                let z8S = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
                let z7S = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
                let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];

                //console.log(altBP)

                // Sine wave test: run for several cycles and measure output amplitude
                const cycles = 1;
                const samplesPerCycle = Math.round(sampleRate / freq);
                const totalSamples = cycles * samplesPerCycle;
                let maxOut = 0;

                for (let t = 0; t < totalSamples; t++) {
                    const testInput = Math.sin(2 * Math.PI * freq * t / sampleRate);
                    let out = 0;
                    
                    switch (altBP) {
                        case 0:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 1:
                            out = bp2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 2:
                            out = bp3(testInput*4, FLTcutoff, resonance, db, 0);
                            break;
                        case 3:
                            out = bp4(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 4:
                            out = bp5(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 5:
                            out = ap(testInput, FLTcutoff, resonance, 0);
                            break;
                        case 6:
                            out = bpTC(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 7:
                            out = bpTC2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        default:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                    }
                    // Use peak amplitude (or accumulate RMS if you prefer)
                    if (t > totalSamples - samplesPerCycle) { // Only last cycle for steady-state
                        maxOut = Math.max(maxOut, Math.abs(out));
                    }
                }

                // Convert to dB
                let dbVal = 20 * Math.log10(maxOut + 1e-8);
                dbVals[x] = dbVal-20;   //it goes off grapth so i subtract it by 20
            }

            // Now, smooth the dB values using a moving average
            const smoothedDbVals = [];
            for (let x = 0; x < points; x++) {
                let sum = 0, count = 0;
                for (let k = -halfWindow; k <= halfWindow; k++) {
                    const idx = x + k;
                    if (idx >= 0 && idx < points) {
                        sum += dbVals[idx];
                        count++;
                    }
                }
                smoothedDbVals[x] = sum / count;
            }

            // Draw the smoothed graph
            for (let x = 0; x < points; x++) {
                // Normalize to canvas height (0 dB at 1/4 from top, -60 dB at bottom)
                const y = canvas.height * 0.25 + (canvas.height * 0.75) * (1 - (smoothedDbVals[x] + 60) / 60);

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            // Draw frequency grid
            ctx.save();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.font = "10px Arial";
            ctx.fillStyle = "#aaa";
            for (let f of [50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000]) {
                const x = Math.log(f / minFreq) / Math.log(maxFreq / minFreq) * (canvas.width - 1);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.fillText(f + "Hz", x + 2, canvas.height - 2);
            }
            ctx.restore();
        }

        // Draw on page load
        document.addEventListener('DOMContentLoaded', studyAnalogFilters);

        function applyAnalogLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Helper functions and state
            const min = Math.min, max = Math.max, abs = Math.abs, pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, PI = Math.PI;
            const clamp = (minn, maxx, value) => min(max(value, minn), maxx);

            let z2 = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
            let z3 = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
            let z4 = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
            let z8 = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
            let z5 = [{var1:0}];
            let z7 = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}];
            let zBPC = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];
            
            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2[callCount]) {
                    z2[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2[callCount].lp6 += cc * (f - z2[callCount].lp6 + fbv * (z2[callCount].lp6 - z2[callCount].lp12));
                z2[callCount].lp12 += cc * (z2[callCount].lp6 - z2[callCount].lp12);
                z2[callCount].lp18 += cc * (z2[callCount].lp12 - z2[callCount].lp18);
                z2[callCount].lp24 += cc * (z2[callCount].lp18 - z2[callCount].lp24);
                z2[callCount].lp30 += cc * (z2[callCount].lp24 - z2[callCount].lp30);
                z2[callCount].lp36 += cc * (z2[callCount].lp30 - z2[callCount].lp36);
                z2[callCount].lp42 += cc * (z2[callCount].lp36 - z2[callCount].lp42);
                z2[callCount].lp48 += cc * (z2[callCount].lp42 - z2[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2[callCount].lp6;
                    case 2:  return z2[callCount].lp12;
                    case 3:  return z2[callCount].lp18;
                    case 4:  return z2[callCount].lp24;
                    case 5:  return z2[callCount].lp30;
                    case 6:  return z2[callCount].lp36;
                    case 7:  return z2[callCount].lp42;
                    case 8:  return z2[callCount].lp48;
                    default: return z2[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3[callCount]) {
                    z3[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3[callCount].hp6 += cc * (f - z3[callCount].hp6 + fbv * (z3[callCount].hp6 - z3[callCount].hp12));
                z3[callCount].hp12 += cc * (z3[callCount].hp6 - z3[callCount].hp12);
                x = f - ((dbv >= 2) ? z3[callCount].hp12 : z3[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3[callCount].hp18 += cc * (x - z3[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3[callCount].hp24 += cc * (x - z3[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3[callCount].hp30 += cc * (x - z3[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3[callCount].hp36 += cc * (x - z3[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3[callCount].hp42 += cc * (x - z3[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3[callCount].hp48 += cc * (x - z3[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);
                    z4[callCount].bp3 += cc * (z4[callCount].bp2 - z4[callCount].bp3);
                    z4[callCount].bp4 += cc * (z4[callCount].bp3 - z4[callCount].bp4);
                    z4[callCount].bp5 += cc * (z4[callCount].bp4 - z4[callCount].bp5);
                    z4[callCount].bp6 += cc * (z4[callCount].bp5 - z4[callCount].bp6);
                    z4[callCount].bp7 += cc * (z4[callCount].bp6 - z4[callCount].bp7);
                    z4[callCount].bp8 += cc * (z4[callCount].bp7 - z4[callCount].bp8);
                    z4[callCount].bp9 += cc * (z4[callCount].bp8 - z4[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4[callCount].bp1 - z4[callCount].bp2; break;
                        case 2: out = z4[callCount].bp2 - z4[callCount].bp3; break;
                        case 3: out = z4[callCount].bp3 - z4[callCount].bp4; break;
                        case 4: out = z4[callCount].bp4 - z4[callCount].bp5; break;
                        case 5: out = z4[callCount].bp5 - z4[callCount].bp6; break;
                        case 6: out = z4[callCount].bp6 - z4[callCount].bp7; break;
                        case 7: out = z4[callCount].bp7 - z4[callCount].bp8; break;
                        case 8: out = z4[callCount].bp8 - z4[callCount].bp9; break;
                        default: out = z4[callCount].bp2 - z4[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w = 1,callCount) {
                try {
                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;
                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4[callCount].bp3 += clamp(-1, 1, f - z4[callCount].bp3) * cc;
                            z4[callCount].bp1 += clamp(-1, 1, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4[callCount].bp3 += clamp(-cc, cc, f - z4[callCount].bp3);
                            z4[callCount].bp1 += clamp(-cc, cc, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2)));
                            break;
                    }
                    z4[callCount].bp2 += clamp(-1, 1, z4[callCount].bp1 - z4[callCount].bp2) * cc;

                    out = z4[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0});
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);

                    let out=0;
                    out = z4[callCount].bp1 - z4[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/128 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (!z7[callCount]) {
                        z7[callCount] = {p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0};
                    }
                    const s = z7[callCount];

                    const nres = 1 - res;
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);

                    const a = clamp(0, 0.9999, 1 - (ag * ag / 4));

                    const input = inputY - s.pi * mr;

                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;

                    s.pi = -y2;

                    return (y2+input)/64*(1+ag*8)
                } catch (e) {
                    throw e;
                }
            };

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    f = (st.bp1 - st.bp2) * (1+cc**2) * (1+cc**2+cc**7*2.75); // feed forward into next stage
                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                        st.bp2 += cc * (st.bp1 - st.bp2);
                        f = (st.bp1 - st.bp2) * (1-r**2) * (1+cc**2+cc**7*2.75); // feed forward into next stage
                        o=f
                    }

                    return o*(1+cc+cc**3*4)*4 // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r //+ r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)

                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc) * (1-fb)
                        o=f
                    }

                    return o*(.25+cc)*8// Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            // UI values
            const sel = parseInt(document.getElementById('decayType').value)-1;
            const rel = parseFloat(document.getElementById('release').value);
            const fb = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const dw = parseFloat(document.getElementById('BPwidth').value);
            const vol = parseFloat(document.getElementById('Volboost').value);
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const flip = document.getElementById('FreqFlip').checked;
            const pitch = parseFloat(document.getElementById('pitch').value);
            const decayByFreq = parseInt(document.getElementById('decayByFreq').value) || 0;
            const freqCurve = parseFloat(document.getElementById('freqCurve').value) || 0;
            const UseResBasedOnDistance = document.getElementById('UseResBasedOnDistance').checked;
            const addLPtoLowEnd = document.getElementById('addLPtoLowEnd').checked;
            const addHPtoHighEnd = document.getElementById('addHPtoHighEnd').checked;

            // Envelope followers
            function peak(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = Math.max(abs(a), z5[call].var1 - sqrt(decayF) / 2);
                return z5[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = (1 - decayF) * z5[call].var1 + decayF * a * a;
                return sqrt(z5[call].var1);
            }
            
            function bandFrequency(bands, index, sampleRate, convertToFloat = true) {
                const fmin = 20;                         // lowest frequency
                const fmax = sampleRate / 2.205;         // Nyquist-ish limit
                const ratio = Math.pow(fmax / fmin, 1 / bands); // geometric step

                // center frequency of this band
                let freq = fmin * Math.pow(ratio, index + 0.5);

                // optionally normalize to [0,1]
                if (convertToFloat) {
                    freq = freq / (sampleRate / 2);
                }
                return freq;
            }

            let modulatedValue = 1
            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
            const duration = inputLeft.length / sampleRate;

            function curve(i, nv) {
                switch (freqCurve) {
                    case 0:
                        ic = i / nv;
                        EQvol = 1;
                        distance = (i+1)/nv - i/nv;
                        break;
                    case 1:
                        ic = Math.log(i/nv+1)/Math.LOG2E;
                        EQvol = 1-ic/10;
                        distance = (Math.log((i+1)/nv+1)/Math.LOG2E) - ic;
                        break;
                    case 2:
                        ic = Math.exp(i/nv)-1;
                        EQvol = .9+ic/10;
                        distance = (Math.exp((i+1)/nv)-1) - ic;
                        break;
                    case 3:
                        ic = 2**(i/nv*8-8);
                        EQvol = 3-ic*2.5;
                        distance = 2**((i+1)/nv*8-8) - ic
                        break;
                    case 4:
                        ic = (i/nv)**2;
                        EQvol = .9+ic/10;
                        distance = ((i+1)/nv)**2 - ic;
                        break;
                    case 5:
                        ic = bandFrequency(nv,i,48000)**.5
                        EQvol = 1+4*(1-i/nv)
                        distance = bandFrequency(nv,i+1,48000)**.5 - ic;
                        break;
                    case 6:
                        ic = 2**(i/nv*8-8);
                        EQvol = 1;
                        distance = 2**((i+1)/nv*8-8) - ic
                        break;
                    default:
                        ic = i/nv;
                        EQvol = 1;
                        distance = (i+1)/nv - ic;
                        break;
                }

                return {ic, distance, EQvol};
            }

            // Vocoder function
            function vocoder(inp, car, bool=false) {
                let relv = 0, nv = n, volv = vol, fbv = fb, dbv = db, dww = dw, selv = sel;
                let p = [rms, peak][max(min(selv, 2), 0)];
                let result = 0;
                let carrierSum = 0, modSum = 0;
                const Alt_BP=parseInt(document.getElementById('Alt_BP').value) || 0;
                let distance = 0;
                let EQvol = 1;

                for (let i = 1; i <= nv; i++) {

                    // Filter input (modulator) and carrier
                    const filter = (v, m, f = 0, dwo, FRQ) => {
                        // Flip FRQ if f flag is set
                        FRQ = f ? 1 - FRQ : FRQ;

                        if (Alt_BP === 0) {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 1) {
                            return bp2(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 2) {
                            return bp3(v * 256, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 3) {
                            return bp4(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 4) {
                            return bp5(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 5) {
                            return ap(v * 64, FRQ, fbv, m);
                        } else if (Alt_BP === 6) {
                            return bpTC(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 7) {
                            return bpTC2(v * 64, FRQ, fbv, dbv, m);
                        } else {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        }
                    };

                    let vol = 1;

                    // Get curve values
                    let { ic, distance, EQvol} = curve(i, nv);


                    //console.log(i, ic, distance)
                    if (UseResBasedOnDistance && (freqCurve==6 || freqCurve==5 || freqCurve==4 || freqCurve==3)) {
                        fbv = fb * (1 - distance*1.75);
                        //EQvol = 1
                    }

                    switch (decayByFreq) {
                        case 0:
                            relv = rel;
                            break;
                        case 1:
                            relv = rel + ic/4;
                            break;
                        case 2:
                            relv = rel + (1-ic)/4;
                            break;
                        default:
                            relv = rel;
                    }

                    const g = ic / 2**(pitch/12);

                    const modFiltered = filter(inp, i + 0 + bool*n*3, flip, dww, g)*EQvol;
                    const carFiltered = filter(car, i + n + bool*n*3, false, dww, ic)*EQvol;

                    const absFilterX = abs(modFiltered);
                    const mod = p(absFilterX, 2**-((relv*3)**2)/400, i + bool*n*3);

                    // For debugging: sum up mod and carrier
                    //modSum += mod;
                    //carrierSum = carFiltered;
                    //combined = modFiltered/512

                    // If mod is always zero, you will only hear silence or the modular
                    const combined = mod * carFiltered * (1 - fbv) / sqrt(nv * 10) * (1 - g);
                    result += combined * volv;

                    //console.log(result, mod, carFiltered, combined, inp, car, i, nv, modulatedValue);
                }

                let LPOUT = 0
                if (addLPtoLowEnd) {
                    let { ic, distance, EQvol: eqv } = curve(1, nv);

                    fbvv = UseResBasedOnDistance?fb*(1-distance*1.75):fb
                    LPC = lp(car*64, ic, fbv, 2, n*2+2 + bool*n*3);
                    LPM = lp(inp*64, ic, fbv, 2, n*2+3 + bool*n*3);

                    ABSLPC = abs(LPM);
                    LPOUT = LPC * p(ABSLPC, 2**-((rel*3)**2)/400, n*2+2)
                }

                if (addHPtoHighEnd) {
                    let { ic, distance, EQvol: eqv } = curve(nv, nv);

                    fbvv = UseResBasedOnDistance?fb*(1-distance*1.75):fb
                    LPC = hp(car*64, ic, fbv, 2, n*2+2 + bool*n*3);
                    LPM = hp(inp*64, ic, fbv, 2, n*2+3 + bool*n*3);

                    ABSLPC = abs(LPM);
                    LPOUT = LPC * p(ABSLPC, 2**-((rel*3)**2)/400, n*2+3)
                }

                let LOUT = LPOUT * volv / 8 * dbv + result*n/2;

                // Prevent NaN/Infinity
                if (!isFinite(result) || isNaN(result)) result = 0;
                return LOUT / 128;
            }

            // Output buffer
            const bufferLen = inputLeft.length;
            const outputBuffer = context.createBuffer(2, bufferLen, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);
            // Analog vocoder processing
            for (let idx = 0; idx < bufferLen; idx++) {
                const idxL = idx % carrierLeft.length;
                const idxR = idx % carrierRight.length;
                outputLeft[idx] = vocoder(carrierLeft[idxL], inputLeft[idx], 0);
                outputRight[idx] = vocoder(carrierRight[idxR], inputRight[idx], 1);
            }

            return outputBuffer;
        }

        function applyFFTLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Add the new FFT functions for classic magnitude transfer
            function bitReverseIndexes(n){ 
                const rev = new Uint32Array(n); 
                const bits = Math.log2(n)|0; 
                for(let i=0;i<n;i++){ 
                    let j=0, x=i; 
                    for(let b=0;b<bits;b++){ j=(j<<1)|(x&1); x>>=1 } 
                    rev[i]=j; 
                } 
                return rev; 
            }

            const type = parseInt(document.getElementById('BR_voc_Type').value);
            const wave = (o) => {
                switch (type) {
                    case 0:
                        return sin(o);
                    case 1:
                        return asin(sin(o)) / PI * 2.25;
                    case 2:
                        return sin(sin(o) * 2) * 0.9;
                    case 3:
                        return sin(o * 2) * 0.9;
                    case 4:
                        return sin(o * 3) * 0.8;
                    case 5:
                        return o / PI & 1 ? 0.65 : -0.65;
                    case 6:
                        return ((o / PI) % 2 - 1) / 1.4;
                    case 7:
                        return sin(sin(sin(o) * 2) * 2) * 0.8;
                    case 8:
                        return sin(o / 2) * 0.9;
                    case 9:
                        return sin(o ** 2) * 0.95;
                    case 10:
                        return sin(o) ** 2;
                    case 11:
                        return (-abs(sin(o / 2)) + 0.5) * 1.7;
                    case 12:
                        return (abs(sin(o / 2 + PI / 4) ** 3) - 0.5) * 1.8;
                    case 13:
                        return sin(rand(o / 1e10) * PI) * 0.9;
                    case 14:
                        return sin(o) ** 3 * 1.15;
                    case 15:
                        return sin(o * sin(o)) / 2;
                    case 16:
                        return harm(o) * 0.8;
                    case 17:
                        return harmS(o) * 0.9;
                    case 18:
                        return sin((o * 128 / PI | o * 127 / PI) / 128 * PI);
                    case 19:
                        return sin((o * 4 / PI | 0) / 4 * PI);
                    default:
                        return sin(o);
                }
            };

            function fft_classic(re, im, useWave = false, clampWave = false){ 
                const n = re.length; 
                if(n<=1) return; 
                const rev = bitReverseIndexes(n); 
                const cre = new Float32Array(n), cim = new Float32Array(n); 
                for(let i=0;i<n;i++){ cre[i]=re[rev[i]]; cim[i]=im[rev[i]] } 
                for(let len=2; len<=n; len<<=1){ 
                    const ang = -2*Math.PI/len; 
                    let wlenRe, wlenIm;
                    
                    if(useWave) {
                        wlenRe = wave(ang + Math.PI/2);  // cos equivalent using wave
                        wlenIm = wave(ang);              // sin equivalent using wave
                        
                        // Clamp wave output between -1 and 1
                        if(clampWave) {
                            wlenRe = Math.max(-1, Math.min(1, wlenRe));
                            wlenIm = Math.max(-1, Math.min(1, wlenIm));
                        }
                    } else {
                        wlenRe = Math.cos(ang);
                        wlenIm = Math.sin(ang);
                    }
                    
                    for(let i=0;i<n;i+=len){ 
                        let ur=1, ui=0; 
                        for(let j=0;j<len/2;j++){ 
                            const evenR = cre[i+j], evenI = cim[i+j]; 
                            const oddR = cre[i+j+len/2], oddI = cim[i+j+len/2]; 
                            const tr = ur*oddR - ui*oddI; 
                            const ti = ur*oddI + ui*oddR; 
                            cre[i+j] = evenR + tr; 
                            cim[i+j] = evenI + ti; 
                            cre[i+j+len/2] = evenR - tr; 
                            cim[i+j+len/2] = evenI - ti; 
                            const tmp = ur*wlenRe - ui*wlenIm; 
                            ui = ur*wlenIm + ui*wlenRe; 
                            ur = tmp; 
                        } 
                    } 
                } 
                re.set(cre); im.set(cim); 
            }

            function ifft_classic(re, im, useWave = false, clampWave = false){ 
                // conjugate, forward fft, conjugate, divide 
                for(let i=0;i<re.length;i++) im[i] = -im[i]; 
                fft_classic(re, im, useWave, clampWave); 
                for(let i=0;i<re.length;i++){ re[i] = re[i]/re.length; im[i] = -im[i]/re.length } 
            }

            const FFTsize = document.getElementById('FFTsize').value;
            const SIZE = 2 ** FFTsize;

            const OVERLAP = 4;
            const HOP_SIZE = SIZE / OVERLAP;
            const PI = Math.PI;
            const cos = Math.cos;
            const sin = Math.sin;
            const asin = Math.asin;
            const abs = Math.abs;

            // Usage example in your X function:
            const X = o => {
                return { 
                    r: wave(o + PI / 2), 
                    i: wave(o) 
                };
            };

            const X2 = o => ({ r: cos(o), i: sin(o) }); //back up
            const M = (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + b.r * a.i });
            const A = (a, b) => ({ r: a.r + b.r, i: a.i + b.i });

            const FFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = { r: I[ii], i: 0 };
                else {
                    FFT(O, I, oi, ii, N / 2, s * 2);
                    FFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(-2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            const IFFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = I[ii];
                else {
                    IFFT(O, I, oi, ii, N / 2, s * 2);
                    IFFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            // Calculate the duration of the audio buffer
            const duration = inputLeft.length / sampleRate;

            // Create output buffer (stereo)
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);

            // Initialize buffers
            const I = Array.from({ length: SIZE }, () => 0);
            const O = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));
            const I2 = Array.from({ length: SIZE }, () => 0);
            const O2 = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));

            const pitch = parseInt(document.getElementById('pitch').value);
            const Shift = parseInt(document.getElementById('BandShift').value)
            const divbands = parseInt(document.getElementById('divbands').value);

            const DecayType = parseInt(document.getElementById('decayType').value);
            const Release = parseFloat(document.getElementById('release').value) ** (1 / (4 + (divbands - 1) * 2));
            const BassBoost = parseFloat(document.getElementById('BassBoost').value);

            const envelopeStateLeft = Array(SIZE).fill(0);
            const envelopeStateRight = Array(SIZE).fill(0);

            let ReverbStateLeft = Array(SIZE).fill(0);
            let ReverbStateRight = Array(SIZE).fill(0);

            const window = Array.from({ length: SIZE }, (_, i) =>
                0.5 * (1 - Math.cos(2 * Math.PI * i / (SIZE - 1)))
            );

            const clampOut = parseFloat(document.getElementById('clamp_output').value);
            const Threshold = parseFloat(document.getElementById('threshold').value);

            // Check if classic magnitude transfer mode is enabled
            const useClassicMagnitudeTransfer = parseInt(document.getElementById('FFTmode').value||0);

            // Process left and right channels separately
            const processChannel = (inputData, carrierData, outputData, envelopeState, ReverbState) => {
                const startTime = performance.now();
                const Break = document.getElementById('BandBreak').checked;
                const flip = document.getElementById('FreqFlip').checked

                for (let t = 0; t < inputData.length; t += HOP_SIZE) {
                    const currentTime = (performance.now() - startTime) / 1000; // Current time in seconds

                    // === CLASSIC MAGNITUDE TRANSFER MODE ===
                    if (useClassicMagnitudeTransfer) {
                        const reM = new Float32Array(SIZE);
                        const imM = new Float32Array(SIZE);
                        const reC = new Float32Array(SIZE);
                        const imC = new Float32Array(SIZE);

                        // Fill input buffers with windowing
                        for (let i = 0; i < SIZE; i++) {
                            reC[i] = (inputData[t + i] || 0) * window[i];
                            imC[i] = 0;
                            reM[i] = (carrierData[t + i] || 0) * window[i];
                            imM[i] = 0;
                        }

                        // Perform FFT
                        const brOut = parseInt(document.getElementById('BR_out').value);
                        clampWaveOutput = 1;
                        switch (brOut) {
                            case 1:
                                fft_classic(reM, imM, true, clampWaveOutput);
                                fft_classic(reC, imC, true, clampWaveOutput);
                                break;
                            case 2:
                                fft_classic(reM, imM, true, clampWaveOutput);
                                fft_classic(reC, imC, false, false);
                                break;
                            case 3:
                                fft_classic(reM, imM, false, false);
                                fft_classic(reC, imC, true, clampWaveOutput);
                                break;
                            default:
                                fft_classic(reM, imM, false, false);
                                fft_classic(reC, imC, false, false);
                        }

                        //  envelope state arrays (persistent across calls!)
                        if (!applyFFTLogic._classicEnv) {
                            applyFFTLogic._classicEnv = new Float32Array(SIZE);
                        }
                        const env = applyFFTLogic._classicEnv;

                        const DecayType = parseInt(document.getElementById('decayType').value);
                        const Release   = parseFloat(document.getElementById('release').value) 
                                        ** (1 / (4 + (SIZE / 1024 - 1) * 2)); // similar scaling
                        const Ratio     = SIZE / 1024;

                        // Extract magnitude and phase
                        const magM = new Array(SIZE);
                        const phC  = new Array(SIZE);

                        for (let i = 0; i < SIZE; i++) {
                            const instMag = Math.sqrt(reM[i] * reM[i] + imM[i] * imM[i]); // instant magnitude

                            // --- envelope smoothing ---
                            const REL = Math.min((1 - Release) * Ratio, 1);
                            switch (DecayType) {
                                case 1: // RMS-like smoothing
                                    env[i] = (1 - REL) * env[i] + REL * instMag * instMag;
                                    magM[i] = Math.sqrt(env[i]);
                                    break;
                                case 2: // Peak hold + exponential release
                                    env[i] = Math.max(instMag, env[i] * (1 - REL));
                                    magM[i] = env[i];
                                    break;
                                default: // raw
                                    magM[i] = instMag;
                            }

                            phC[i] = Math.atan2(imC[i], reC[i]);
                        }

                        // Apply magnitude transfer
                        for (let i = 0; i < SIZE; i++) {
                            const outMag = magM[i];
                            const outPh  = phC[i];
                            reM[i] = outMag * Math.cos(outPh);
                            imM[i] = outMag * Math.sin(outPh);
                        }

                        // Apply volume and normalization
                        const volume = parseFloat(document.getElementById('volume').value) / Math.sqrt(SIZE / 1024);
                        for (let i = 0; i < SIZE; i++) {
                            reM[i] *= volume;
                            imM[i] *= volume;
                        }

                        // IFFT
                        ifft_classic(reM, imM);

                        // Overlap-add with windowing
                        for (let i = 0; i < SIZE; i++) {
                            const inputt = outputData[t + i] + reM[i] * window[i];
                            if (clampOut == 1) {
                                outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt)) / 3;
                            } else {
                                outputData[t + i] += reM[i] * window[i] / 3;
                            }
                        }
                    } else {
                        // Fill input buffer for input data with windowing
                        for (let i = 0; i < SIZE; i++) {
                            I[i] = (inputData[t + i] || 0) * window[i];
                            I2[i] = (carrierData[t + i] || 0) * window[i];
                        }

                        // Perform FFT on input data
                        FFT(O, I, 0, 0, SIZE, 1);

                        // Perform FFT on carrier data
                        FFT(O2, I2, 0, 0, SIZE, 1);
                        // === ORIGINAL PROCESSING MODE ===
                        // Modulate frequency components
                        for (let i = 0; i < SIZE; i++) {
                            let timer = currentTime; // Timer value between 0 and 1
                            const speedType = parseInt(document.getElementById('speedType').value)

                            switch (speedType) {
                                case 0:
                                    timer = currentTime / 8;
                                    break;
                                case 1:
                                    timer = currentTime / duration;
                                    break;
                                case 2:
                                    timer = currentTime * parseFloat(document.getElementById('userSpeed').value);
                                    break;
                            }

                            // Apply envelope following
                            let envelope = 0;
                            const mag1 = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                            let mag2 = 0;
                            let ip = 0;
                            let ip_ = 0;
                            const Ratio = (SIZE / 1024);

                            let callCount = 0;

                            const lin = (a, b, t) => a * (1 - t) + b * t;

                            // divide bands
                            for (let j = 0; j <= divbands; j++) {
                                ip = (i / 2 ** (pitch / 12) | 0);
                                const weight = 1 - abs(j - divbands / 2) / divbands;
                                
                                ip_ = Math.round(ip + (j - divbands / 2) + Shift);

                                if (flip) {
                                    ip_=Math.round(SIZE/16-ip_)
                                }

                                if (ip_ >= 0 && ip_ < SIZE && O2[ip_]) {
                                    mag2 += Math.sqrt(O2[ip_].r * O2[ip_].r + O2[ip_].i * O2[ip_].i) * weight;
                                } else {
                                    mag2 += 0;
                                }

                                const REL = Math.min((1 - Release) * Ratio, 1);

                                switch (DecayType) {
                                    case 1: // RMS
                                        envelopeState[i] = (1 - REL) * envelopeState[i] + REL * mag2 * mag2;
                                        envelope += Math.sqrt(envelopeState[i]);
                                        break;
                                    case 2: // Peak
                                        envelopeState[i] = Math.max(mag2, envelopeState[i] * (1 - REL));
                                        envelope += envelopeState[i];
                                        break;
                                }

                                const reverbAMT = parseFloat(document.getElementById("reverbAMT").value)
                                const reverbSIZE = parseFloat(document.getElementById("reverbSIZE").value)
                                
                                const RSIZE = Math.min((1 - reverbSIZE) * Ratio, 1);

                                const mag3 = envelope
                                
                                ReverbState[i] = (1 - RSIZE) * ReverbState[i] + RSIZE * mag3 * mag3;
                                envelope = Math.sqrt(ReverbState[i])*reverbAMT+mag3*(1-reverbAMT);
                                // somehow (1 + 2 / divbands / 2) solved the volume issue
                                envelope /= divbands * ((1 + 2 / divbands) / 2);
                            }

                            // Apply modulation with normalization and volume with BassBoost
                            const BassCurveType = parseInt(document.getElementById('BassCurve').value);
                            const normEQcurveType = parseInt(document.getElementById('EQType').value);

                            let BassCurve = 0;
                            switch (BassCurveType) {
                                case 0:
                                    BassCurve = 1;
                                    break;
                                case 1:
                                    BassCurve = 10 / (i + 1);
                                    break;
                                case 2:
                                    BassCurve = ((1 - i / SIZE) ** 2);
                                    break;
                            }

                            let normEQcurve = 0;
                            switch (normEQcurveType) {
                                case 0:
                                    normEQcurve = Math.min(1, (i < SIZE / 2 ? i : SIZE - i) / (SIZE / 4));
                                    break;
                                case 1:
                                    normEQcurve = Math.sin(i / SIZE * PI);
                                    break;
                            }

                            // Example calculation using the timer
                            let modulatedValue = 1
                            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
                            const modulatedInput = i*((timer*256|0)/256);

                            switch (simpleChorus) {
                                case 1:
                                    modulatedValue = sin(modulatedInput*PI);
                                    break;
                                case 2:
                                    modulatedValue = cos(modulatedInput*PI);
                                    break;
                                case 3:
                                    modulatedValue = asin(sin(modulatedInput*PI));
                                    break;
                                case 4:
                                    modulatedValue = asin(cos(modulatedInput*PI));
                                    break;
                            }

                            const normEQ = (normEQcurve + BassBoost * BassCurve / (Math.sqrt(Ratio)*1024) * 20) * modulatedValue

                            // Apply modulation based on BR_out value
                            switch (parseInt(document.getElementById('BR_out').value)) {
                                case 1:
                                    O[i] = M(O[i], X(2 * PI * i / SIZE));
                                    O2[i] = M(O2[i], X(2 * PI * i / SIZE));
                                    break;
                                case 3:
                                    O[i] = M(O[i], X2(2 * PI * i / SIZE));
                                    break;
                                case 2:
                                    O2[i] = M(O2[i], X2(2 * PI * i / SIZE));
                                    break;
                            }

                            const volume = document.getElementById('volume').value / Math.sqrt(Ratio);

                            const steps = parseFloat(document.getElementById('steps').value);
                            const RoundType = [Math.floor, Math.round, Math.ceil][parseInt(document.getElementById('RoundType').value)];
                            envelope = steps ? RoundType(envelope * (steps / 16)) / (steps / 16) : envelope;

                            O[i].r *= envelope * volume * normEQ;
                            O[i].i *= envelope * volume * normEQ;

                            if (clampOut == 2) {
                                O[i].r = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].r));
                                O[i].i = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].i));
                            }
                        }

                        let frequencyMagnitudes = Array(SIZE).fill(0);
                        if (clampOut == 4) {
                            for (let i = 0; i < SIZE; i++) {
                                const ratio = 2; // Compression ratio

                                // Calculate the magnitude of the frequency component
                                const magni = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                                frequencyMagnitudes[i] = Math.sqrt((frequencyMagnitudes[i] ** 2 * 24 + magni ** 2) / 25);
                                let level = frequencyMagnitudes[i];

                                let gain = Math.min(1, (Threshold / level) ** (ratio - 1)); // Compute gain reduction

                                O[i].r *= gain;
                                O[i].i *= gain;
                            }
                        }

                        if (Break) {
                            // Reverse the second half of the spectrum
                            for (let i = 1; i < SIZE / 2; i++) {
                                let tmp = O[i];
                                O[i] = O[SIZE - i];
                                O[SIZE - i] = tmp;
                            }
                            // discard the second half of the spectrum
                            for (let i = SIZE / 2; i < SIZE; i++) {
                                O[i].r = 0;
                                O[i].i = 0;
                            }
                        }

                        // Perform IFFT
                        IFFT(I, O, 0, 0, SIZE, 1);

                        // Overlap-add with windowing
                        for (let i = 0; i < SIZE; i++) {
                            const inputt =  outputData[t + i] + I[i].r / SIZE * window[i];
                            if (clampOut == 1) {
                                outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt));
                            } else {
                                outputData[t + i] += (I[i].r / SIZE) * window[i];
                            }
                        }
                    }
                }
            };

            // Process left channel
            processChannel(inputLeft, carrierLeft, outputLeft, envelopeStateLeft, ReverbStateLeft);

            // Process right channel
            processChannel(inputRight, carrierRight, outputRight, envelopeStateRight, ReverbStateRight);

            return outputBuffer;
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const synthKeyboardContainer = document.getElementById("synthKeyboardContainer");
            if (synthKeyboardContainer) {
                renderSynthKeyboard(synthKeyboardContainer, synthState.heldNotes);
                
                window.addEventListener('resize', () => {
                    renderSynthKeyboard(synthKeyboardContainer, synthState.heldNotes);
                });
            }
        });

        /*
         * Visualize the frequency response of the analog filters based on current analog control properties.
         * Draws the response on the #filterView canvas.
         */
        // global for it to not reset on each call
        let visState = 0;

        /*
         * syncMethod:
         * 0 = Rising Zero Crossing
         * 1 = Falling Zero Crossing
         * 2 = Any Zero Crossing
         * 3 = Positive Peak
         * 4 = Negative Trough
         * 5 = Steepest Rising Edge
         * 6 = Steepest Falling Edge
         * 7 = RMS Trigger
         * 8 = Hysteresis Trigger
         * 9 = Correlation Sync
         */

        syncMethod = 7

        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        canvas.addEventListener('click', function () {
            visState = (visState + 1) % 4;
        });

        function visualize(analyserL, analyserR, dataArrayL, dataArrayR) {
            const bufferLength = analyserL.frequencyBinCount;

            // Global visualization state:
            // 0 = Linear Spectrum
            // 1 = Log Spectrum
            // 2 = Scope
            // 3 = Mixed (Log + Scope)

            // Toggle on click

            function draw() {
                const width = canvas.width;
                const height = canvas.height;

                // Pull FFT + Time-domain data
                analyserL.getByteFrequencyData(dataArrayL);
                analyserR.getByteFrequencyData(dataArrayR);

                const timeDataL = new Uint8Array(analyserL.fftSize);
                const timeDataR = new Uint8Array(analyserR.fftSize);
                analyserL.getByteTimeDomainData(timeDataL);
                analyserR.getByteTimeDomainData(timeDataR);

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                switch (visState) {
                    case 0: // Linear Spectrum
                        drawSpectrumLinear(dataArrayL);
                        break;

                    case 1: // Log Spectrum
                        drawSpectrumLog(dataArrayL);
                        break;

                    case 2: // Scope
                        drawScope(timeDataL, timeDataR, 1.0);
                        break;

                    case 3: // Mixed
                        ctx.globalAlpha = 0.25;
                        drawSpectrumLog(dataArrayL);
                        ctx.globalAlpha = 1.0;
                        drawScope(timeDataL, timeDataR, 1.0);
                        break;
                }

                requestAnimationFrame(draw);
            }

            function drawSpectrumLinear(dataArray) {
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] * 1.56;
                    const barH = barHeight * 1.26 / 2;
                    const B255 = (Math.min(barH, 255) / 255) ** 1.5 * 255;
                    ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }

            function drawSpectrumLog(dataArray) {
                const func = Math.log;
                const logMin = 1;
                const logMax = func(bufferLength + 1);
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    const x = (func(i + logMin) / logMax) * canvas.width;
                    const nextX = (func(i + 1 + logMin) / logMax) * canvas.width;
                    const barWidthLog = nextX - x + 1;
                    const barH = barHeight * 1.26 / 2;
                    const B255 = (Math.min(barH, 255) / 255) ** 1.5 * 255;
                    ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidthLog, barHeight);
                }
            }

            function drawScope(timeDataL, timeDataR, alpha = 1.0) {
                ctx.globalAlpha = alpha;
                ctx.lineWidth = 1.5;
                
                // All sync methods
                function findRisingZeroCrossing(d){for(let i=0;i<d.length-1;i++){if(d[i]<128&&d[i+1]>=128)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findFallingZeroCrossing(d){for(let i=0;i<d.length-1;i++){if(d[i]>128&&d[i+1]<=128)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findAnyZeroCrossing(d){for(let i=0;i<d.length-1;i++){if((d[i]<128&&d[i+1]>=128)||(d[i]>128&&d[i+1]<=128))return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findPositivePeak(d){let m=-1,i0=0,c=false;for(let i=0;i<d.length;i++){if(d[i]>m){m=d[i];i0=i;c=true}}return {index:i0,canSync:c&&m>140}}
                function findNegativeTrough(d){let m=256,i0=0,c=false;for(let i=0;i<d.length;i++){if(d[i]<m){m=d[i];i0=i;c=true}}return {index:i0,canSync:c&&m<116}}
                function findSteepestRisingEdge(d){let m=0,i0=0,c=false;for(let i=0;i<d.length-1;i++){let s=d[i+1]-d[i];if(s>m){m=s;i0=i;c=true}}return {index:i0,canSync:c&&m>10}}
                function findSteepestFallingEdge(d){let m=0,i0=0,c=false;for(let i=0;i<d.length-1;i++){let s=d[i]-d[i+1];if(s>m){m=s;i0=i;c=true}}return {index:i0,canSync:c&&m>10}}
                function findRMSTrigger(d,w=32,t=20){for(let i=0;i<d.length-w;i++){let r=0;for(let j=0;j<w;j++){let s=d[i+j]-128;r+=s*s}r=Math.sqrt(r/w);if(r>t)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findCorrelationSync(d,p,l=64){if(!p||p.length<l)return {index:0,canSync:false};let bc=-1,bi=0;for(let i=0;i<=d.length-l;i++){let c=0,na=0,nb=0;for(let j=0;j<l;j++){const a=d[i+j]-128,b=p[j]-128;c+=a*b;na+=a*a;nb+=b*b}if(na>0&&nb>0){c/=Math.sqrt(na*nb);if(c>bc){bc=c;bi=i}}}return {index:bi,canSync:bc>0.7}}
                function findHysteresisTrigger(d,low=120,high=136){let trig=false;for(let i=0;i<d.length-1;i++){if(!trig&&d[i]<low)trig=true;else if(trig&&d[i]>high)return {index:i,canSync:true}}return {index:0,canSync:false}}
                
                function getSyncPoint(timeData, method = 'risingZero', previousPattern = null) {
                    switch (method) {
                        case 0: return findRisingZeroCrossing(timeData);
                        case 1: return findFallingZeroCrossing(timeData);
                        case 2: return findAnyZeroCrossing(timeData);
                        case 3: return findPositivePeak(timeData);
                        case 4: return findNegativeTrough(timeData);
                        case 5: return findSteepestRisingEdge(timeData);
                        case 6: return findSteepestFallingEdge(timeData);
                        case 7: return findRMSTrigger(timeData);
                        case 8: return findHysteresisTrigger(timeData);
                        case 9: return findCorrelationSync(timeData, previousPattern);
                        default: return findRisingZeroCrossing(timeData);
                    }
                }
                
                // Find sync point for each channel separately using selected method
                const syncResultL = getSyncPoint(timeDataL, syncMethod);
                const syncResultR = getSyncPoint(timeDataR, syncMethod);
                const startIndexL = syncResultL.index;
                const startIndexR = syncResultR.index;
                const canSyncL = syncResultL.canSync;
                const canSyncR = syncResultR.canSync;
                
                // Enable additive blending so red+blue = magenta
                ctx.globalCompositeOperation = "lighter";
                
                // Left channel (red) - synchronized to its own trigger point
                ctx.strokeStyle = "rgb(255, 0, 0)";
                ctx.beginPath();
                for (let i = 0; i < timeDataL.length; i++) {
                    const index = canSyncL ? (startIndexL + i) % timeDataL.length : i;
                    const x = (i / timeDataL.length) * canvas.width;
                    // Convert from 0-255 range to centered waveform
                    const y = ((255 - timeDataL[index]) / 255.0) * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Right channel (blue) - synchronized to its own trigger point
                ctx.strokeStyle = "rgb(0, 0, 255)";
                ctx.beginPath();
                for (let i = 0; i < timeDataR.length; i++) {
                    const index = canSyncR ? (startIndexR + i) % timeDataR.length : i;
                    const x = (i / timeDataR.length) * canvas.width;
                    // Convert from 0-255 range to centered waveform
                    const y = ((255 - timeDataR[index]) / 255.0) * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Restore normal drawing mode for next layers
                ctx.globalCompositeOperation = "source-over";
                
                // Draw sync indicators and method label
                ctx.beginPath();
                ctx.arc(10, 10, 5, 0, 2 * Math.PI);
                ctx.fillStyle = canSyncL ? 'red' : 'gray';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(25, 10, 5, 0, 2 * Math.PI);
                ctx.fillStyle = canSyncR ? 'blue' : 'gray';
                ctx.fill();
                
                // Display current sync method
                ctx.fillStyle = 'white';
                ctx.font = '12px monospace';
                //ctx.fillText(`Sync: ${syncMethod}`, 45, 15);
            }

            draw();
        }

        document.getElementById('playButton').addEventListener('click', function () {
            if (processedBuffer) {
                playbackSource = audioContext.createBufferSource();
                playbackSource.buffer = processedBuffer; // Play the processed buffer stored in RAM

                // --- Create split for stereo channels ---
                const splitter = audioContext.createChannelSplitter(2);

                // --- Create analysers for L & R ---
                const analyserL = audioContext.createAnalyser();
                const analyserR = audioContext.createAnalyser();
                analyserL.fftSize = 2048;
                analyserR.fftSize = 2048;

                const dataArrayL = new Uint8Array(analyserL.frequencyBinCount);
                const dataArrayR = new Uint8Array(analyserR.frequencyBinCount);

                // --- Create merger to keep stereo ---
                const merger = audioContext.createChannelMerger(2);

                // --- Routing ---
                playbackSource.connect(splitter);

                splitter.connect(analyserL, 0); // Left channel
                splitter.connect(analyserR, 1); // Right channel

                // Send to merger to preserve stereo
                analyserL.connect(merger, 0, 0); // analyserL  Left
                analyserR.connect(merger, 0, 1); // analyserR  Right

                // Connect to speakers
                merger.connect(audioContext.destination);

                // --- Visualize both channels ---
                visualize(analyserL, analyserR, dataArrayL, dataArrayR);

                // --- Start playback ---
                playbackSource.start();
            }
        });


        document.getElementById('pauseButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('stopButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('downloadButton').addEventListener('click', function() {
            const carrierInput = document.getElementById('carrierInput');
            const audioInput = document.getElementById('audioInput');
            let carrierName = 'No name';
            let modularName = 'No name';

            if (carrierInput.files.length > 0) {
                carrierName = carrierInput.files[0].name.split('.').slice(0, -1).join('.');
            }
            if (audioInput.files.length > 0) {
                modularName = audioInput.files[0].name.split('.').slice(0, -1).join('.');
            }

            if (processedBuffer) {
                const wavBuffer = bufferToWav(processedBuffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${carrierName} (${modularName}).wav`;
                a.click();
                URL.revokeObjectURL(url);
            }
        });

        function bufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = loadedCarrierBuffer.length * numOfChan * 2 + 44; // Use carrier buffer length
            const bufferArray = new ArrayBuffer(length);
            const view = new DataView(bufferArray);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length

            // Write interleaved audio data
            let offset = 44;
            for (let i = 0; i < loadedCarrierBuffer.length; i++) { // Use carrier buffer length
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
