<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="./IconCFFTV.png">
    <title>Crappy DX3 Vocoder</title>
    <style>
        /* Base text styling */
        label, span, p, h1, h2, h3, h4, h5, h6 {
            color: #ddd;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Bold or strong text */
        strong, b {
            color: #fff;
        }

        /* Headings */
        h1, h2, h3 {
            color: #fff;
            margin: 0.5em 0;
            font-weight: bold;
        }

        /* Subtle/inactive or muted text */
        .text-muted {
            color: #888;
            font-size: 0.9em;
            font-style: italic;
        }

        /* Informational (e.g. helper text) */
        .text-info {
            color: #5ac8fa;
            font-size: 0.95em;
        }

        /* For sliders and live values */
        .value-label {
            margin-left: 6px;
            color: #aaa;
            font-family: monospace;
            font-size: 0.95em;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-height: 100vh;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Header Section */
        .header-section {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            /*backdrop-filter: blur(10px);*/
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #Title {
            font-size: clamp(24px, 5vw, 48px);
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #5ac8fa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        #Title:hover {
            transform: scale(1.05);
        }

        #what_is {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .author {
            color: #aaa;
            font-size: 12px;
        }

        #randomQuote {
            margin-top: 15px;
            padding: 10px;
            background: rgba(90, 200, 250, 0.1);
            border-radius: 8px;
            font-style: italic;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #randomQuote:hover {
            background: rgba(90, 200, 250, 0.2);
        }

        /* Canvas and Visualizer */
        .visualizer-section {
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #visualizer, #filterView {
            max-width: 100%;
            height: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Controls Layout */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            /*backdrop-filter: blur(5px);*/
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(90, 200, 250, 0.3);
            font-size: 18px;
        }

        /* Form Controls */
        .form-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .form-group:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .form-group label {
            min-width: 120px;
            flex-shrink: 0;
            font-weight: 500;
        }

        .form-control {
            flex: 1;
            min-width: 100px;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* File Inputs */
        input[type="file"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
            font-size: 14px;
        }

        input[type="file"]:hover {
            border-color: #5ac8fa;
            background: rgba(90, 200, 250, 0.1);
        }

        input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            margin-right: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        input[type="file"]::file-selector-button:hover {
            background: linear-gradient(135deg, #007acc 0%, #005999 100%);
            transform: scale(1.05);
        }

        /* Select Dropdowns */
        select {
            background: rgba(68, 68, 68, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 120px;
        }

        select:hover, select:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Range Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            min-width: 120px;
            height: 6px;
            background: rgba(68, 68, 68, 0.8);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 15px rgba(90, 200, 250, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(90, 200, 250, 0.3);
        }

        /* Number Inputs */
        input[type="number"] {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }

        input[type="number"]:focus {
            border-color: #5ac8fa;
            outline: none;
        }

        /* Text Inputs and Textareas */
        input[type="text"], textarea {
            background: rgba(34, 34, 34, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            width: 100%;
            resize: vertical;
            min-height: 60px;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #5ac8fa;
            box-shadow: 0 0 10px rgba(90, 200, 250, 0.2);
        }

        /* Checkboxes */
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #5ac8fa;
        }

        /* Keyboard Section */
        .keyboard-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .keyboard-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 2px;
        }

        .key-button {
            position: relative;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            text-align: center;
            padding-top: 30px;
        }

        .key-button.white {
            background: #fff;
            color: #000;
            width: 40px;
            height: 120px;
        }

        .key-button.black {
            background: #222;
            color: #ccc;
            width: 25px;
            height: 80px;
            z-index: 2;
            margin-left: -12px;
            margin-right: -12px;
        }

        .key-button:hover {
            transform: translateY(-2px);
        }

        .key-button.active {
            background: #0055ff !important;
            color: #fff !important;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-top: 20px;
        }

        .action-buttons button {
            min-width: 120px;
        }

        /* Drag and Drop */
        .drag-over {
            border-color: #5ac8fa !important;
            background: rgba(90, 200, 250, 0.1) !important;
            transform: scale(1.02);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .form-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .form-group label {
                min-width: unset;
                width: 100%;
                margin-bottom: 5px;
            }

            .form-control {
                width: 100%;
            }

            input[type="range"] {
                min-width: unset;
            }

            .action-buttons {
                flex-direction: column;
            }

            .action-buttons button {
                min-width: unset;
                width: 100%;
            }

            #visualizer {
                width: 100%;
                height: 200px;
            }

            .keyboard-row {
                overflow-x: auto;
                padding-bottom: 10px;
            }

            .key-button.white {
                width: 35px;
                height: 100px;
            }

            .key-button.black {
                width: 20px;
                height: 65px;
                margin-left: -10px;
                margin-right: -10px;
            }
        }

        @media (max-width: 480px) {
            .control-panel {
                padding: 15px;
            }

            #Title {
                font-size: 24px;
            }

            button {
                padding: 12px 16px;
                font-size: 16px;
            }

            .form-group {
                margin-bottom: 20px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1200px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .main-container {
                padding: 20px;
            }
        }

        /* Dark mode enhancements */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            }
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-panel {
            animation: fadeIn 0.6s ease-out;
        }

        /* Utility classes */
        .hidden { display: none !important; }
        .visible { display: block !important; }
        
        /* Separator */
        .separator {
            display: inline-block;
            margin: 0 10px;
            color: #666;
        }

        /* Value display */
        .auto-value-span {
            color: #5ac8fa;
            font-family: monospace;
            font-weight: 500;
        }

        /* Corner GitHub link */
        .github-corner {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #444 0%, #666 100%);
            color: #fff;
            padding: 12px 16px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .github-corner:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #666 0%, #888 100%);
        }

        @media (max-width: 768px) {
            .github-corner {
                bottom: 10px;
                right: 10px;
                padding: 10px 12px;
                font-size: 12px;
            }
        }

        /* New styles for the thinner synth keyboard */
        #synthKeyboardContainer .key-button.white {
            width: 15px; /* Thinner width for white keys */
            height: 80px; /* Height remains the same */
            padding-top: 15px; /* Padding for text */
            font-size: 8px; /* Smaller font size */
        }

        #synthKeyboardContainer .key-button.black {
            width: 10px; /* Thinner width for black keys */
            height: 40px; /* Height remains the same */
            font-size: 8px; /* Smaller font size */
        }

        /* OSC Tabs System */
        .osc-tabs {
            margin: 15px 0;
        }

        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab-button {
            background: rgba(68, 68, 68, 0.8);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 60px;
            text-align: center;
        }

        .tab-button:hover {
            background: rgba(90, 200, 250, 0.2);
            border-color: #5ac8fa;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #5ac8fa 0%, #007acc 100%);
            border-color: #5ac8fa;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .tab-buttons {
                flex-direction: column;
            }

            .tab-button {
                min-width: unset;
                width: 100%;
            }

            .tab-content {
                padding: 0 10px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header Section -->
        <div class="header-section">
            <div id="Title">Crappy 4ormulator clone</div>
            <div id="what_is">an 4ormulator clone</div>
            <div class="author">by DX3050/D3nschot</div>
            <div id="randomQuote" style="display: none;">FFT? I only know it as Functional Family Therapy</div>
        </div>

        <!-- Visualizer Section -->
        <div class="visualizer-section">
            <canvas id="visualizer" width="800" height="400"></canvas>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button id="playButton" onclick="playAudio()" disabled>Play</button>
            <button id="pauseButton" onclick="pauseAudio()" disabled>Pause</button>
            <button id="stopButton" onclick="stopAudio()" disabled>Stop</button>
            <button id="downloadButton" disabled>Download</button>
            <button id="reprocessButton" disabled>Reprocess</button>
            <button id="helpButton">Help</button>
        </div>

        <!-- Controls Grid -->
        <div class="controls-grid">
            <!-- Mode Control Panel -->
            <div class="control-panel">
                <h3>Mode & Files</h3>
                
                <div class="form-group">
                    <button id="changeBackButton">Change to FFT Mode</button>
                    <button id="ViewProperties">View Properties</button>
                </div>

                <!--it's swaped, i ain't gonna fix it-->
                <div class="form-group">
                    <label for="carrierInput">Audio Input:</label>
                    <input type="file" id="carrierInput" class="form-control" draggable="true">
                </div>

                <div class="form-group">
                    <label for="audioInput">Carrier Input:</label>
                    <input type="file" id="audioInput" class="form-control" draggable="true">
                </div>
            </div>

            <!--synth-->
            <div class="control-panel">
                <h3>Synth</h3>
                
                <div class="form-group">
                    <label for="enableSynth">Enable Synth:</label>
                    <input type="checkbox" id="enableSynth">
                </div>

                <div class="form-group">
                    <label for="oscCount">OSC Count:</label>
                    <select id="oscCount" class="form-control">
                        <option value="1">1 OSC</option>
                        <option value="2">2 OSC</option>
                        <option value="3">3 OSC</option>
                        <option value="4">4 OSC</option>
                        <option value="5">5 OSC</option>
                        <option value="6">6 OSC</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="SRfix">SR fix</label>
                    <input type="range" id="SRfix" min="0" max="2" step="0.001" value="1">
                </div>

                <!-- OSC Tabs -->
                <div class="osc-tabs">
                    <div class="tab-buttons">
                        <button class="tab-button active" data-tab="global">Global</button>
                        <button class="tab-button" data-tab="osc1">OSC 1</button>
                        <button class="tab-button" data-tab="osc2">OSC 2</button>
                        <button class="tab-button" data-tab="osc3">OSC 3</button>
                        <button class="tab-button" data-tab="osc4">OSC 4</button>
                        <button class="tab-button" data-tab="osc5">OSC 5</button>
                        <button class="tab-button" data-tab="osc6">OSC 6</button>
                    </div>

                    <!-- Global Settings Tab -->
                    <div class="tab-content active" id="global-tab">
                        <div class="form-group">
                            <label for="synthVolume">Master Volume:</label>
                            <input type="range" id="synthVolume" min="0" max="2" step="0.01" value="0.5">
                        </div>

                        <div class="form-group">
                            <label for="synthOctave">Master Octave Shift:</label>
                            <input type="range" id="synthOctave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="synthDetune">Master Detune Amount:</label>
                            <input type="range" id="synthDetune" min="0" max="1" step="0.01" value="0.02">
                        </div>

                        <div class="form-group">
                            <label for="synthCents">Master Cents (Fine Pitch):</label>
                            <input type="range" id="synthCents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="synthVoices">Voice Count:</label>
                            <input type="range" id="synthVoices" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="globalVoiceMix">Master Voice Mix:</label>
                            <select id="globalVoiceMix" class="form-control">
                                <option value="2">Root (√n) [Default]</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="globalOVDistort">Global Orange Distort</label>
                            <input type="range" id="globalOVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label>Sync & Ring Matrix:</label>
                            <div id="syncRingContainer" class="form-control" style="display:flex;flex-direction:column;gap:10px;">
                                <div>
                                    <strong>Sync Matrix (source → target)</strong>
                                    <div id="syncMatrixContainer" style="overflow:auto;">
                                        <!-- sync matrix will be generated here -->
                                    </div>
                                </div>
                                <div>
                                    <strong>Ring Matrix (source → target)</strong>
                                    <div id="ringMatrixContainer" style="overflow:auto;">
                                        <!-- ring matrix will be generated here -->
                                    </div>
                                </div>
                                <div>
                                    <strong>Sync Status:</strong>
                                    <div id="syncStatus" style="font-family: monospace; font-size: 12px; color: #5ac8fa; min-height: 20px;">
                                        Ready
                                    </div>
                                </div>
                                <div>
                                    <strong>Voice Count Summary:</strong>
                                    <div id="voiceCountSummary" style="font-family: monospace; font-size: 12px; color: #5ac8fa; min-height: 60px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; margin-top: 5px;">
                                        <!-- Voice count summary will be generated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Individual OSC Tabs -->
                    <div class="tab-content" id="osc1-tab">
                        <div class="form-group">
                            <label for="osc1Waveform">Waveform:</label>
                            <select id="osc1Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc1LFORate">OSC 1 LFO Rate:</label>
                            <input type="range" id="osc1LFORate" min="0" max="3.0" step="0.01" value="1.60">
                        </div>
                        <div class="form-group">
                            <label for="osc1LFOAmount">OSC 1 LFO Amount:</label>
                            <input type="range" id="osc1LFOAmount" min="-1" max="1" step="0.001" value="0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc1LFOEnable">Enable OSC 1 LFO:</label>
                            <input type="checkbox" id="osc1LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc1Volume">OSC 1 Volume:</label>
                            <input type="range" id="osc1Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc1Octave">OSC 1 Octave Shift:</label>
                            <input type="range" id="osc1Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc1Detune">OSC 1 Detune:</label>
                            <input type="range" id="osc1Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc1Cents">OSC 1 Cents (Fine Pitch):</label>
                            <input type="range" id="osc1Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc1OVDistort">OSC 1 Orange Distort</label>
                            <input type="range" id="osc1OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc1VoiceCount">OSC 1 Voice Count:</label>
                            <input type="range" id="osc1VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc1VoiceMix">OSC 1 Voice Mix:</label>
                            <select id="osc1VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc1Enabled">OSC 1 Enabled:</label>
                            <input type="checkbox" id="osc1Enabled" checked>
                        </div>
                    </div>

                    <div class="tab-content" id="osc2-tab">
                        <div class="form-group">
                            <label for="osc2Waveform">Waveform:</label>
                            <select id="osc2Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc2LFORate">OSC 2 LFO Rate:</label>
                            <input type="range" id="osc2LFORate" min="0" max="3.0" step="0.01" value="2.21">
                        </div>
                        <div class="form-group">
                            <label for="osc2LFOAmount">OSC 2 LFO Amount:</label>
                            <input type="range" id="osc2LFOAmount" min="-1" max="1" step="0.001" value="-0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc2LFOEnable">Enable OSC 2 LFO:</label>
                            <input type="checkbox" id="osc2LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc2Volume">OSC 2 Volume:</label>
                            <input type="range" id="osc2Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc2Octave">OSC 2 Octave Shift:</label>
                            <input type="range" id="osc2Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc2Detune">OSC 2 Detune:</label>
                            <input type="range" id="osc2Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc2Cents">OSC 2 Cents (Fine Pitch):</label>
                            <input type="range" id="osc2Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc2OVDistort">OSC 2 Orange Distort</label>
                            <input type="range" id="osc2OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc2VoiceCount">OSC 2 Voice Count:</label>
                            <input type="range" id="osc2VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc2VoiceMix">OSC 2 Voice Mix:</label>
                            <select id="osc2VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc2Enabled">OSC 2 Enabled:</label>
                            <input type="checkbox" id="osc2Enabled" checked>
                        </div>
                    </div>

                    <div class="tab-content" id="osc3-tab">
                        <div class="form-group">
                            <label for="osc3Waveform">Waveform:</label>
                            <select id="osc3Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc3LFORate">OSC 3 LFO Rate:</label>
                            <input type="range" id="osc3LFORate" min="0" max="3.0" step="0.01" value="1.60">
                        </div>
                        <div class="form-group">
                            <label for="osc3LFOAmount">OSC 3 LFO Amount:</label>
                            <input type="range" id="osc3LFOAmount" min="-1" max="1" step="0.001" value="0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc3LFOEnable">Enable OSC 3 LFO:</label>
                            <input type="checkbox" id="osc3LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc3Volume">OSC 3 Volume:</label>
                            <input type="range" id="osc3Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc3Octave">OSC 3 Octave Shift:</label>
                            <input type="range" id="osc3Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc3Detune">OSC 3 Detune:</label>
                            <input type="range" id="osc3Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc3Cents">OSC 3 Cents (Fine Pitch):</label>
                            <input type="range" id="osc3Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc3OVDistort">OSC 3 Orange Distort</label>
                            <input type="range" id="osc3OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc3VoiceCount">OSC 3 Voice Count:</label>
                            <input type="range" id="osc3VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc3VoiceMix">OSC 3 Voice Mix:</label>
                            <select id="osc3VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc3Enabled">OSC 3 Enabled:</label>
                            <input type="checkbox" id="osc3Enabled" checked>
                        </div>
                    </div>

                    <div class="tab-content" id="osc4-tab">
                        <div class="form-group">
                            <label for="osc4Waveform">Waveform:</label>
                            <select id="osc4Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc4LFORate">OSC 4 LFO Rate:</label>
                            <input type="range" id="osc4LFORate" min="0" max="3.0" step="0.01" value="2.21">
                        </div>
                        <div class="form-group">
                            <label for="osc4LFOAmount">OSC 4 LFO Amount:</label>
                            <input type="range" id="osc4LFOAmount" min="-1" max="1" step="0.001" value="-0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc4LFOEnable">Enable OSC 4 LFO:</label>
                            <input type="checkbox" id="osc4LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc4Volume">OSC 4 Volume:</label>
                            <input type="range" id="osc4Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc4Octave">OSC 4 Octave Shift:</label>
                            <input type="range" id="osc4Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc4Detune">OSC 4 Detune:</label>
                            <input type="range" id="osc4Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc4Cents">OSC 4 Cents (Fine Pitch):</label>
                            <input type="range" id="osc4Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc4OVDistort">OSC 4 Orange Distort</label>
                            <input type="range" id="osc4OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc4VoiceCount">OSC 4 Voice Count:</label>
                            <input type="range" id="osc4VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc4VoiceMix">OSC 4 Voice Mix:</label>
                            <select id="osc4VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc4Enabled">OSC 4 Enabled:</label>
                            <input type="checkbox" id="osc4Enabled" checked>
                        </div>
                    </div>

                    <div class="tab-content" id="osc5-tab">
                        <div class="form-group">
                            <label for="osc5Waveform">Waveform:</label>
                            <select id="osc5Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc5LFORate">OSC 5 LFO Rate:</label>
                            <input type="range" id="osc5LFORate" min="0" max="3.0" step="0.01" value="1.60">
                        </div>
                        <div class="form-group">
                            <label for="osc5LFOAmount">OSC 5 LFO Amount:</label>
                            <input type="range" id="osc5LFOAmount" min="-1" max="1" step="0.001" value="0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc5LFOEnable">Enable OSC 5 LFO:</label>
                            <input type="checkbox" id="osc5LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc5Volume">OSC 5 Volume:</label>
                            <input type="range" id="osc5Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc5Octave">OSC 5 Octave Shift:</label>
                            <input type="range" id="osc5Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc5Detune">OSC 5 Detune:</label>
                            <input type="range" id="osc5Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc5Cents">OSC 5 Cents (Fine Pitch):</label>
                            <input type="range" id="osc5Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc5OVDistort">OSC 5 Orange Distort</label>
                            <input type="range" id="osc5OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc5VoiceCount">OSC 5 Voice Count:</label>
                            <input type="range" id="osc5VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc5VoiceMix">OSC 5 Voice Mix:</label>
                            <select id="osc5VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc5Enabled">OSC 5 Enabled:</label>
                            <input type="checkbox" id="osc5Enabled" checked>
                        </div>
                    </div>

                    <div class="tab-content" id="osc6-tab">
                        <div class="form-group">
                            <label for="osc6Waveform">Waveform:</label>
                            <select id="osc6Waveform" class="form-control">
                                <option value="0">sine</option>
                                <option value="1">triangle</option>
                                <option value="2" selected>sawtooth</option>
                                <option value="3">square</option>
                                <option value="4">PWM</option>
                                <option value="5">Brigth noise</option>
                                <option value="6">OV Duo tri</option>
                                <option value="7">OV indigo</option>
                                <option value="20">OV vox</option>
                                <option value="11">OV strings</option>
                                <option value="21">OV airy</option>
                                <option value="12">OV unisono</option>
                                <option value="22">OV voxpad</option>
                                <option value="13">OV strings + unisono</option>
                                <option value="23">OV pulse</option>
                                <option vaule="24">OV damped saw</option> <!--there are not the same as damped saw-->
                                <option value="25">OV damped square</option>
                                <option value="26">OV damped triangle</option>
                                <option value="27">OV curvation</option>
                                <option value="28">OV circular</option>
                                <option value="29">OV distored saw</option>
                                <option value="8">TriSaw</option>
                                <option value="14">VX Power (Not Perfect)</option>
                                <option value="15">damped saw</option>
                                <option value="34">distorted saw</option>
                                <option value="16">VX Phased</option>
                                <option value="17">VX chip (Arp)</option>
                                <option value="18">VX Robotsaw</option>
                                <option value="19">ST chip (Arp)</option>
                                <option value="30">this.thing</option>
                                <option value="31">and</option>
                                <option value="32">xor</option>
                                <option value="33">or</option>
                                <option value="9">Noise</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc6LFORate">OSC 6 LFO Rate:</label>
                            <input type="range" id="osc6LFORate" min="0" max="3.0" step="0.01" value="2.21">
                        </div>
                        <div class="form-group">
                            <label for="osc6LFOAmount">OSC 6 LFO Amount:</label>
                            <input type="range" id="osc6LFOAmount" min="-1" max="1" step="0.001" value="-0.003">
                        </div>
                        <div class="form-group">
                            <label for="osc6LFOEnable">Enable OSC 6 LFO:</label>
                            <input type="checkbox" id="osc6LFOEnable">
                        </div>
                        <div class="form-group">
                            <label for="osc6Volume">OSC 6 Volume:</label>
                            <input type="range" id="osc6Volume" min="0" max="2" step="0.01" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc6Octave">OSC 6 Octave Shift:</label>
                            <input type="range" id="osc6Octave" min="-3" max="3" step="1" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc6Detune">OSC 6 Detune:</label>
                            <input type="range" id="osc6Detune" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc6Cents">OSC 6 Cents (Fine Pitch):</label>
                            <input type="range" id="osc6Cents" min="-12000" max="12000" step="0.001" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc6OVDistort">OSC 6 Orange Distort</label>
                            <input type="range" id="osc6OVDistort" min="0" max="1" step="0.01" value="0">
                        </div>

                        <div class="form-group">
                            <label for="osc6VoiceCount">OSC 6 Voice Count:</label>
                            <input type="range" id="osc6VoiceCount" min="1" max="32" step="1" value="1">
                        </div>

                        <div class="form-group">
                            <label for="osc6VoiceMix">OSC 6 Voice Mix:</label>
                            <select id="osc6VoiceMix" class="form-control">
                                <option value="2">Root (√n)</option>
                                <option value="1">Linear (1/n)</option>
                                <option value="0">Flat (None)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="osc6Enabled">OSC 6 Enabled:</label>
                            <input type="checkbox" id="osc6Enabled" checked>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="SynthOnly">Synth only:</label>
                    <input type="checkbox" id="SynthOnly">
                </div>


                <label>Synth Keyboard:</label>
                <div class="keyboard-section">
                    <div class="keyboard-container" id="synthKeyboardContainer"></div>
                </div>
            </div>



                <script>
                    // Re-using the semitoneNames and heldNotes from the original script
                    const semitoneNames = [
                        { name: 'C', black: false },
                        { name: 'C#', black: true },
                        { name: 'D', black: false },
                        { name: 'D#', black: true },
                        { name: 'E', black: false },
                        { name: 'F', black: false },
                        { name: 'F#', black: true },
                        { name: 'G', black: false },
                        { name: 'G#', black: true },
                        { name: 'A', black: false },
                        { name: 'A#', black: true },
                        { name: 'B', black: false },
                    ];

                    const synthHeldNotes1 = new Set(); // Use a separate set for the first synth notes
                    const synthKeyboardContainer1 = document.getElementById("synthKeyboardContainer");
                    const synthTotalKeys = 72; // Total number of keys
                    const synthBaseNote = 48; // Starting from C3 (MIDI note 48)

                                        // Render the synth keyboard
                    function renderSynthKeyboard(container, heldNotes) {
                        container.innerHTML = '';
                        const synthTotalKeys = 72;
                        const synthBaseNote = 36; // C2 instead of C3 for more range
                        const synthKeysPerRow = 24;
                        let currentRowDiv;
                        for (let k = 0; k < synthTotalKeys; k++) {
                            if (k % synthKeysPerRow === 0) {
                                currentRowDiv = document.createElement("div");
                                currentRowDiv.className = "keyboard-row";
                                container.appendChild(currentRowDiv);
                            }
                            const midiNote = synthBaseNote + k;
                            const noteIndexInOctave = k % 12;
                            const name = semitoneNames[noteIndexInOctave];
                            const isBlack = name.black;
                            const btn = document.createElement("button");
                            btn.className = `key-button ${isBlack ? 'black' : 'white'}`;
                            btn.dataset.note = midiNote;
                            btn.textContent = name.name;
                            if (isBlack) {
                                btn.style.marginLeft = "-25px";
                                btn.style.marginRight = "-25px";
                            } else {
                                btn.style.marginLeft = "0";
                                btn.style.marginRight = "0";
                            }
                            if (heldNotes.has(midiNote)) {
                                btn.classList.add('active');
                            }
                            btn.addEventListener("click", () => {
                                if (heldNotes.has(midiNote)) {
                                    heldNotes.delete(midiNote);
                                    btn.classList.remove('active');
                                } else {
                                    heldNotes.add(midiNote);
                                    btn.classList.add('active');
                                }
                                // Save synth keys in URL
                                updateSynthKeysURL();
                            });
                            currentRowDiv.appendChild(btn);
                        }
                    }
                    // Save synth keys in URL
                    function updateSynthKeysURL() {
                        const params = new URLSearchParams(window.location.search);
                        params.set('synthKeys', Array.from(synthHeldNotes1).join(','));
                        window.history.replaceState({}, '', `${window.location.pathname}?${params}`);
                    }
                    // Restore synth keys from URL
                    function restoreSynthKeysFromURL() {
                        const params = new URLSearchParams(window.location.search);
                        const keys = params.get('synthKeys');
                        if (keys) {
                            synthHeldNotes1.clear();
                            keys.split(',').forEach(k => {
                                if (k !== '') synthHeldNotes1.add(Number(k));
                            });
                        }
                    }

                    // Call the render function for the keyboard when the DOM is loaded
                    document.addEventListener('DOMContentLoaded', () => {
                        restoreSynthKeysFromURL();
                        renderSynthKeyboard(synthKeyboardContainer1, synthHeldNotes1);
                        updateSynthKeysURL(); // Sync URL on load
                        // Add event listener for window resize to re-render if layout changes
                        window.addEventListener('resize', () => {
                            renderSynthKeyboard(synthKeyboardContainer1, synthHeldNotes1);
                        });
                    });
                </script>


            </div>

            <!-- Basic Controls Panel -->
            <div class="control-panel">
                <h3>Basic Controls</h3>
                
                <div class="form-group">
                    <label for="decayType">Decay Type:</label>
                    <select id="decayType" class="form-control">
                        <option value="1">RMS</option>
                        <option value="2">Peak</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="release">Release:</label>
                    <input type="range" id="release" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="pitch">Pitch:</label>
                    <input type="range" id="pitch" value="0" min="-24" max="24" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BandShift">Shift:</label>
                    <input type="range" id="BandShift" value="0" min="-100" max="100" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FreqFlip">Flip:</label>
                    <input type="checkbox" id="FreqFlip">
                </div>

                <div class="form-group">
                    <label for="SoundGoodizer">SoundGoodizer:</label>
                    <input type="range" id="SoundGoodizer" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>
            </div>

            <!-- FFT Controls Panel -->
            <div id="FFTcontrols" class="control-panel hidden">
                <h3>FFT Vocoder Settings</h3>

                <div class="form-group">
                    <label for="FFTmode">FFT Mode:</label>
                    <select id="FFTmode" class="form-control">
                        <option value="0">OVDX</option>
                        <option value="3" selected>OVDX Fast</option>
                        <option value="1">Colorized</option>
                        <option value="2">Magix</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="BandBreak">Band Break:</label>
                    <input type="checkbox" id="BandBreak">
                </div>

                <div class="form-group">
                    <label for="BR_voc_Type">Broken vocoder:</label>
                    <select id="BR_voc_Type" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">Triangle</option>
                        <option value="5">Square</option>
                        <option value="6">Sawtooth</option>
                        <option value="11">semi-sine</option>
                        <option value="2">double sine</option>
                        <option value="7">triple sine</option>
                        <option value="8">half sine</option>
                        <option value="10">sine squared</option>
                        <option value="14">sine cubed</option>
                        <option value="3">2 sine</option>
                        <option value="4">3 sine</option>
                        <option value="9">squared sine</option>
                        <option value="12">IDK</option>
                        <option value="13">Noise</option>
                        <option value="15">sine sine</option>
                        <option value="16">harmonics sq</option>
                        <option value="17">harmonics saw</option>
                        <option value="18">Bitwise</option>
                        <option value="19">Floor</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="BR_out">Broken vocoder out:</label>
                    <select id="BR_out" class="form-control">
                        <option value="1">Both</option>
                        <option value="2">Input</option>
                        <option value="3">Carrier</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="volume">Volume:</label>
                    <input type="range" id="volume" value="1" min="0" max="2" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="clamp_output">Clamp out:</label>
                    <select id="clamp_output" class="form-control">
                        <option value="0">Off</option>
                        <option value="1">On</option>
                        <option value="2">individual</option>
                        <!--option value="4">individual (soft)</option-->
                    </select>
                </div>

                <div class="form-group">
                    <label for="threshold">Clamp Threshold:</label>
                    <input type="range" id="threshold" value="1" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="divbands">Divide bands:</label>
                    <input type="range" id="divbands" value="1" min="1" max="64" class="form-control">
                </div>

                <div class="form-group">
                    <label for="FFTsize">FFT size:</label>
                    <input type="range" id="FFTsize" value="10" min="2" max="14" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassBoost">Bass Boost:</label>
                    <input type="range" id="BassBoost" value="0" min="-4" max="4" step=".01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BassCurve">Bass Curve:</label>
                    <select id="BassCurve" class="form-control">
                        <option value="0">+1</option>
                        <option value="1">x/i</option>
                        <option value="2">quadratic</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="reverbAMT">reverb amount</lebel>
                    <input type="range" id="reverbAMT" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <lebel for="reverbSIZE">reverb size (decay)</lebel>
                    <input type="range" id="reverbSIZE" value="0" min="0" max="0.99" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="EQType">Norm EQ type:</label>
                    <select id="EQType" class="form-control">
                        <option value="0">original</option>
                        <option value="1">sin</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="steps">Steps:</label>
                    <input type="range" id="steps" value="0" min="0" max="16" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="RoundType">Round Type:</label>
                    <select id="RoundType" class="form-control">
                        <option value="0">Floor</option>
                        <option value="1">Round</option>
                        <option value="2">Ceil</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="simpleChorus">Simple Chorus:</label>
                    <select id="simpleChorus" class="form-control">
                        <option value="0">OFF</option>
                        <option value="1">sin</option>
                        <option value="2">cos</option>
                        <option value="3">asin</option>
                        <option value="4">acos</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="speedType">Speed:</label>
                    <select id="speedType" class="form-control">
                        <option value="0">Auto</option>
                        <option value="1">file length</option>
                        <option value="2">user</option>
                    </select>
                </div>

                <div class="form-group hidden">
                    <label for="userSpeed">Speed:</label>
                    <input type="range" id="userSpeed" value="1" min="0" max="100" step="0.01" class="form-control">
                </div>
            </div>

            <!-- Analog Controls Panel -->
            <div id="analogControls" class="control-panel hidden">
                <h3>Analog Vocoder Settings</h3>

                <div class="form-group">
                    <label for="AutoUpdateFilters">Auto-update Filters:</label>
                    <input type="checkbox" id="AutoUpdateFilters" checked>
                    <button id="ManualStudyFilters" class="hidden">Update Study Filters</button>
                </div>

                <div class="visualizer-section">
                    <canvas id="filterView" width="700" height="100"></canvas>
                </div>

                <div class="form-group">
                    <label for="TotalBands">Total Bands:</label>
                    <input type="range" id="TotalBands" value="40" min="1" max="1024" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance">Resonance:</label>
                    <input type="range" id="Resonance" value=".9999" min="0" max=".9999" step="0.0001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="BPwidth">Bandpass Width:</label>
                    <input type="range" id="BPwidth" value="0" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Volboost">Volume Boost:</label>
                    <input type="range" id="Volboost" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="DBperOct">dB per Octave:</label>
                    <input type="range" id="DBperOct" value="8" min="1" max="8" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Alt_BP">Alt Bandpass:</label>
                    <select id="Alt_BP" class="form-control">
                        <option value="0">Default</option>
                        <option value="1">normal</option>
                        <option value="2">weird</option>
                        <option value="3">fast</option>
                        <option value="4">3FLT</option>
                        <option value="5">ApLp</option>
                        <option value="6">True Cascade (Oversampled and slow)</option>
                        <option value="7" selected>True Cascade2 (slow)</option>
                        <option value="8">Triangle bandpass (slow?)</option>
                        <option value="9">FFT Bandpass (Oversampled and slow)</option>
                        <option value="10">True Cascade3 (Oversampled and slow)</option>
                        <option value="11">weird2 (Oversampled and slow)</option>
                        <option value="12">"filter"</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="decayByFreq">Decay by Frequency:</label>
                    <select id="decayByFreq" class="form-control">
                        <option value="0">fixed</option>
                        <option value="1">High priority</option>
                        <option value="2">Low priority</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="freqCurve">Frequency Curve:</lebel>
                    <select id="freqCurve" class="form-control">
                        <option value="0">linear</option>
                        <!--option value="1">logarithmic</option>
                        <option value="2">exponential</option-->
                        <option value="3">exponential (base2)</option>
                        <option value="4">squared</option>
                        <option value="5" selected>Audaciy aproxinarion</option>
                        <option value="6">Vocodex aproxinarion</option>
                    </select>
                </div>

                <div class="form-group">
                    <lebel for="UseResBasedOnDistance">Use Resonance Based on Distance:</lebel>
                    <input type="checkbox" id="UseResBasedOnDistance" checked>
                </div>

                <!--adds -->
                <div class="form-group">
                    <label for="addLPtoLowEnd">Add LP to Low End:</label>
                    <input type="checkbox" id="addLPtoLowEnd">
                </div>

                <div class="form-group">
                    <label for="addHPtoHighEnd">Add HP to High End:</label>
                    <input type="checkbox" id="addHPtoHighEnd">
                </div>

                <div class="form-group">
                    <i>
                        Recommended settings for <strong>Analog Mode</strong>:<br>
                        This applies primarily to the options <strong>Audacity approximation</strong> and <strong>Vocodex approximation</strong>.<br><br>

                        <strong>Audacity-like sound:</strong><br>
                        &bull; Use <strong>20 Bands</strong><br>
                        &bull; Set <strong>Filter Type</strong> to <strong>True Cascade2</strong><br>
                        &bull; Set <strong>Resonance</strong> to <strong>0.8</strong> without <strong>Use Resonance Based on Distance</strong><br>
                        &bull; Keep <strong>SoundGoodizer</strong> off<br>
                        &bull; Set <strong>dB</strong> to <strong>48 dB per octave</strong><br><br>

                        <strong>Vocodex-like sound:</strong><br>
                        &bull; Use <strong>47 Bands</strong><br>
                        &bull; Set <strong>Filter Type</strong> to <strong>True Cascade or 3</strong><br>
                        &bull; Set <strong>Resonance</strong> to <strong>0.8</strong> without <strong>Use Resonance Based on Distance</strong><br>
                        &bull; Enable <strong>SoundGoodizer</strong> at <strong>0.1-0.3</strong><br>
                        &bull; Set <strong>dB</strong> to <strong>48 dB per octave</strong>
                    </i>
                </div>
            </div>

            <!-- 4ormulator Controls Panel -->
            <div id="4ormClone" class="control-panel hidden">
                <h3>4ormulator Settings</h3>

                <div class="form-group">
                    <label for="Ag">Base frequency:</label>
                    <input type="range" id="Ag" value=".125" min="0" max="1" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Resonance4orm">Resonance:</label>
                    <input type="range" id="Resonance4orm" value="0.999" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormFilterType">Filter Type:</label>
                    <select id="4ormFilterType" class="form-control">
                        <option value="0">ApLp</option>
                        <option value="1">Lp12</option>
                        <option value="2">BP12</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="UseArrLength">Use Array Length:</label>
                    <input type="checkbox" id="UseArrLength">
                </div>

                <div class="form-group">
                    <label for="MaxHarm">Max Harmonics:</label>
                    <input type="range" id="MaxHarm" value="16" min="1" max="1000" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="4ormVolume">Volume:</label>
                    <input type="range" id="4ormVolume" value="1" min="0" max="10" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="use_gen">Use generator:</label>
                    <input type="checkbox" id="use_gen">
                </div>

                <div class="form-group">
                    <label for="gen_type">Generator (filtered):</label>
                    <select id="gen_type" class="form-control">
                        <option value="0">Input 2</option>
                        <option value="1">sine</option>
                        <option value="2">triangle</option>
                        <option value="3">sawtooth</option>
                        <option value="4">PWM</option>
                        <option value="5">Noise</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="PWMwidth">PWM width:</label>
                    <input type="range" id="PWMwidth" value="0.5" min="0" max="1" step="0.01" class="form-control">
                </div>

                <div class="form-group">
                    <label for="resonance2">Resonance 2:</label>
                    <input type="range" id="resonance2" value="0.99" min="0" max="0.999" step="0.001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="Harmonics">Offsets (Array only):</label>
                    <textarea id="Harmonics" class="form-control">[-5,2,7,10].map((i)=&gt;2**((i+3)/12)*Math.PI/128/HZ*2048*440)</textarea>
                </div>

                <!-- Harmonics Buttons -->
                <div class="keyboard-section">
                    <div id="harm">
                        <h3>Harmonics</h3>
                        <!-- This will be populated with buttons H1-H12 -->
                    </div>
                </div>

                <!-- Easy Mode Keyboard -->
                <div class="keyboard-section">
                    <div id="easyKeyboard">
                        <h3>Easy Mode Keyboard</h3>
                        <div class="keyboard-container" id="keyboardContainer">
                            <!-- Keyboard will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Some Experiments Controls Panel -->
            <div id="someExpControls" class="control-panel hidden">
                <h3>Some Experiments Settings</h3>

                <div class="form-group">
                    <label for="expMode">Experiment Mode:</label>
                    <select id="expMode" class="form-control">
                        <option value="0">Classic Filter-Bank</option>
                        <option value="1">Chaotic Drift</option>
                        <option value="2">Nonlinear Oscillator</option>
                        <option value="3">Bitwise Vocoder</option>
                        <option value="4">Bitwise Vocoder Alt</option>
                        <option value="5">Rectified Logic</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="expFF">Filter Count (ff):</label>
                    <input type="range" id="expFF" value="32" min="1" max="256" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="expRes">Resonance:</label>
                    <input type="range" id="expRes" value="0.9" min="0" max="0.9999" step="0.0001" class="form-control">
                </div>

                <div class="form-group">
                    <label for="expFreq">Frequency:</label>
                    <input type="range" id="expFreq" value="440" min="20" max="20000" step="1" class="form-control">
                </div>

                <div class="form-group">
                    <label for="expBaseFreq">Base Frequency:</label>
                    <input type="range" id="expBaseFreq" value="48000" min="8000" max="192000" step="1000" class="form-control">
                </div>

                <div class="form-group">
                    <i>
                        <strong>Experiment Modes:</strong><br>
                        &bull; <strong>Classic Filter-Bank:</strong> Standard vocoder with bandpass filters<br>
                        &bull; <strong>Chaotic Drift:</strong> Phase-based frequency modulation<br>
                        &bull; <strong>Nonlinear Oscillator:</strong> Self-modulating filters<br>
                        &bull; <strong>Bitwise Vocoder:</strong> Bit-level manipulation<br>
                        &bull; <strong>Bitwise Vocoder Alt:</strong> Alternative bitwise processing<br>
                        &bull; <strong>Rectified Logic:</strong> Rectified signal logic
                    </i>
                </div>
            </div>

            <!-- Processing Controls Panel -->
            <div class="control-panel">
                <h3>Processing</h3>
                
                <div class="form-group">
                    <label for="iterations">Iterations:</label>
                    <input type="number" id="iterations" value="1" min="1" class="form-control">
                    <small class="text-muted">It may get loud (or not, I don't recommend using this with long audio files)</small>
                </div>
            </div>
        </div>

        <!-- Help Popup -->
        <div id="helpPopup" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; display: flex; align-items: center; justify-content: center;">
            <div style="background: #333; padding: 30px; border-radius: 15px; color: #fff; max-width: 90vw; max-height: 90vh; overflow-y: auto; width: 600px;">
                <h2>Help</h2>
                <p>Welcome to the Crappy FFT Vocoder!</p>
                <p>This is a Fast Fourier Transform based vocoder that uses a lot of math to process audio files.</p>
                <p><strong>What is FFT?</strong></p>
                <p>The Fast Fourier Transform (FFT) is an algorithm that quickly converts a signal from its original time domain into a frequency domain. This allows the vocoder to analyze and manipulate the different frequency components of audio, enabling effects like filtering, modulation, and vocoding.</p>
                <p>Learn more about the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank" rel="noopener noreferrer" style="color:#4af;">Fast Fourier Transform (FFT)</a> on Wikipedia.</p>
                <p>This is why it's taking so long to process</p>
                <p>Fun fact: dividing the FFT index by 2 will multiply the pitch by 2, multiplying it will do the opposite</p>
                <p>Here are some instructions and information to get you started:</p>
                
                <h3>Basic Controls:</h3>
                <ul>
                    <li><strong>Decay Type:</strong> Choose between RMS and Peak for the decay type.</li>
                    <li><strong>Release:</strong> Adjust the release time for the vocoder (0 is no release and 1 is max release).</li>
                    <li><strong>Pitch:</strong> Adjust the pitch of the vocoded audio (input only).</li>
                    <li><strong>Shift:</strong> Shifts the FFT bands of the vocoded audio (input only)</li>
                </ul>

                <h3>FFT Vocoder Mode:</h3>
                <ul>
                    <li><strong>Band Break:</strong> This shifts the bands a couple of times</li>
                    <li><strong>Flip:</strong> Self explanatory, it flips the bands</li>
                    <li><strong>Broken Vocoder Type:</strong> Select the type of broken vocoder effect.</li>
                    <li><strong>Volume:</strong> Adjust the volume of the output audio.</li>
                    <li><strong>FFT Size:</strong> Adjust the size of the FFT used for processing.</li>
                </ul>

                <h3>Analog Vocoder Mode:</h3>
                <ul>
                    <li><strong>Total Bands:</strong> Sets the number of filter bands (more bands = more detailed vocoding).</li>
                    <li><strong>Resonance:</strong> Controls the sharpness of the bandpass filters.</li>
                    <li><strong>Volume Boost:</strong> Increases the output volume after processing.</li>
                </ul>

                <h3>4ormulator Mode:</h3>
                <ul>
                    <li><strong>Base frequency:</strong> Sets the base frequency of Offsets.</li>
                    <li><strong>Max Harmonics:</strong> Sets the maximum amount of harmonics</li>
                    <li><strong>Offsets:</strong> Sets the offset (shift) for the filter.</li>
                </ul>

                <div style="margin-top: 20px; font-size: 12px; color: #aaa;">
                    Version 1.2<br>
                    Made by D3nschot (DX3050)
                </div>
                
                <button id="closeHelpButton" style="margin-top: 20px;">Close</button>
            </div>
        </div>
    </div>
    <!--
        sample tables
        most of these tables are taken from orange vocoder
        I love working with tables :)
    -->
    <script src="tables.js"></script>
    
    <!-- GitHub Corner Link -->
    <a href="https://github.com/D3nschot/crappy-FFT-vocoder" class="github-corner">Fork me on GitHub :)</a>

    <script>
        // Quote system
        const quotes = [
            "FFT? I only know it as Functional Family Therapy",
            "I love math -D3nschot",
            "I love math -DX3050",
            "probably gonna make Crappy Analog Voc- oh wait, I already did",
            "A fast Fourier transform (FFT) is an algorithm that computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).",
            "Don't we love how long it takes to process audio files? :D",
            "new ui? because why not?",
            "I should really stop adding features",
            "synth👍 -D3nschot",
            "synth👍 -DX3050",
        ];

        document.getElementById('Title').addEventListener('click', function() {
            const quoteEl = document.getElementById('randomQuote');
            quoteEl.style.display = 'block';
            quoteEl.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        document.getElementById('randomQuote').addEventListener('click', function() {
            this.innerText = quotes[Math.floor(Math.random() * quotes.length)];
        });

        // Handle cents sliders value display
        document.addEventListener('DOMContentLoaded', function() {
            // Individual OSC cents sliders (global doesn't need value display)
            for (let i = 1; i <= 6; i++) {
                const centsSlider = document.getElementById(`osc${i}Cents`);
                const centsValue = document.getElementById(`osc${i}CentsValue`);
            }
        });

        // Initialize quote
        document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];

        // Auto-value span system for sliders
        document.addEventListener('DOMContentLoaded', function() {
            const skipIds = ['FFTsize', 'DBperOct'];
            const offWhenZero = ['steps', 'SoundGoodizer'];

            document.querySelectorAll('input[type="range"]').forEach(slider => {
                let label = document.querySelector(`label[for="${slider.id}"]`);
                if (!label) return;

                let span = label.parentNode.querySelector(`.auto-value-span[data-for="${slider.id}"]`);
                if (!span) {
                    span = document.createElement('span');
                    span.className = 'auto-value-span value-label';
                    span.dataset.for = slider.id;
                    label.parentNode.appendChild(span);
                }

                // Add click-to-edit functionality
                if (!skipIds.includes(slider.id)) {
                    span.style.cursor = 'pointer';
                    span.title = 'Click to edit value';
                    span.addEventListener('click', function(e) {
                        if (span.querySelector('input')) return;
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.value = slider.value;
                        input.style.width = '60px';
                        input.style.fontSize = 'inherit';
                        input.style.background = 'rgba(68, 68, 68, 0.8)';
                        input.style.color = '#fff';
                        input.style.border = '1px solid #5ac8fa';
                        input.style.borderRadius = '4px';
                        input.style.padding = '2px 4px';
                        
                        span.textContent = '';
                        span.appendChild(input);
                        input.focus();
                        input.select();
                        
                        function finishEdit() {
                            let val = input.value;
                            if (slider.min !== '') val = Math.max(Number(slider.min), val);
                            if (slider.max !== '') val = Math.min(Number(slider.max), val);
                            slider.value = val;
                            slider.dispatchEvent(new Event('input'));
                            updateSpan();
                        }
                        
                        input.addEventListener('blur', finishEdit);
                        input.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') finishEdit();
                            else if (e.key === 'Escape') updateSpan();
                        });
                    });
                }

                function updateSpan() {
                    let val = slider.value;
                    if (offWhenZero.includes(slider.id) && (val === "0" || val === 0)) {
                        span.textContent = ' OFF';
                    } else {
                        if (skipIds.includes(slider.id)) {
                            switch (slider.id) {
                                case 'FFTsize':
                                    span.textContent = ' ' + (Math.pow(2, val)).toFixed(0);
                                    break;
                                case 'DBperOct':
                                    span.textContent = ' ' + val*6 + ' dB/oct';
                                    break;
                                default:
                                    span.textContent = '';
                            }
                        } else {
                            span.textContent = ' ' + val;
                        }
                    }
                }

                updateSpan();
                slider.addEventListener('input', updateSpan);
            });


        });





        // Mode switching system
        //let Vmode = 0; // Start with 4ormulator mode

        // Read Vmode from URL immediately
        const urlParams = new URLSearchParams(window.location.search);
        let Vmode = parseInt(urlParams.get("Vmode")) || 0;

        function SetUpUI() {
            const controls = ['FFTcontrols', 'analogControls', '4ormClone', 'someExpControls'];
            const configs = [
                { title: 'Crappy FFT Vocoder', whatIs: 'a Fast Fourier Transform vocoder', button: 'Change to Analog Mode', show: 0 },
                { title: 'Crappy Analog Vocoder', whatIs: 'an Analog Vocoder', button: 'Change to 4ormulator Mode', show: 1 },
                { title: 'Crappy 4ormulator clone', whatIs: 'an 4ormulator clone', button: 'Change to Some Experiments Mode', show: 2 },
                { title: 'Some Experiments', whatIs: 'experimental filter bank vocoder', button: 'Change to FFT Mode', show: 3 }
            ];

            controls.forEach(id => document.getElementById(id).classList.add('hidden'));

            const config = configs[Vmode];
            document.getElementById('Title').textContent = config.title;
            document.getElementById('what_is').textContent = config.whatIs;
            document.getElementById('changeBackButton').textContent = config.button;
            document.getElementById(controls[config.show]).classList.remove('hidden');
        }


        document.getElementById('changeBackButton').addEventListener('click', function() {
            Vmode = ((Number(Vmode) || 0) + 1) % 4;
            SetUpUI();
            
            const params = new URLSearchParams(window.location.search);
            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        });



        // Speed type visibility control
        document.getElementById('speedType').addEventListener('change', function(event) {
            const userSpeedGroup = document.querySelector('label[for="userSpeed"]').parentNode;
            if (event.target.value == '2') {
                userSpeedGroup.classList.remove('hidden');
            } else {
                userSpeedGroup.classList.add('hidden');
            }
        });



        // Auto-update filters toggle
        document.addEventListener('DOMContentLoaded', () => {
            const autoUpdateCheckbox = document.getElementById('AutoUpdateFilters');
            const manualStudyButton = document.getElementById('ManualStudyFilters');

            autoUpdateCheckbox.addEventListener('change', () => {
                if (autoUpdateCheckbox.checked) {
                    manualStudyButton.classList.add('hidden');
                } else {
                    manualStudyButton.classList.remove('hidden');
                }
            });



            manualStudyButton.addEventListener('click', () => {
                if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
            });



            ['TotalBands', 'Resonance', 'DBperOct', 'BPwidth', 'Alt_BP', 'AutoUpdateFilters'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    const handler = () => {
                        const autoUpdate = document.getElementById('AutoUpdateFilters');
                        if (!autoUpdate || autoUpdate.checked) {
                            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
                        }
                    };
                    el.addEventListener('input', handler);
                    el.addEventListener('change', handler);
                }
            });



            if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
        });



        // Harmonics textarea tab support
        document.addEventListener('DOMContentLoaded', function() {
            const harmonicsTextarea = document.getElementById('Harmonics');
            if (harmonicsTextarea) {
                harmonicsTextarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = this.selectionStart;
                        const end = this.selectionEnd;
                        this.value = this.value.substring(0, start) + '\t' + this.value.substring(end);
                        this.selectionStart = this.selectionEnd = start + 1;
                    }
                });


            }
        });



        // Harmonic buttons system
        function createHarmonicButtons() {
            const harmDiv = document.getElementById('harm');
            if (!harmDiv) return;

            // Always force harmonics to be numbers
            window.harmString = (window.harmString || []).map(h => Number(h));

            // Clear old buttons
            Array.from(harmDiv.querySelectorAll('button.harm-btn')).forEach(btn => btn.remove());

            for (let i = 1; i <= 12; i++) {
                const btn = document.createElement('button');
                btn.textContent = `H${i}`;
                btn.className = 'harm-btn';

                const harmonicNum = i;

                // Initial active state
                if (window.harmString.includes(harmonicNum)) {
                    btn.style.backgroundColor = "#0055ff";
                    btn.style.color = "#fff";
                }

                btn.addEventListener("click", () => {
                    // Normalize before check
                    window.harmString = window.harmString.map(h => Number(h));

                    const idx = window.harmString.indexOf(harmonicNum);
                    // console.log(
                    //     'Clicked:', harmonicNum,
                    //     'Harmonics:', JSON.stringify(window.harmString),
                    //     'Index:', idx
                    // );

                    if (idx !== -1) {
                        // Remove
                        window.harmString.splice(idx, 1);
                        btn.style.backgroundColor = "";
                        btn.style.color = "";
                    } else {
                        // Add
                        window.harmString.push(harmonicNum);
                        btn.style.backgroundColor = "#0055ff";
                        btn.style.color = "#fff";
                    }

                    if (typeof updateHarmonicsText === 'function') {
                        updateHarmonicsText();
                    }
                });



                harmDiv.appendChild(btn);
            }
        }



        const heldNotes = new Set();
        const keyboard = document.getElementById("easyKeyboard");
        const totalKeys = 60;
        const base = -24;

        function updateHarmonicsText() {
            const harmonicsArea = document.getElementById("Harmonics");
            if (!harmonicsArea) return;

            const arr = Array.from(heldNotes).sort((a, b) => a - b);
            const harmArr = (window.harmString || []).slice().sort((a, b) => a - b);
            const arrString = `[${arr.join(",")}]`;
            const harmString = `[${harmArr.join(",")}]`;
            const mapFunctionString = `.flatMap((i)=>{\n    f=2**((i+3)/12)*Math.PI/128/HZ*2048*440;\n    return ${harmString}.map(a=>a*f);\n})`;
            harmonicsArea.value = arrString + mapFunctionString;
        }

        function renderKeyboard() {
            keyboard.innerHTML = '';
            
            let split = keyboard.offsetWidth < 600 || window.innerWidth < 700;
            let keysPerRow = split ? 12 : 24;
            
            for (let k = 0; k < totalKeys; k++) {
                if (k % keysPerRow === 0) {
                    var rowDiv = document.createElement("div");
                    rowDiv.className = "keyboard-row";
                    keyboard.appendChild(rowDiv);
                }

                const intVal = k + base;
                const name = semitoneNames[k % 12];
                const isBlack = name.black;

                const btn = document.createElement("button");
                btn.className = `key-button ${isBlack ? 'black' : 'white'}`;
                btn.dataset.note = intVal;
                if (isBlack) {
                    btn.style.marginLeft = "-21px";
                    btn.style.marginRight = "-21px";
                } else {
                    btn.style.marginLeft = "0";
                    btn.style.marginRight = "0";
                }


                if (heldNotes.has(intVal)) {
                    btn.classList.add('active');
                }

                btn.addEventListener("click", () => {
                    if (heldNotes.has(intVal)) {
                        heldNotes.delete(intVal);
                        btn.classList.remove('active');
                    } else {
                        heldNotes.add(intVal);
                        btn.classList.add('active');
                    }
                    updateHarmonicsText();
                });



                rowDiv.appendChild(btn);
            }
        }

        
        // Drag and drop system
        let draggingInputId = null;

        ['carrierInput', 'audioInput'].forEach(id => {
            const input = document.getElementById(id);
            if (!input) return;

            input.setAttribute('draggable', 'true');

            input.addEventListener('dragstart', e => {
                draggingInputId = id;
            });



            input.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                input.classList.add('drag-over');
            });



            input.addEventListener('dragleave', e => {
                input.classList.remove('drag-over');
            });



            input.addEventListener('drop', e => {
                e.preventDefault();
                input.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    input.files = files;
                    input.dispatchEvent(new Event('change'));
                }
            });


        });



        // URL parameter management
        function updateURLParams() {
            const params = new URLSearchParams();

            document.querySelectorAll('input, select, textarea').forEach(input => {
                const id = input.id;
                if (!id || input.type === 'file') return;

                if (input.type === 'checkbox') {
                    params.set(id, input.checked ? 'true' : 'false');
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    const encoded = btoa(unescape(encodeURIComponent(input.value)));
                    params.set(id, `base64~${encoded}`);
                } else {
                    params.set(id, input.value);
                }
            });



            params.set('Vmode', Vmode);
            const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newUrl);
        }

        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);

            // Legacy key mapping: old single-synth names -> new per-OSC/master ids
            const legacyMap = {
                // Core synth params
                'synthWaveform': 'osc1Waveform',
                'synthOctave': 'synthOctave',
                'synthDetune': 'synthDetune',
                'synthVoices': 'synthVoices',

                // Old Orange Distort → New Global Orange Distort
                'OVDistort': 'globalOVDistort',

                // These did NOT exist in old UI:
                // synthCents, osc1LFORate, osc1LFOAmount, osc1LFOEnable,
                // osc1Cents, osc1OVDistort, osc1Enabled, etc.
            };

            params.forEach((value, key) => {
                // Remap legacy keys to current ids
                if (legacyMap[key]) {
                    key = legacyMap[key];
                }
                if (key === 'Vmode') {
                    window.Vmode = parseInt(value) || 0;
                    return;
                }

                const input = document.getElementById(key);
                if (!input) return;

                if (input.type === 'checkbox') {
                    input.checked = value === 'true';
                } else if (input.type === 'text' || input.tagName.toLowerCase() === 'textarea') {
                    if (value.startsWith('base64~')) {
                        try {
                            const b64 = value.slice(7);
                            input.value = decodeURIComponent(escape(atob(b64)));
                        } catch (e) {
                            input.value = '';
                        }
                    } else {
                        input.value = value;
                    }
                } else {
                    input.value = value;
                }

                input.dispatchEvent(new Event('input'));
            });


        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            // Attach URL updating to all inputs
            document.querySelectorAll('input[type="range"], input[type="number"], input[type="checkbox"], select, textarea').forEach(input => {
                input.addEventListener('input', updateURLParams);
                input.addEventListener('change', updateURLParams);
            });



            loadStateFromURL();
            SetUpUI();
            createHarmonicButtons();
            renderKeyboard();
            updateHarmonicsText();

            // Initialize voice mix controls to follow master setting
            initializeVoiceMixControls();
            
            // Initialize voice count summary
            updateVoiceCountSummary();
            
            // Initialize voice count slider labels
            updateVoiceCountSliderLabels();

            // Handle window resize for keyboard
            window.addEventListener('resize', renderKeyboard);
            
            // Initialize OSC tabs functionality
            initializeOSCTabs();
            
            // Add event listener to update per-OSC voice count defaults when global synthVoices changes
            const synthVoicesSlider = document.getElementById('synthVoices');
            if (synthVoicesSlider) {
                synthVoicesSlider.addEventListener('input', () => {
                    // Only update if no per-OSC sliders have been explicitly set
                    let hasCustomSettings = false;
                    for (let i = 1; i <= 6; i++) {
                        const slider = document.getElementById(`osc${i}VoiceCount`);
                        if (slider && slider.value !== synthVoicesSlider.value) {
                            hasCustomSettings = true;
                            break;
                        }
                    }
                    
                    updateVoiceCountSummary();
                    updateVoiceCountSliderLabels();
                });
            }
            
            // Add event listeners to update voice count summary when relevant controls change
            const voiceCountControls = ['oscCount', 'synthVoices', 'osc1VoiceCount', 'osc2VoiceCount', 'osc3VoiceCount', 'osc4VoiceCount', 'osc5VoiceCount', 'osc6VoiceCount'];
            voiceCountControls.forEach(controlId => {
                const element = document.getElementById(controlId);
                if (element) {
                    element.addEventListener('input', () => {
                        updateVoiceCountSummary();
                        updateVoiceCountSliderLabels();
                    });
                    element.addEventListener('change', () => {
                        updateVoiceCountSummary();
                        updateVoiceCountSliderLabels();
                    });
                }
            });
        });

        // OSC Tabs functionality
        function initializeOSCTabs() {
            // Tab buttons and content
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            // Add click event listeners to all tab buttons
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');

                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // Add active class to clicked button and corresponding content
                    button.classList.add('active');
                    const targetContent = document.getElementById(targetTab + '-tab');
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });


            });



            // OSC Count selector functionality
            const oscCountSelector = document.getElementById('oscCount');
            if (oscCountSelector) {
                oscCountSelector.addEventListener('change', () => {
                    updateOSCTabsVisibility();
                });


            }

            // Initial setup
            updateOSCTabsVisibility();
        }

        function updateOSCTabsVisibility() {
            const oscCount = parseInt(document.getElementById('oscCount')?.value || '1');
            const tabButtons = document.querySelectorAll('.tab-button');
            
            // Show/hide OSC tabs based on count
            tabButtons.forEach((button, index) => {
                const tabName = button.getAttribute('data-tab');
                if (tabName === 'global') {
                    button.style.display = 'block'; // Always show global
                } else {
                    const oscNum = parseInt(tabName.replace('osc', ''));
                    button.style.display = oscNum <= oscCount ? 'block' : 'none';
                }
            });



            // Update active tab if current tab is hidden
            const activeButton = document.querySelector('.tab-button.active');
            if (activeButton && activeButton.style.display === 'none') {
                // Switch to global tab if active tab is hidden
                const globalButton = document.querySelector('.tab-button[data-tab="global"]');
                if (globalButton) {
                    globalButton.click();
                }
            }
        }

        // Help popup system
        document.getElementById('helpButton').addEventListener('click', function() {
            // Show the existing help popup
            document.getElementById('helpPopup').classList.remove('hidden');
        });



        // Close help popup
        document.getElementById('closeHelpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').classList.add('hidden');
        });



        // Function to clean up the URL by removing disallowed characters
            function CleanUpLink() {
                const DisAllowsCharacters = '(|^*%$#@!<>,/\\:\';\"{}[]~+")';
                const regex = new RegExp('[' + DisAllowsCharacters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']', 'g');
            
                const url = window.location.href;
                const [base, query] = url.split('?');
            
                if (query) {
                    const cleanedQuery = query.replace(regex, '');
                    const newUrl = `${base}?${cleanedQuery}`;
                    window.history.replaceState({}, '', newUrl);
                }
            }
            
            function handleDragOver(event) {
                event.preventDefault();
                event.target.classList.add('drag-over');
                event.target.classList.add('expanded');
            }

            function handleDragLeave(event) {
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
                const fileInput = event.target;
                const files = event.dataTransfer.files;
                fileInput.files = files;

                // Trigger change event manually
                const changeEvent = new Event('change');
                fileInput.dispatchEvent(changeEvent);
            }

            document.getElementById('carrierInput').addEventListener('dragover', handleDragOver);
            document.getElementById('carrierInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('carrierInput').addEventListener('drop', handleDrop);

            document.getElementById('audioInput').addEventListener('dragover', handleDragOver);
            document.getElementById('audioInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('audioInput').addEventListener('drop', handleDrop);

            document.getElementById('speedType').addEventListener('change', function(event) {
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                if (event.target.value == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            });



            const inputs='input[type="range"], input[type="number"], input[type="checkbox"], select'

            // Initialize the visibility of the speed slider based on the current selection
            document.getElementById('speedType').dispatchEvent(new Event('change'));

            // --- Cookie helpers ---
            function savePresetCookie(presetName, data, days = 30) {
                const json = JSON.stringify(data);
                const encoded = encodeURIComponent(json);
                let expires = "";
                if (days) {
                    const date = new Date();
                    date.setTime(date.getTime() + (days*24*60*60*1000));
                    expires = "; expires=" + date.toUTCString();
                }
                document.cookie = presetName + "=" + encoded + expires + "; path=/";
            }

            function loadPresetCookie(presetName) {
                const nameEQ = presetName + "=";
                const ca = document.cookie.split(';');
                for(let i=0; i < ca.length; i++) {
                    let c = ca[i].trim();
                    if (c.indexOf(nameEQ) === 0) {
                        try {
                            return JSON.parse(decodeURIComponent(c.substring(nameEQ.length)));
                        } catch (e) {
                            console.error("Invalid preset cookie", e);
                        }
                    }
                }
                return null;
            }

            function listPresets() {
                return document.cookie.split(";").map(c => c.trim().split("=")[0]);
            }

            // Collect current settings from inputs

            // Collect current settings from inputs
            function exportCurrentSettings() {
                const inputs = document.querySelectorAll('input, select'); // query inside function
                const settings = {};
                inputs.forEach(input => {
                    if (input.type === 'checkbox') {
                        settings[input.id] = input.checked;
                    } else {
                        settings[input.id] = input.value;
                    }
                });


                settings.Mode = Vmode;
                return settings;
            }

            // Apply settings back to inputs
            function importSettings(obj) {
                Object.keys(obj).forEach(key => {
                    if (key === "Mode" || key === "Vmode") {
                        Vmode = obj[key];
                        return;
                    }
                    const el = document.getElementById(key);
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = obj[key] === true || obj[key] === "true";
                        } else {
                            el.value = obj[key];
                        }
                        el.dispatchEvent(new Event('input'));
                        el.dispatchEvent(new Event('change'));
                    }
                });


            }


            // --- Your existing code with preset integration ---
            document.getElementById('ViewProperties').addEventListener('click', function() {
                const inputs = document.querySelectorAll('input, select');
                const fileInputs = document.querySelectorAll('input[type="file"]');
                const properties = [];
                const fileInfo = [];



                // Collect input values
                inputs.forEach(input => {
                    if (input.type === 'range' || input.type === 'number' || input.type === 'checkbox' || input.tagName === 'SELECT') {
                        properties.push(`${input.id}: ${input.value}`);
                    }
                });


                properties.push(`Mode: ${['FFT Mode','Analog Mode','4orm Mode','Some Experiments'][Vmode]}`); // Add Vmode as a property
                // Collect file input details
                fileInputs.forEach(fileInput => {
                    const file = fileInput.files[0];
                    if (file) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            audioContext.decodeAudioData(e.target.result, function(buffer) {
                                const duration = buffer.duration.toFixed(2);
                                fileInfo.push(`
                                    <h2>${file.name}</h2>
                                    <li>Size: ${(file.size / 1024).toFixed(2)} KB</li>
                                    <li>Duration: ${Math.floor(duration / 60)}:${Math.floor(duration % 60).toString().padStart(2, '0')}:${Math.floor((duration % 1) * 1000).toString().padStart(3, '0')} (${duration} seconds)</li>
                                    <li>Sample Rate: ${buffer.sampleRate} Hz</li>
                                    <li>Channels: ${buffer.numberOfChannels}</li>
                                    <li>Codec: ${(co=file.type.split('/')[1]|| 'failed to get Codec') , file.type === 'audio/wav' || file.type.includes('pcm') ? co + ` (PCM ${buffer.getChannelData(0).BYTES_PER_ELEMENT * 8})`: co}</li>
                                `);

                                // Update the popup content dynamically
                                const popup = document.querySelector('div[style*="z-index: 1000"]');
                                if (popup) {
                                    popup.innerHTML = `
                                        <h1>Properties</h1>
                                        ${fileInfo.join('')}
                                        <br>
                                        <h1>Input Values</h1>
                                        <ul>${properties.map(prop => `<li>${prop}</li>`).join('')}</ul>
                                        <br>
                                        <div>
                                            <button id="ExportJSON">Export JSON</button> |
                                            <button id="ImportJSON">Import JSON</button> 
                                            <br>
                                            note that this uses Cookies/localStorage
                                            <br>
                                            <button id="SavePreset">Save Preset</button> |
                                            <button id="LoadPreset">Load Preset</button> 
                                            <br>
                                            <button id="closePropertiesButton">Close</button>
                                        </div>
                                    `;

                                    // Reattach the close button event listener
                                    document.getElementById('closePropertiesButton').addEventListener('click', function() {
                                        document.body.removeChild(popup);
                                    });



                                    // Add ExportJSON functionality
                                    document.getElementById('ExportJSON').addEventListener('click', function() {
                                        const inputs = document.querySelectorAll('input, select'); // query inside the function
                                        const jsonObject = {};

                                        inputs.forEach(input => {
                                            if (input.type === 'checkbox') {
                                                jsonObject[input.id] = input.checked; // boolean
                                            } else {
                                                jsonObject[input.id] = input.value;   // string
                                            }
                                        });



                                        // Numeric Mode
                                        jsonObject.Mode = Vmode; // 0, 1, 2

                                        const jsonBlob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                                        const jsonUrl = URL.createObjectURL(jsonBlob);
                                        const downloadLink = document.createElement('a');
                                        downloadLink.href = jsonUrl;
                                        downloadLink.download = 'properties.json';
                                        downloadLink.click();
                                        URL.revokeObjectURL(jsonUrl);
                                    });



                                    // Import JSON
                                    document.getElementById('ImportJSON').addEventListener('click', function() {
                                        const input = document.createElement('input');
                                        input.type = 'file';
                                        input.accept = 'application/json';
                                        input.addEventListener('change', function(event) {
                                            const file = event.target.files[0];
                                            if (!file) return;

                                            const reader = new FileReader();
                                            reader.onload = function(e) {
                                                try {
                                                    const jsonObject = JSON.parse(e.target.result);
                                                    Object.keys(jsonObject).forEach(key => {
                                                        if (key === 'Mode' || key === 'Vmode') {
                                                            window.Vmode = jsonObject[key]; // numeric mode
                                                            return;
                                                        }
                                                        const inputElement = document.getElementById(key);
                                                        if (inputElement) {
                                                            if (inputElement.type === 'checkbox') {
                                                                inputElement.checked = jsonObject[key] === true;
                                                            } else {
                                                                inputElement.value = jsonObject[key];
                                                            }
                                                            inputElement.dispatchEvent(new Event('input'));
                                                            inputElement.dispatchEvent(new Event('change'));
                                                        }
                                                    });


                                                    alert('Properties imported successfully!');
                                                } catch (error) {
                                                    alert('Invalid JSON file. Please select a valid properties file.');
                                                }
                                            };
                                            reader.readAsText(file);
                                        });


                                        input.click();
                                    });



                                }
                            });


                        };
                        reader.readAsArrayBuffer(file);
                    } else {
                        fileInfo.push(`
                            <h2>${fileInput.id}</h2>
                            <li>No file selected</li>
                        `);
                    }
                });



                const popup = document.createElement('div');
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = '#333';
                popup.style.color = '#fff';
                popup.style.padding = '20px';
                popup.style.borderRadius = '10px';
                popup.style.width = '90vw';
                popup.style.maxWidth = '600px';
                popup.style.minWidth = '220px';
                popup.style.maxHeight = '80vh';
                popup.style.overflowY = 'auto';
                popup.style.zIndex = '1000';

                // Build popup content
                popup.innerHTML = `
                    <h2>Properties</h2>
                    ${fileInfo.join('')}
                    <h2>Input Values</h2>
                    <ul>${properties.map(p => `<li>${p}</li>`).join('')}</ul>
                    <br>
                    <div>
                        <button id="ExportJSON">Export JSON</button> |
                        <button id="ImportJSON">Import JSON</button> 
                        <br>
                        note that this uses Cookies/localStorage
                        <br>
                        <button id="SavePreset">Save Preset</button> |
                        <button id="LoadPreset">Load Preset</button> 
                        <br>
                        <button id="closePropertiesButton">Close</button>
                    </div>
                `;

                document.body.appendChild(popup);

                // Close button
                document.getElementById('closePropertiesButton').addEventListener('click', () => {
                    document.body.removeChild(popup);
                });



                // Export JSON
                document.getElementById('ExportJSON').addEventListener('click', () => {
                    const jsonObject = {};
                    inputs.forEach(input => {
                        if (input.type === 'range' || input.type === 'number' || input.tagName === 'SELECT') {
                            jsonObject[input.id] = input.value;
                        } else if (input.type === 'checkbox') {
                            jsonObject[input.id] = input.checked;
                        }
                    });


                    jsonObject.Mode = Vmode;
                    const blob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = "properties.json";
                    a.click();
                    URL.revokeObjectURL(url);
                });



                // Import JSON
                document.getElementById('ImportJSON').addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    input.onchange = e => {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = e => {
                            try {
                                const obj = JSON.parse(e.target.result);
                                applyPreset(obj);
                                alert("Imported successfully");
                            } catch {
                                alert("Invalid JSON");
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                });



                // Load presets from cookie/localStorage
                function getPresets() {
                    const data = localStorage.getItem("presets");
                    return data ? JSON.parse(data) : {};
                }

                    console.log("Loaded presets:", localStorage.getItem("presets"));

                // Save presets to storage
                function savePresets(presets) {
                    localStorage.setItem("presets", JSON.stringify(presets));
                    updatePresetList();
                }

                function updatePresetList() {
                    const presets = getPresets();
                    const presetList = document.getElementById("presetList");
                    if (!presetList) return; // <-- prevents null errors

                    presetList.innerHTML = `<option value="">-- Select a preset --</option>`;
                    for (const key in presets) {
                        const opt = document.createElement("option");
                        opt.value = key;
                        opt.textContent = key;
                        presetList.appendChild(opt);
                    }
                }


                // Save preset
                document.getElementById("SavePreset").addEventListener("click", () => {
                    const name = prompt("Enter a preset name:");
                    if (!name) return;
                    const presets = getPresets();
                    presets[name] = exportCurrentSettings(); // <-- replace with your export function
                    savePresets(presets);
                });



                // Load preset
                document.getElementById("LoadPreset").addEventListener("click", () => {
                    // Check if the dropdown already exists
                    if (!document.getElementById("presetList")) {
                        const container = document.createElement("div");
                        container.style.marginTop = "10px";
                        container.innerHTML = `
                            <label for="presetList">Presets: </label>
                            <select id="presetList">
                                <option value="">-- Select a preset --</option>
                            </select>
                            <button id="ConfirmLoadPreset">Load</button>
                        `;
                        popup.appendChild(container);

                        updatePresetList(); // ✅ safe now, dropdown exists

                        // Confirm load action
                        document.getElementById("ConfirmLoadPreset").addEventListener("click", () => {
                            const presetList = document.getElementById("presetList");
                            const name = presetList.value;
                            if (!name) {
                                alert("Please select a preset from the list.");
                                return;
                            }
                            const presets = getPresets();
                            if (presets[name]) {
                                importSettings(presets[name]);
                                alert(`Preset "${name}" loaded successfully.`);
                            }
                        });


                    }
                });





                // Initialize dropdown on page load
                updatePresetList();


                // Apply preset to inputs
                function applyPreset(obj) {
                    Object.keys(obj).forEach(key => {
                        if (key === "Mode" || key === "Vmode") {
                            Vmode = obj[key];
                            return;
                        }
                        const el = document.getElementById(key);
                        if (el) {
                            if (el.type === 'checkbox') {
                                el.checked = obj[key] === true || obj[key] === "true";
                            } else {
                                el.value = obj[key];
                            }
                            el.dispatchEvent(new Event('input'));
                            el.dispatchEvent(new Event('change'));
                        }
                    });


                }
            });



                </script>

        <script>
            // Build Sync & Ring matrices UI and display sync clocks (phase % 256)
            document.addEventListener('DOMContentLoaded', () => {
                const maxOsc = 6;
                const syncMatrixContainer = document.getElementById('syncMatrixContainer');
                const ringMatrixContainer = document.getElementById('ringMatrixContainer');
                const syncClocksDisplay = document.getElementById('syncClocksDisplay');

                // matrices are required; clocks display is optional
                if (!syncMatrixContainer || !ringMatrixContainer) return;

                function makeMatrix(container, prefix) {
                    container.innerHTML = '';
                    const table = document.createElement('table');
                    table.style.borderCollapse = 'collapse';
                    table.style.width = '100%';
                    const thead = document.createElement('thead');
                    const headRow = document.createElement('tr');
                    headRow.appendChild(document.createElement('th')); // corner
                    for (let c = 1; c <= maxOsc; c++) {
                        const th = document.createElement('th');
                        th.style.padding = '4px';
                        th.style.textAlign = 'center';
                        th.textContent = 'T' + c;
                        headRow.appendChild(th);
                    }
                    thead.appendChild(headRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    for (let s = 1; s <= maxOsc; s++) {
                        const row = document.createElement('tr');
                        const label = document.createElement('td');
                        label.textContent = 'S' + s;
                        label.style.padding = '4px';
                        row.appendChild(label);
                        for (let t = 1; t <= maxOsc; t++) {
                            const cell = document.createElement('td');
                            cell.style.padding = '4px';
                            cell.style.textAlign = 'center';
                            const chk = document.createElement('input');
                            chk.type = 'checkbox';
                            chk.id = `${prefix}_s${s}_t${t}`;
                            chk.dataset.src = String(s);
                            chk.dataset.tgt = String(t);
                            cell.appendChild(chk);
                            row.appendChild(cell);
                        }
                        tbody.appendChild(row);
                    }
                    table.appendChild(tbody);
                    container.appendChild(table);
                }

                // Initialize matrices
                makeMatrix(syncMatrixContainer, 'sync');
                makeMatrix(ringMatrixContainer, 'ring');

                // update visibility according to oscCount
                function updateVisibility() {
                    const oscCount = parseInt(document.getElementById('oscCount')?.value || '1');
                    for (let s = 1; s <= maxOsc; s++) {
                        for (let t = 1; t <= maxOsc; t++) {
                            const visible = (s <= oscCount) && (t <= oscCount);
                            const nodeSync = document.getElementById(`sync_s${s}_t${t}`);
                            const nodeRing = document.getElementById(`ring_s${s}_t${t}`);
                            if (nodeSync) nodeSync.disabled = !visible;
                            if (nodeRing) nodeRing.disabled = !visible;
                        }
                    }
                }

                // Hook oscCount change
                const oscCountEl = document.getElementById('oscCount');
                if (oscCountEl) {
                    oscCountEl.addEventListener('change', updateVisibility);
                }

                // start updater
                updateVisibility();
            });
        </script>
    <script>
        let audioContext, analyser, source, processedBuffer, audioData, carrierBuffer;
        let loadedAudioBuffer = null;
        let loadedCarrierBuffer = null;
        let playbackSource = null;

        function extractAudioFromVideo(file, callback) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.play();

            video.addEventListener('canplaythrough', function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                const recorder = new MediaRecorder(destination.stream);
                const chunks = [];

                recorder.ondataavailable = function(event) {
                    chunks.push(event.data);
                };

                recorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(blob);
                };

                recorder.start();
                video.play();
                setTimeout(() => {
                    recorder.stop();
                    video.pause();
                    URL.revokeObjectURL(video.src);
                }, video.duration * 1000);
            });


        }

        function handleFileInput(event, callback) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    extractAudioFromVideo(file, callback);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        document.getElementById('audioInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioData = e.target.result;
                    audioContext.decodeAudioData(audioData, function(buffer) {
                        loadedAudioBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding carrier audio data:', error);
                        showErrorPopup(`Error decoding carrier audio data. Please select a valid audio file. \n ${error}`);
                    });


                };
                reader.readAsArrayBuffer(file);
            }
        });



        let EnSynth = document.getElementById('enableSynth').checked;
        // this fixed the issue of requiring the carrier file to be loaded first
        function tryProcessAudio(B) {
            if (loadedCarrierBuffer && (loadedAudioBuffer || EnSynth)) {
                processAudio(B);
            }
        }

        document.getElementById('carrierInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const carrierData = e.target.result;
                    audioContext.decodeAudioData(carrierData, function(buffer) {
                        loadedCarrierBuffer = buffer;
                        carrierBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding modular audio data:', error);
                        showErrorPopup(`Error decoding modular audio data. Please select a valid audio file. \n ${error}`);
                    });


                };
                reader.readAsArrayBuffer(file);
            }
        });



        document.getElementById('reprocessButton').addEventListener('click', function() {
            if (loadedAudioBuffer && (loadedCarrierBuffer||EnSynth)) {
                processAudio(loadedAudioBuffer);
            } else {
                showErrorPopup('Please load both audio and input files first.', true); // warning style popup
            }
        });



        document.getElementById('Harmonics').addEventListener('input', (e) => {
            /*const text = e.target.value;
            let parsed = [];

            try {
                const result = eval(text);
                if (Array.isArray(result)) {
                    parsed = result;
                    console.log("Harmonics array:", parsed);
                } else {
                    console.warn("Harmonics input did not return an array.");
                }
            } catch (err) {
                console.error("Failed to evaluate harmonics:", err);
            }*/

            updateURLParams()
        })

        function createLoopedBuffer(buffer, targetLength) {
            const sampleRate = buffer.sampleRate;
            const numberOfChannels = buffer.numberOfChannels;
            const newBuffer = audioContext.createBuffer(numberOfChannels, targetLength, sampleRate);
            
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const nowBuffering = newBuffer.getChannelData(channel);
                const originalData = buffer.getChannelData(channel);
                
                for (let i = 0; i < targetLength; i++) {
                    nowBuffering[i] = originalData[i % originalData.length];
                }
            }
            
            return newBuffer;
        }

        function showProcessPOP_UP(text, block = true, bar = false, per) {
            let popup = document.getElementById('processPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'processPopup';
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = '#222';
                popup.style.color = '#fff';
                popup.style.padding = '30px 40px';
                popup.style.borderRadius = '12px';
                popup.style.boxShadow = '0 4px 24px #000a';
                popup.style.zIndex = '2000';
                popup.style.fontSize = '1.2em';
                popup.style.textAlign = 'center';
                popup.style.display = 'flex';
                popup.style.flexDirection = 'column';
                popup.style.alignItems = 'center';
                popup.style.justifyContent = 'center';
                popup.style.width = '90vw';        // Responsive width
                popup.style.maxWidth = '600px';    // Maximum width
                popup.style.minWidth = '220px';    // Minimum width for usability
                popup.style.maxHeight = '90vh';    // Responsive height
                //popup.style.overflowY = 'auto';    // Enable vertical scroll if needed
                document.body.appendChild(popup);
            }

            // Clear popup content
            popup.innerHTML = '';

            // Add text
            const textDiv = document.createElement('div');
            textDiv.innerHTML = text.replace(/\n/g, '<br>');
            popup.appendChild(textDiv);

            // Add or update progress bar
            if (bar) {
                let progressBar = document.getElementById('progressBar');
                let progressFill = document.getElementById('progressFill');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.id = 'progressBar';
                    progressBar.style.width = '100%';
                    progressBar.style.height = '20px';
                    progressBar.style.backgroundColor = '#444';
                    progressBar.style.borderRadius = '10px';
                    progressBar.style.marginTop = '10px';

                    progressFill = document.createElement('div');
                    progressFill.id = 'progressFill';
                    progressFill.style.height = '100%';

                    const B255 = (Math.min(per/100*255, 255) / 255) ** 1.5 * 255;
                    progressFill.style.backgroundColor = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    progressFill.style.borderRadius = '10px';

                    progressBar.appendChild(progressFill);
                    popup.appendChild(progressBar);
                }
                // Always update width
                progressFill.style.width = `${per || 0}%`;
            }

            // Remove any fixed height so it grows/shrinks automatically
            popup.style.height = '';

            popup.style.display = block && text ? 'block' : 'none';
        }

        function showProcessPOP_UP_WL(message, visible = true, showProgress = false, progress = 0) {
            let popup = document.getElementById("processPopup");

            // Flex layout: gif on the left, text on the right
            popup.innerHTML = `
                <div style="display:flex;align-items:center;gap:15px;">
                    <img src="Load.gif" alt="Loading..." style="width:75px;height:75px;flex-shrink:0;">
                    <div style="flex:1;">
                        <p style="margin:0;white-space:pre-line;">${message || "Processing..."}</p>
                        ${showProgress ? `
                            <div id="progressWrapper" style="margin-top:10px;width:100%;background:#222;border-radius:5px;overflow:hidden;height:12px;">
                                <div id="progressBar" style="height:100%;width:${progress || 0}%;background:#5ac8fa;"></div>
                            </div>` : ""}
                    </div>
                </div>
            `;
            popup.style.display = "block";

            if (showProgress) {
                let per = Math.max(0, Math.min(progress, 100)); // clamp 0-100
                const progressBar = popup.querySelector("#progressBar");
                if (progressBar) {
                    progressBar.style.width = per + "%";

                    // 🎨 Color formula
                    const B255 = (Math.min(per / 100 * 255, 255) / 255) ** 1.5 * 255;
                    progressBar.style.backgroundColor =
                        `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                }
            }

            if (!popup) {
                popup = document.createElement("div");
                popup.id = "processPopup";
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.background = "rgba(34, 34, 34, 0.95)";
                popup.style.color = "#fff";
                popup.style.padding = "20px 30px";
                popup.style.borderRadius = "15px";
                popup.style.zIndex = "6000";
                popup.style.textAlign = "left";
                popup.style.boxShadow = "0 10px 40px rgba(0,0,0,0.6)";
                popup.style.minWidth = "320px";
                popup.style.maxWidth = "500px";
                document.body.appendChild(popup);
            }

            if (!visible) {
                popup.style.display = "none";
                return;
            }
        }

        function showErrorPopup(message, warn = false) {
            // Check if popup already exists, remove it
            let existingPopup = document.getElementById('errorPopup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'errorPopup';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10000';

            // Create popup container
            const popup = document.createElement('div');
            popup.style.backgroundColor = warn ? '#b58900' : '#700'; // yellow for warn, red for error
            popup.style.color = '#fff';
            popup.style.padding = '20px 30px';
            popup.style.borderRadius = '12px';
            popup.style.maxWidth = '400px';
            popup.style.width = '90%';
            popup.style.boxShadow = '0 4px 20px rgba(0,0,0,0.5)';
            popup.style.textAlign = 'center';
            popup.style.fontFamily = 'Arial, sans-serif';

            // Message text
            const messageEl = document.createElement('p');
            messageEl.style.marginBottom = '20px';
            messageEl.style.whiteSpace = 'pre-wrap'; // preserve line breaks
            messageEl.textContent = message;

            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.background = warn ? '#d7a600' : '#a00'; // lighter yellow for warn, dark red for error
            closeBtn.style.border = 'none';
            closeBtn.style.color = '#fff';
            closeBtn.style.padding = '10px 20px';
            closeBtn.style.borderRadius = '8px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.transition = 'background 0.3s ease';

            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = warn ? '#ffcc00' : '#f00'; // bright yellow on hover for warn, bright red for error
            });


            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = warn ? '#d7a600' : '#a00';
            });



            closeBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });



            // Append elements
            popup.appendChild(messageEl);
            popup.appendChild(closeBtn);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        //showErrorPopup('Test',1)

        // Global synth state
        const synthState = {
            heldNotes: new Set(),
            enabled: false,
            waveform: 0,
            volume: 0.5,
            octave: 0,
            detune: 0,
            voices: 1,
            t: 0 // Global time counter
        };
        // per-osc, per-voice phase accumulators (L/R)
        synthState.phaseAcuL = Array.from({ length: 6 }, () => []);
        synthState.phaseAcuR = Array.from({ length: 6 }, () => []);

        function SoundGoodizer(input, amt, channel) {
            // initialize persistent states once per channel
            if (!SoundGoodizer._state) SoundGoodizer._state = {};
            if (!SoundGoodizer._state[channel]) {
                SoundGoodizer._state[channel] = {
                    z2MBC: [], // lowpass stages
                    z3MBC: [], // highpass stages
                    RMS:  []  // rms detectors
                };
            }
            const state = SoundGoodizer._state[channel];
            const { z2MBC, z3MBC, RMS } = state;

            // RMS / envelope follower
            function MBCrms(x, attack, release, call) {
                if (!RMS[call]) RMS[call] = 0;
                let e = RMS[call];
                let target = Math.abs(x);
                let coeff = target > e ? attack : release;
                e += coeff * (target - e);
                RMS[call] = e;
                return e;
            }


            function MBClp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2MBC[callCount]) {
                    z2MBC[callCount] = { lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0 };
                }
                const cc = Math.min(Math.max(c,0),0.9999);
                const fbv = r + r/(1-cc);
                const f = d;
                let s = z2MBC[callCount];
                s.lp6  += cc*(f - s.lp6 + fbv*(s.lp6 - s.lp12));
                s.lp12 += cc*(s.lp6 - s.lp12);
                s.lp18 += cc*(s.lp12 - s.lp18);
                s.lp24 += cc*(s.lp18 - s.lp24);
                s.lp30 += cc*(s.lp24 - s.lp30);
                s.lp36 += cc*(s.lp30 - s.lp36);
                s.lp42 += cc*(s.lp36 - s.lp42);
                s.lp48 += cc*(s.lp42 - s.lp48);
                switch(dbv){
                    case 1:return s.lp6;
                    case 2:return s.lp12;
                    case 3:return s.lp18;
                    case 4:return s.lp24;
                    case 5:return s.lp30;
                    case 6:return s.lp36;
                    case 7:return s.lp42;
                    case 8:return s.lp48;
                    default:return s.lp12;
                }
            }

            function MBChp(d, c, r = 0, dbv = 2, callCount) {
                if (!z3MBC[callCount]) {
                    z3MBC[callCount] = { hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0 };
                }
                const cc = Math.min(Math.max(c,0),0.9999);
                const fbv = r + r/(1-cc);
                let s = z3MBC[callCount];
                s.hp6  += cc*(d - s.hp6 + fbv*(s.hp6 - s.hp12));
                s.hp12 += cc*(s.hp6 - s.hp12);
                let x = d - (dbv>=2 ? s.hp12 : s.hp6);
                if (dbv===1||dbv===2) return x;
                x -= (s.hp18+= cc*(x-s.hp18)); if (dbv===3) return x;
                x -= (s.hp24+= cc*(x-s.hp24)); if (dbv===4) return x;
                x -= (s.hp30+= cc*(x-s.hp30)); if (dbv===5) return x;
                x -= (s.hp36+= cc*(x-s.hp36)); if (dbv===6) return x;
                x -= (s.hp42+= cc*(x-s.hp42)); if (dbv===7) return x;
                x -= (s.hp48+= cc*(x-s.hp48)); if (dbv===8) return x;
                return x;
            }

            compressor = (input, threshold, ratio, attack, decay,call) => {
                let level = MBCrms(input, attack, decay, call);
                threshold/=3
                //ratio/=1.2
                let gain = Math.min(1, (threshold / level) ** (ratio - 1));
                return input * gain;
            }

            function mbc(d, settings) {
                const {
                    lowFreq=.05, midLow=.1, midHigh=.2, HighFreq=0,
                    lowThreshold=20, midThreshold=20, highThreshold=20,
                    ratio=4, decay=.01, attack=0,db=2
                }=settings;

                d = MBChp(d,.01,0,3,channel*5);

                //natural sound ratios 1, 2 and 1.5
                let low=MBClp(d,lowFreq,0,db,0+channel*5);
                low=compressor(low,lowThreshold,ratio,attack,decay,0+channel*5);

                let mid=MBChp(MBClp(d/2,midHigh,0,db,1+channel*5),midLow,0,db,1+channel*5);
                mid=compressor(mid,midThreshold,ratio,attack,decay,1+channel*5);

                let high=MBChp(d/1.5,HighFreq,0,db,2+channel*5);
                high=compressor(high,highThreshold,ratio,attack,decay,2+channel*5);

                return low+mid+high;
            }

            const thres=1;
            const set={
                lowFreq:.05, midLow:.015, midHigh:.4, HighFreq:.1,
                lowThreshold:thres, midThreshold:thres, highThreshold:thres,
                ratio:2.0, decay:0.0005, attack:0.01, db:8
            };

            // rms(input,.01,.01,0) fine
            // to prevent cliping
            return compressor(mbc(input*(1+amt*100),set),thres,set.ratio,set.attack,set.decay,channel*5+3);
        }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Main synthesis function
        const waveShaper = (t) => {
            tt = Math.min(Math.max(t,-1),1)/2+.5;
            actualthing=((DistTable.charCodeAt(Math.floor(tt*DistTable.length)%DistTable.length)/2**14-1)*2.47-tt%1+0.5)*2
            interperlated=((Math.abs(t-tt*2+1)+1)**2-1)*6
            return interperlated+actualthing
        }
        // Performance-optimized synthesis function with caching
        const synthOptimizer = {
            cachedConfig: null,
            lastConfigTime: 0,
            configCacheTimeout: 100, // ms
            cacheDOMValues() {
                const now = performance.now();
                if (this.cachedConfig && (now - this.lastConfigTime) < this.configCacheTimeout) {
                    return this.cachedConfig;
                }

                // Cache all DOM values at once
                this.cachedConfig = {
                    oscCount: parseInt(document.getElementById('oscCount')?.value || '1'),
                    globalOVDistortVal: getGlobalOVDistort(),
                    masterVolume: getMasterVolume(),
                    masterOctave: getMasterOctave(),
                    masterDetune: getMasterDetune(),
                    masterCents: getMasterCents(),
                    masterVoiceMix: getMasterVoiceMix(),
                    masterVoices: parseInt(document.getElementById('synthVoices')?.value || '1'),
                    enableSynth: document.getElementById("enableSynth")?.checked || false,
                    oscVoiceCounts: Array.from({ length: 6 }, (_, i) => getOSCVoiceCount(i + 1))
                };
                this.lastConfigTime = now;
                return this.cachedConfig;
            }
        };

        function polyFsawFromKeyboard(m, heldNotesSet, octaveShift, detuneAmount, waveformType, t, SynthState, SR) {
            try {
                if (heldNotesSet.size === 0) return [0, 0];

                // Get cached config (updated every 100ms) for performance
                const config = synthOptimizer.cacheDOMValues();
                if (!config.enableSynth) return [0, 0];

                // Decide master voices: prefer function parameter 'm' if valid, else config
                const masterVoices = (typeof m === 'number' && m > 0) ? Math.max(1, Math.floor(m)) : (config.masterVoices || 1);

                // Pre-calculate values that don't change during processing
                const notesArray = Array.from(heldNotesSet);
                const noteBaseFreqs = new Float32Array(notesArray.length);
                for (let i = 0; i < notesArray.length; i++) {
                    noteBaseFreqs[i] = 2 ** ((notesArray[i] - 67.5 - 9.23) / 12);
                }
                const len = notesArray.length;

                // Calculate per-OSC voice counts and total voices consistently (include masterVoices)
                const oscVoiceCounts = config.oscVoiceCounts || [];
                let totalVoices = 0;
                let maxVoicesPerNote = 0;
                let maxOscVoiceCount = 0;

                for (let oscIndex = 0; oscIndex < config.oscCount; oscIndex++) {
                    if (!isOSCEnabled(oscIndex + 1)) {
                        oscVoiceCounts[oscIndex] = 0;
                        continue;
                    }
                    const oscVoices = oscVoiceCounts[oscIndex] || 1;
                    oscVoiceCounts[oscIndex] = oscVoices;
                    maxOscVoiceCount = Math.max(maxOscVoiceCount, oscVoices);
                    const effectiveVoices = oscVoices * masterVoices; // incorporate master voices
                    totalVoices += len * effectiveVoices;
                    maxVoicesPerNote = Math.max(maxVoicesPerNote, effectiveVoices);
                }

                const volumeNormalization = 1 / Math.sqrt(Math.max(1, maxVoicesPerNote));

                // Initialize SynthState arrays to totalVoices length if not already set (or if totalVoices changed)
                if (!SynthState.oscPhaseClock || SynthState._lastTotalVoices !== totalVoices) {
                    SynthState._lastTotalVoices = totalVoices;
                    const oscCount6 = Math.max(6, config.oscCount);
                    SynthState.oscPhaseClock = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.oscPhaseFull = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.prevOscPhaseClock = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.prevOscPhaseFull = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.phaseAcuL = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.phaseAcuR = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.voiceMixes = new Array(totalVoices);
                    for (let i = 0; i < totalVoices; i++) SynthState.voiceMixes[i] = { L: 0, R: 0 };
                    SynthState.oscOutputsL = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                    SynthState.oscOutputsR = Array.from({ length: oscCount6 }, () => new Array(totalVoices).fill(0));
                } else {
                    // Ensure voiceMixes has correct length and zeroed
                    if (!Array.isArray(SynthState.voiceMixes) || SynthState.voiceMixes.length !== totalVoices) {
                        SynthState.voiceMixes = new Array(totalVoices);
                    }
                    for (let i = 0; i < totalVoices; i++) {
                        SynthState.voiceMixes[i] = SynthState.voiceMixes[i] || { L: 0, R: 0 };
                        SynthState.voiceMixes[i].L = 0;
                        SynthState.voiceMixes[i].R = 0;
                    }
                }

                // Helper: per-OSC base offsets so each osc uses a consistent global k index
                const perOscBaseOffset = new Array(config.oscCount).fill(0);
                {
                    let offset = 0;
                    for (let oscIndex = 0; oscIndex < config.oscCount; oscIndex++) {
                        if (!isOSCEnabled(oscIndex + 1)) {
                            perOscBaseOffset[oscIndex] = offset; // keep offset unchanged for disabled oscillators
                            continue;
                        }
                        const oscVoices = oscVoiceCounts[oscIndex] || 1;
                        perOscBaseOffset[oscIndex] = offset;
                        offset += len * (oscVoices * masterVoices);
                    }
                    // sanity: offset should equal totalVoices
                }

                // mapping helper: global index for given parameters
                const getGlobalIndex = (oscIndex, noteIndex, masterSlot, voiceIndex) => {
                    const base = perOscBaseOffset[oscIndex] || 0;
                    const oscVoices = oscVoiceCounts[oscIndex] || 1;
                    return base + (noteIndex * masterVoices + masterSlot) * oscVoices + voiceIndex;
                };

                let sumL = 0, sumR = 0;

                // Helper to read matrix checkboxes (kept as before)
                const getSyncMatrix = () => {
                    const matrix = [];
                    for (let s = 1; s <= 6; s++) {
                        matrix[s] = [];
                        for (let t = 1; t <= 6; t++) {
                            const el = document.getElementById(`sync_s${s}_t${t}`);
                            matrix[s][t] = el ? el.checked : false;
                        }
                    }
                    return matrix;
                };
                const getRingMatrix = () => {
                    const matrix = [];
                    for (let s = 1; s <= 6; s++) {
                        matrix[s] = [];
                        for (let t = 1; t <= 6; t++) {
                            const el = document.getElementById(`ring_s${s}_t${t}`);
                            matrix[s][t] = el ? el.checked : false;
                        }
                    }
                    return matrix;
                };

                const syncMatrix = getSyncMatrix();
                const ringMatrix = getRingMatrix();

                // Store previous phase clocks for sync detection
                const prevClocks = SynthState.prevOscPhaseClock.map(osc => osc.slice());

                // First pass: process each OSC and fill oscOutputs and voiceMixes (but skip adding for ring-modded voices)
                for (let oscIndex = 0; oscIndex < config.oscCount; oscIndex++) {
                    if (!isOSCEnabled(oscIndex + 1)) continue;

                    const oscConfig = getOSCConfig(oscIndex + 1);
                    const effectiveOctave = config.masterOctave + oscConfig.octave;
                    const oscDetune = oscConfig.detune; // the osc can only use its own detune
                    const masterDetune = config.masterDetune; // master detune is applied to all oscillators
                    const centsAdjustment = Math.pow(2, (config.masterCents + oscConfig.cents) / 12000);

                    // Pre-calc LFO
                    let lfoValue = 0;
                    if (oscConfig.lfoEnabled) {
                        lfoValue = Math.sin(oscConfig.lfoRate * t / 44100 * Math.PI) * oscConfig.lfoAmount;
                    }

                    const sampleRateFactor = 44100 / SR;
                    const oscVolume = oscConfig.volume;
                    const oscOVDistort = oscConfig.distort;
                    const oscWaveform = oscConfig.waveform;
                    const oscVoiceCount = oscVoiceCounts[oscIndex];

                    for (let noteIndex = 0; noteIndex < len; noteIndex++) {
                        for (let masterSlot = 0; masterSlot < masterVoices; masterSlot++) {
                            for (let voiceIndex = 0; voiceIndex < oscVoiceCount; voiceIndex++) {
                                const k = getGlobalIndex(oscIndex, noteIndex, masterSlot, voiceIndex);

                                // Use pre-calculated base frequency and apply octave shift
                                const pitch = noteBaseFreqs[noteIndex] * (2 ** effectiveOctave) * centsAdjustment;

                                const detuneL = Math.sin(voiceIndex) * 8;
                                const detuneR = Math.sin(-voiceIndex) * 8;
                                const DTL = Math.abs(detuneL) * 1e9;
                                const DTR = Math.abs(detuneR) * 1e9;

                                const masterDetuneL = Math.sin(masterSlot)
                                const masterDetuneR = Math.sin(-masterSlot);
                                const MDTL = Math.abs(masterDetuneL) * 1e9;
                                const MDTR = Math.abs(masterDetuneR) * 1e9;

                                //console.log(detuneL, detuneR, masterDetuneL, masterDetuneR, DTL, DTR, MDTL, MDTR)

                                // Fast phase accumulation
                                let basePL = pitch * (1 + detuneL * (oscDetune) / 100);
                                let basePR = pitch * (1 + detuneR * (oscDetune) / 100);
                                
                                basePL *= (1 + masterDetuneL * (masterDetune) / 100);
                                basePR *= (1 + masterDetuneR * (masterDetune) / 100);


                                let pitchIncL = oscConfig.lfoEnabled ? basePL * (1 + lfoValue) : basePL;
                                let pitchIncR = oscConfig.lfoEnabled ? basePR * (1 + lfoValue) : basePR;

                                pitchIncL *= sampleRateFactor;
                                pitchIncR *= sampleRateFactor;

                                // Ensure accumulators exist (pre-filled, but keep defensive check)
                                if (typeof SynthState.phaseAcuL[oscIndex][k] === 'undefined') SynthState.phaseAcuL[oscIndex][k] = 0;
                                if (typeof SynthState.phaseAcuR[oscIndex][k] === 'undefined') SynthState.phaseAcuR[oscIndex][k] = 0;

                                // Check for sync from any source oscillator that targets this osc
                                let syncTriggered = false;
                                for (let srcOsc = 0; srcOsc < config.oscCount; srcOsc++) {
                                    if (srcOsc === oscIndex) continue;
                                    if (syncMatrix[srcOsc + 1] && syncMatrix[srcOsc + 1][oscIndex + 1]) {
                                        const srcPhaseClock = SynthState.oscPhaseClock[srcOsc][k];
                                        const srcPrevClock = prevClocks[srcOsc][k];
                                        if (typeof srcPhaseClock !== 'undefined' && typeof srcPrevClock !== 'undefined') {
                                            if (srcPhaseClock < srcPrevClock) {
                                                SynthState.phaseAcuL[oscIndex][k] = 0;
                                                SynthState.phaseAcuR[oscIndex][k] = 0;
                                                syncTriggered = true;
                                            }
                                        }
                                    }
                                }

                                // Advance accumulators
                                SynthState.phaseAcuL[oscIndex][k] += pitchIncL;
                                SynthState.phaseAcuR[oscIndex][k] += pitchIncR;

                                const phaseL = SynthState.phaseAcuL[oscIndex][k] + DTL + MDTL;
                                const phaseR = SynthState.phaseAcuR[oscIndex][k] + DTR + MDTR;

                                // Update OSC clocks (after advancing phase) - store per voice
                                SynthState.oscPhaseClock[oscIndex][k] = Math.floor(phaseL) & 255;
                                SynthState.oscPhaseFull[oscIndex][k] = phaseL;

                                // Waveform generation (preserved)
                                let vl, vr;
                                switch (oscWaveform) {
                                    case 0: // sine
                                        vl = -Math.sin(phaseL / 128 * Math.PI);
                                        vr = -Math.sin(phaseR / 128 * Math.PI);
                                        break;
                                    case 1: // triangle
                                        vl = Math.asin(-Math.sin(phaseL / 128 * Math.PI)) / Math.PI * 2;
                                        vr = Math.asin(-Math.sin(phaseR / 128 * Math.PI)) / Math.PI * 2;
                                        break;
                                    case 2: // sawtooth
                                        vl = ((phaseL + 128) / 128) % 2 - 1;
                                        vr = ((phaseR + 128) / 128) % 2 - 1;
                                        break;
                                    case 3: // square
                                        vl = (phaseL & 128)/64 - 1;
                                        vr = (phaseR & 128)/64 - 1;
                                        break;
                                    case 4: { // PWM
                                        const phh = Math.acos(-Math.cos(t / 32768 * Math.PI)) / Math.PI * 128;
                                        vl = ((phaseL | (phaseL + phh)) & 128)/128 - phh/256 - 0.5;
                                        vr = ((phaseR | (phaseR + phh)) & 128)/128 - phh/256 - 0.5;
                                        break;
                                    }
                                    case 5: // brTable
                                        vl = brTable[Math.floor(phaseL) & 255];
                                        vr = brTable[Math.floor(phaseR) & 255];
                                        break;
                                    case 6: // custom waveform
                                        vl = customWaveform(pitch * (1 + detuneL * detuneAmount / 100), t, phaseL);
                                        vr = customWaveform(pitch * (1 + detuneR * detuneAmount / 100), t, phaseR);
                                        break;
                                    case 7: // indigo
                                        vl = indigo.charCodeAt(Math.floor(phaseL*2**(2/12)/55*258) % indigo.length)/(2**12)-8;
                                        vr = indigo.charCodeAt(Math.floor(phaseR*2**(2/12)/55*258) % indigo.length)/(2**12)-8;
                                        break;
                                    case 8: // TriSaw
                                        vl = (((phaseL & 128) ? ~phaseL : phaseL*2) & 255)/170 - 0.56;
                                        vr = (((phaseR & 128) ? ~phaseR : phaseR*2) & 255)/170 - 0.56;
                                        break;
                                    case 9: // noise
                                        vl = Math.random()*2-1;
                                        vr = Math.random()*2-1;
                                        break;
                                    case 11: // strings
                                        vl = strings.charCodeAt(Math.floor(phaseL*2**(2/12)/55*258) % strings.length)/(2**12)-8;
                                        vr = strings.charCodeAt(Math.floor(phaseR*2**(2/12)/55*258) % strings.length)/(2**12)-8;
                                        break;
                                    case 12: // unisono
                                        vl = unisono.charCodeAt(Math.floor(phaseL*2**(2/12)/55*258) % unisono.length)/(2**12)-8;
                                        vr = unisono.charCodeAt(Math.floor(phaseR*2**(2/12)/55*258) % unisono.length)/(2**12)-8;
                                        break;
                                    case 13: // strings + unisono
                                        vl = (unisono.charCodeAt(Math.floor(phaseL*2**(2/12)/55*258) % unisono.length) + strings.charCodeAt(Math.floor(phaseL*2**(2.1/12)/55*258) % strings.length))/(2**12)-16;
                                        vr = (unisono.charCodeAt(Math.floor(phaseR*2**(2/12)/55*258) % unisono.length) + strings.charCodeAt(Math.floor(phaseR*2**(2.1/12)/55*258) % strings.length))/(2**12)-16;
                                        break;
                                    case 14: { // Power
                                        const powerResult = Power(phaseL, len * masterVoices * oscVoiceCount, k, t); // this function is very slow, i don't know why
                                        vl = powerResult[0];
                                        vr = powerResult[1];
                                        break;
                                    }
                                    case 15: // damped saw
                                        vl = Math.sin(Math.tan((phaseL/128-(Math.sin(Math.tan((phaseL/128)%2-1)*2.02))/6)%2-1)*2.02);
                                        vr = Math.sin(Math.tan((phaseR/128-(Math.sin(Math.tan((phaseR/128)%2-1)*2.02))/6)%2-1)*2.02);
                                        break;
                                    case 16: { // VX Phased
                                        const i = k % len;
                                        const j = Math.floor(k / len);
                                        const state = getPhasedState(j, i);
                                        const phasedResult = Phased(phaseL + 128, t, len, state);
                                        vl = phasedResult[0];
                                        vr = phasedResult[1];
                                        break;
                                    }
                                    case 17: // VX chip (Arp)
                                        {
                                            const chipResult = Chip(notesArray, detuneL+masterDetuneL, detuneR+masterDetuneR, (oscDetune/100)*(masterDetune/100), 1, t, effectiveOctave);
                                            vl = chipResult[0] / len;
                                            vr = chipResult[1] / len;
                                        }
                                        break;
                                    case 18: // VX Robotsaw
                                        {
                                            const robotResult = Robotsaw(phaseL, t, k);
                                            vl = robotResult[0];
                                            vr = robotResult[1];
                                        }
                                        break;
                                    case 19: // ST chip (Arp)
                                        {
                                            const chip2Result = Chip2(notesArray, detuneL+masterDetuneL, detuneR+masterDetuneR, (oscDetune/100)*(masterDetune/100), 1, t, effectiveOctave);
                                            vl = chip2Result[0] / len;
                                            vr = chip2Result[1] / len;
                                        }
                                        break;
                                    case 20: // OV vox
                                        vl = vox.charCodeAt(Math.floor(phaseL * Math.pow(2, 2/12) / 55 * 258) % vox.length) / (2**12) - 8;
                                        vr = vox.charCodeAt(Math.floor(phaseR * Math.pow(2, 2/12) / 55 * 258) % vox.length) / (2**12) - 8;
                                        break;
                                    case 21: // OV airy
                                        vl = airy.charCodeAt(Math.floor(phaseL * Math.pow(2, 2/12) / 55 * 258) % airy.length) / (2**12) - 8;
                                        vr = airy.charCodeAt(Math.floor(phaseR * Math.pow(2, 2/12) / 55 * 258) % airy.length) / (2**12) - 8;
                                        break;
                                    case 22: // OV voxpad
                                        vl = voxpad.charCodeAt(Math.floor(phaseL * Math.pow(2, 2/12) / 55 * 258) % voxpad.length) / (2**12) - 8;
                                        vr = voxpad.charCodeAt(Math.floor(phaseR * Math.pow(2, 2/12) / 55 * 258) % voxpad.length) / (2**12) - 8;
                                        break;
                                    case 23: // OV pulse
                                        vl = Math.max(Math.min(Math.tan(phaseL/128*Math.PI)/10,1),-1);
                                        vr = Math.max(Math.min(Math.tan(phaseR/128*Math.PI)/10,1),-1);
                                        break;
                                    case 24: // OV damped saw
                                        vl = Math.sin(phaseL/64*Math.PI+Math.sin(phaseL/64*Math.PI)/1.75+Math.sin(phaseL/64*Math.PI*2)/3);
                                        vr = Math.sin(phaseR/64*Math.PI+Math.sin(phaseR/64*Math.PI)/1.75+Math.sin(phaseR/64*Math.PI*2)/3);
                                        break;
                                    case 25: // OV damped square
                                        vl = Math.sin(-phaseL/128*Math.PI+Math.sin(-phaseL/64*Math.PI)/1.75+Math.sin(-phaseL/64*Math.PI*2)/3);
                                        vr = Math.sin(-phaseR/128*Math.PI+Math.sin(-phaseR/64*Math.PI)/1.75+Math.sin(-phaseR/64*Math.PI*2)/3);
                                        break;
                                    case 26: // OV damped triangle
                                        vl = -Math.sin(phaseL/128*Math.PI+Math.sin((phaseL+64)/64*Math.PI)/4);
                                        vr = -Math.sin(phaseR/128*Math.PI+Math.sin((phaseR+64)/64*Math.PI)/4);
                                        break;
                                    case 27: // OV curvation
                                        vl = -Math.sin(phaseL/128*Math.PI+Math.sin((phaseL+64)/64*Math.PI)/2);
                                        vr = -Math.sin(phaseR/128*Math.PI+Math.sin((phaseR+64)/64*Math.PI)/2);
                                        break;
                                    case 28: // OV circular
                                        vl = -Math.sin(Math.sin(phaseL/128*Math.PI))*1.19;
                                        vr = -Math.sin(Math.sin(phaseR/128*Math.PI))*1.19;
                                        break;
                                    case 29: // OV distored saw
                                        vl = Math.max(Math.min(Math.tan(phaseL/128*Math.PI),1),-1);
                                        vr = Math.max(Math.min(Math.tan(phaseR/128*Math.PI),1),-1);
                                        break;
                                    case 30: // this.thing
                                        vl=((3*phaseL&t>>8)-((5+2*(1&-t>>17))*phaseL>>1&t>>7)&255)/128-1
                                        vr=((3*phaseR&t>>8)-((5+2*(1&-t>>17))*phaseR>>1&t>>7)&255)/128-1;
                                        break;
                                    case 31: //and
                                        vl=((phaseL+128&t>>8&255)-t/512%128)/128-1
                                        vr=((phaseR+128&t>>8&255)-t/512%128)/128-1
                                        break;
                                    case 32: //xor
                                        vl=((phaseL+128^t>>8)&255)/128-1
                                        vr=((phaseR+128^t>>8)&255)/128-1
                                        break;
                                    case 33:
                                        vl=(((phaseL+128|t>>8)&255)-t/512%128)/128-1
                                        vr=(((phaseR+128|t>>8)&255)-t/512%128)/128-1
                                        break;
                                    case 34: // distorted saw (saturated)
                                        vl= Math.tanh(((phaseL + 128) / 64) % 4 - 2)
                                        vr= Math.tanh(((phaseR + 128) / 64) % 4 - 2)
                                        break;
                                    default: // fallback to sine
                                        vl = -Math.sin(phaseL / 128 * Math.PI);
                                        vr = -Math.sin(phaseR / 128 * Math.PI);
                                }

                                // Apply distortion and volume and store in oscOutputs arrays
                                const distortedVL = vl + (oscOVDistort > 0 ? waveShaper(vl) * oscOVDistort * 2 : 0);
                                const distortedVR = vr + (oscOVDistort > 0 ? waveShaper(vr) * oscOVDistort * 2 : 0);

                                // voiceNormalization per osc configuration
                                let voiceNormalization = 1;
                                if (oscConfig.voiceMix === 1) {
                                    voiceNormalization = 1 / (oscConfig.voices || oscVoiceCount);
                                } else if (oscConfig.voiceMix === 2) {
                                    voiceNormalization = 1 / Math.sqrt(oscConfig.voices || oscVoiceCount);
                                }

                                SynthState.oscOutputsL[oscIndex][k] = distortedVL * oscVolume * voiceNormalization;
                                SynthState.oscOutputsR[oscIndex][k] = distortedVR * oscVolume * voiceNormalization;

                                // Decide whether to add to voiceMixes now (skip if this osc participates in ring modulation)
                                let isOSCInRingMod = false;
                                for (let srcOsc = 0; srcOsc < config.oscCount; srcOsc++) {
                                    for (let tgtOsc = 0; tgtOsc < config.oscCount; tgtOsc++) {
                                        if (ringMatrix[srcOsc + 1] && ringMatrix[srcOsc + 1][tgtOsc + 1]) {
                                            if (srcOsc === oscIndex || tgtOsc === oscIndex) {
                                                isOSCInRingMod = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (isOSCInRingMod) break;
                                }

                                if (!isOSCInRingMod) {
                                    // Add directly to voice mix
                                    SynthState.voiceMixes[k].L += SynthState.oscOutputsL[oscIndex][k];
                                    SynthState.voiceMixes[k].R += SynthState.oscOutputsR[oscIndex][k];
                                }
                            } // voiceIndex
                        } // masterSlot
                    } // noteIndex
                } // oscIndex

                // Save prev clocks for next sample
                for (let oscIndex = 0; oscIndex < config.oscCount; oscIndex++) {
                    SynthState.prevOscPhaseClock[oscIndex] = SynthState.oscPhaseClock[oscIndex].slice();
                    SynthState.prevOscPhaseFull[oscIndex] = SynthState.oscPhaseFull[oscIndex].slice();
                }

                // Apply ring modulation using the same global index mapping
                // For each note, masterSlot and voiceIndex, compute ring contributions
                for (let noteIndex = 0; noteIndex < len; noteIndex++) {
                    for (let masterSlot = 0; masterSlot < masterVoices; masterSlot++) {
                        // iterate voice index up to the maximum voice count across oscillators
                        for (let voiceIndex = 0; voiceIndex < maxOscVoiceCount; voiceIndex++) {
                            let ringL = 0, ringR = 0, ringCount = 0;

                            for (let srcOsc = 0; srcOsc < config.oscCount; srcOsc++) {
                                for (let tgtOsc = 0; tgtOsc < config.oscCount; tgtOsc++) {
                                    if (ringMatrix[srcOsc + 1] && ringMatrix[srcOsc + 1][tgtOsc + 1]) {
                                        const srcOscVoices = oscVoiceCounts[srcOsc] || 0;
                                        const tgtOscVoices = oscVoiceCounts[tgtOsc] || 0;
                                        // only apply if both oscillators actually have this voice index
                                        if (voiceIndex < srcOscVoices && voiceIndex < tgtOscVoices) {
                                            const srcK = getGlobalIndex(srcOsc, noteIndex, masterSlot, voiceIndex);
                                            const tgtK = getGlobalIndex(tgtOsc, noteIndex, masterSlot, voiceIndex);
                                            const srcL = SynthState.oscOutputsL[srcOsc][srcK] || 0;
                                            const srcR = SynthState.oscOutputsR[srcOsc][srcK] || 0;
                                            const tgtL = SynthState.oscOutputsL[tgtOsc][tgtK] || 0;
                                            const tgtR = SynthState.oscOutputsR[tgtOsc][tgtK] || 0;

                                            ringL += srcL * tgtL;
                                            ringR += srcR * tgtR;
                                            ringCount++;
                                        }
                                    }
                                }
                            }

                            if (ringCount > 0) {
                                const ringResultL = ringL / Math.sqrt(ringCount);
                                const ringResultR = ringR / Math.sqrt(ringCount);

                                // Mix into existing voiceMixes (scaled)
                                // We must add to the correct global slot(s) — pick a representative target index:
                                // Since ring produced between multiple oscillators, add to the voiceMix index for the first involved osc
                                // We'll just update the one that matches the first srcOsc that exists for this voice
                                // Find any k index to apply the ring mix to (prefer the first enabled osc)
                                let applied = false;
                                for (let oscIndex = 0; oscIndex < config.oscCount && !applied; oscIndex++) {
                                    if (!isOSCEnabled(oscIndex + 1)) continue;
                                    const oscVoices = oscVoiceCounts[oscIndex] || 0;
                                    if (voiceIndex < oscVoices) {
                                        const k = getGlobalIndex(oscIndex, noteIndex, masterSlot, voiceIndex);
                                        if (SynthState.voiceMixes[k]) {
                                            SynthState.voiceMixes[k].L += ringResultL * 0.5;
                                            SynthState.voiceMixes[k].R += ringResultR * 0.5;
                                            applied = true;
                                        }
                                    }
                                } // if none applied (edge-case) skip
                            }
                        } // voiceIndex
                    } // masterSlot
                } // noteIndex

                // Apply master processing - optimized
                // First, collect voices by key/note to apply global distortion to OSC mix per key
                const keyMixes = new Array(len * masterVoices).fill(0).map(() => ({ L: 0, R: 0 }));
                
                // Sum voices by key (before global distortion)
                for (let k = 0; k < totalVoices; k++) {
                    const voiceMix = SynthState.voiceMixes[k];
                    if (voiceMix) {
                        // Find which key this voice belongs to
                        const keyIndex = k % (len * masterVoices);
                        keyMixes[keyIndex].L += voiceMix.L;
                        keyMixes[keyIndex].R += voiceMix.R;
                    }
                }
                
                // Apply global distortion to each key's OSC mix, then add to output
                for (let keyIndex = 0; keyIndex < keyMixes.length; keyIndex++) {
                    let keyL = keyMixes[keyIndex].L;
                    let keyR = keyMixes[keyIndex].R;
                    
                    // Apply global distortion to the mix of all OSC for this key
                    if (config.globalOVDistortVal > 0) {
                        keyL += waveShaper(keyL / 2) * config.globalOVDistortVal * 2;
                        keyR += waveShaper(keyR / 2) * config.globalOVDistortVal * 2;
                    }
                    
                    sumL += keyL * config.masterVolume * volumeNormalization;
                    sumR += keyR * config.masterVolume * volumeNormalization;
                }

                // Clear voice mixes efficiently (reset zero)
                for (let i = 0; i < SynthState.voiceMixes.length; i++) {
                    SynthState.voiceMixes[i].L = 0;
                    SynthState.voiceMixes[i].R = 0;
                }

                return [sumL / 3, sumR / 3];
            } catch (error) {
                showErrorPopup(`Error in polyFsawFromKeyboard \n ${error}`);
                return [0, 0];
            }
        }

        // Helper functions for OSC management with backwards compatibility
        function getOSCCount() {
            return parseInt(document.getElementById('oscCount')?.value || '1');
        }

        function getOSCConfig(oscNumber) {
            // For backwards compatibility: prefer per-OSC control; if missing, use OSC1 control; if still missing, use master/global
            const tryGet = (id) => document.getElementById(id);

            const pref = (id, parseFn, defaultVal) => {
                const el = tryGet(id);
                if (el) return parseFn(el.value ?? (el.checked !== undefined ? el.checked : ''));
                // fallback to osc1 (unless asking for osc1)
                if (oscNumber !== 1) {
                    const el1 = tryGet(id.replace(`osc${oscNumber}`, 'osc1'));
                    if (el1) return parseFn(el1.value ?? (el1.checked !== undefined ? el1.checked : ''));
                }
                return defaultVal;
            };

            // waveform: fallback to master synthWaveform
            const waveform = (function(){
                const el = tryGet(`osc${oscNumber}Waveform`);
                if (el) return parseInt(el.value);
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1Waveform');
                    if (el1) return parseInt(el1.value);
                }
                const masterEl = tryGet('synthWaveform');
                return masterEl ? parseInt(masterEl.value) : 2;
            })();

            const volume = pref(`osc${oscNumber}Volume`, v => parseFloat(v), 1.0);
            const octave = pref(`osc${oscNumber}Octave`, v => parseInt(v), 0);
            const detune = pref(`osc${oscNumber}Detune`, v => parseFloat(v), 0);
            const distort = pref(`osc${oscNumber}OVDistort`, v => parseFloat(v), 0);
            
            // Get voice mix setting with master fallback logic
            const voiceMix = getEffectiveVoiceMix(oscNumber);
            const enabled = (function(){
                const el = tryGet(`osc${oscNumber}Enabled`);
                if (el) return el.checked;
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1Enabled');
                    if (el1) return el1.checked;
                }
                return true;
            })();

            // cents uses existing helper but prefer osc1 if this doesn't exist
            const cents = (function(){
                const el = tryGet(`osc${oscNumber}Cents`);
                if (el) return parseFloat(el.value);
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1Cents');
                    if (el1) return parseFloat(el1.value);
                }
                return getMasterCents();
            })();

            // LFO controls: rate, amount, enabled
            const lfoRateEl = tryGet(`osc${oscNumber}LFORate`);
            const lfoAmountEl = tryGet(`osc${oscNumber}LFOAmount`);
            const lfoEnableEl = tryGet(`osc${oscNumber}LFOEnable`);

            const lfoRate = (function(){
                if (lfoRateEl) return parseFloat(lfoRateEl.value);
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1LFORate'); if (el1) return parseFloat(el1.value);
                }
                // fallback master defaults by osc parity
                return (oscNumber % 2 === 1) ? 1.60 : 2.21;
            })();

            const lfoAmount = (function(){
                if (lfoAmountEl) return parseFloat(lfoAmountEl.value);
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1LFOAmount'); if (el1) return parseFloat(el1.value);
                }
                return (oscNumber % 2 === 1) ? 0.03 : -0.03;
            })();

            const lfoEnabled = (function(){
                if (lfoEnableEl) return !!lfoEnableEl.checked;
                if (oscNumber !== 1) {
                    const el1 = tryGet('osc1LFOEnable'); if (el1) return !!el1.checked;
                }
                return false;
            })();

            const voices = getOSCVoiceCount(oscNumber);
            
            return { waveform, volume, octave, detune, distort, voiceMix, enabled, cents, lfoRate, lfoAmount, lfoEnabled, voices };
        }

        function isOSCEnabled(oscNumber) {
            const enabledEl = document.getElementById(`osc${oscNumber}Enabled`);
            return enabledEl ? enabledEl.checked : true;
        }

        function getOSCVoiceCount(oscNumber) {
            // For backwards compatibility: if no per-OSC voice count, use global synthVoices
            const voiceCountEl = document.getElementById(`osc${oscNumber}VoiceCount`);
            if (voiceCountEl) {
                return parseInt(voiceCountEl.value);
            }
            // fallback to global voice count
            return parseInt(document.getElementById('synthVoices')?.value || '1');
        }

        function getGlobalOVDistort() {
            // For backwards compatibility: use old OVDistort if globalOVDistort doesn't exist
            const globalEl = document.getElementById('globalOVDistort');
            const oldEl = document.getElementById('OVDistort');
            return parseFloat(globalEl?.value || oldEl?.value || '0');
        }

        function getMasterVolume() {
            return parseFloat(document.getElementById('synthVolume')?.value || '0.5');
        }

        function getMasterOctave() {
            return parseInt(document.getElementById('synthOctave')?.value || '0');
        }

        function getMasterDetune() {
            return parseFloat(document.getElementById('synthDetune')?.value || '0.02');
        }

        function getMasterCents() {
            return parseFloat(document.getElementById('synthCents')?.value || '0');
        }

        function getMasterVoiceMix() {
            return parseInt(document.getElementById('globalVoiceMix')?.value || '2'); // 2 = root default
        }

        function getEffectiveVoiceMix(oscNumber) {
            const oscElement = document.getElementById(`osc${oscNumber}VoiceMix`);
            const masterElement = document.getElementById('globalVoiceMix');
            
            if (!oscElement || !masterElement) {
                return 2; // Default to root
            }
            
            const oscValue = parseInt(oscElement.value || '2');
            const masterValue = parseInt(masterElement.value || '2');
            
            // If OSC is set to default (2=root), use master setting
            // If OSC is explicitly set to something else, use that
            // Special case: if master is also 2, both default to root
            if (oscValue === 2) {
                return masterValue === 2 ? 2 : masterValue;
            }
            return oscValue;
        }

        function updateVoiceCountSliderLabels() {
            const masterVoices = parseInt(document.getElementById('synthVoices')?.value || '1');
            
            for (let i = 1; i <= 6; i++) {
                const slider = document.getElementById(`osc${i}VoiceCount`);
                const label = document.querySelector(`label[for="osc${i}VoiceCount"]`);
                
                if (slider && label) {
                    const sliderValue = parseInt(slider.value || '1');
                    const isDefault = sliderValue === masterVoices;
                    
                    // Update label to show if using default or custom value
                    if (isDefault) {
                        label.innerHTML = `OSC ${i} Voice Count: <span style="color: #5ac8fa">(using master: ${masterVoices})</span>`;
                    } else {
                        label.innerHTML = `OSC ${i} Voice Count: <span style="color: #ffaa00">(custom: ${sliderValue})</span>`;
                    }
                }
            }
        }

        function initializeVoiceMixControls() {
            const masterElement = document.getElementById('globalVoiceMix');
            if (!masterElement) return;
            
            // Set all OSC voice mix controls to default (2=root) so they follow master
            for (let i = 1; i <= 6; i++) {
                const oscElement = document.getElementById(`osc${i}VoiceMix`);
                if (oscElement) {
                    oscElement.value = '2'; // Default to root to follow master
                }
            }
            
            // Add event listener to master control to update OSC controls when needed
            masterElement.addEventListener('change', () => {
                // When master changes, update all OSC controls that are set to default (2=root)
                const masterValue = masterElement.value;
                for (let i = 1; i <= 6; i++) {
                    const oscElement = document.getElementById(`osc${i}VoiceMix`);
                    if (oscElement && oscElement.value === '2') {
                        // Only update OSC controls that are still set to default
                        oscElement.value = masterValue;
                    }
                }
                updateURLParams(); // Update URL with new master setting
                updateVoiceCountSummary(); // Refresh the voice count display
            });
            
            // Add event listeners to individual OSC controls to detect when user changes them manually
            for (let i = 1; i <= 6; i++) {
                const oscElement = document.getElementById(`osc${i}VoiceMix`);
                if (oscElement) {
                    oscElement.addEventListener('change', () => {
                        updateURLParams(); // Update URL when OSC voice mix changes
                        updateVoiceCountSummary(); // Refresh the voice count display
                    });
                }
            }
        }

        function updateVoiceCountSummary() {
            const summaryElement = document.getElementById('voiceCountSummary');
            if (!summaryElement) return;

            const oscCount = parseInt(document.getElementById('oscCount')?.value || '1');
            const masterVoices = parseInt(document.getElementById('synthVoices')?.value || '1');
            const masterVoiceMix = document.getElementById('globalVoiceMix')?.value || '2';
            
            let oscSummary = 'OSC Voices: ';
            let oscMixSummary = 'OSC Mix: ';
            let totalOSCVoices = 0;
            let totalEffectiveVoices = 0;
            
            for (let i = 1; i <= oscCount; i++) {
                const oscVoices = parseInt(document.getElementById(`osc${i}VoiceCount`)?.value || masterVoices);
                const oscVoiceMix = getEffectiveVoiceMix(i);
                const effectiveVoices = oscVoices * masterVoices;
                oscSummary += `OSC${i}:${oscVoices} `;
                oscMixSummary += `OSC${i}:${['Flat', 'Linear', 'Root'][oscVoiceMix]} `;
                totalOSCVoices += oscVoices;
                totalEffectiveVoices += effectiveVoices;
            }
            
            // Calculate final total voices (sum of all OSC voices * master voices)
            const finalTotalVoices = totalOSCVoices * masterVoices;
            const masterMixName = ['Flat (None)', 'Linear (1/n)', 'Root (√n)'][masterVoiceMix];
            
            // Calculate expected normalization for Root (√n) mix
            const maxEffectiveVoices = Math.max(...Array.from({length: oscCount}, (_, i) => {
                const oscVoices = parseInt(document.getElementById(`osc${i+1}VoiceCount`)?.value || masterVoices);
                return oscVoices * masterVoices;
            }));
            const expectedRootNormalization = maxEffectiveVoices > 0 ? (1 / Math.sqrt(maxEffectiveVoices)).toFixed(3) : '1.000';
            
            summaryElement.innerHTML = `
                ${oscSummary}<br>
                Master Voices: ${masterVoices}<br>
                Master Voice Mix: ${masterMixName}<br>
                ${oscMixSummary}<br>
                Total OSC Voices: ${totalOSCVoices}<br>
                Total Effective Voices: ${totalEffectiveVoices}<br>
                <strong>Final Total Voices: ${finalTotalVoices}</strong><br>
                Expected Root Normalization: ${expectedRootNormalization}<br>
                <small>Calculation: (${oscSummary}) × Master (${masterVoices}) = ${finalTotalVoices} total voices</small>
            `;
        }

        function getOSCCents(oscNumber) {
            const centsEl = document.getElementById(`osc${oscNumber}Cents`);
            return centsEl ? parseFloat(centsEl.value) : 0;
        }


                function customWaveform(y, t, p) {
                    const sampleRate = 44100;
                    const invHz = Math.PI / sampleRate;
                    const mod = y;
                    const x = p

                    const rate1 = 1.60;
                    const rate2 = 2.21;

                    const s1 = Math.sin(t * rate1 * invHz);
                    const s2 = -Math.sin(t * rate2 * invHz);

                    const o1 = x + s1 * 1.4e4 * mod * 0.003 / rate1;
                    const o2 = x * 2 ** (0.1/12) + s2 * 1.4e4 * mod * 0.003 / rate2;

                    const tri1 = Math.sin(o1/128*Math.PI+Math.sin((o1+64)/64*Math.PI)/2);
                    const tri2 = Math.sin(o2/128*Math.PI+Math.sin((o2+64)/64*Math.PI)/4);

                    return (tri1+tri2)
                }

        // === chorus state & reset ===
        const zCho = {};

        // === reverb state & reset ===
        const zRev = {};

        function resetSynthState() {
            // reset reverb
            for (const k in zRev) {
                delete zRev[k];
            }

            // reset chorus
            for (const k in zCho) {
                delete zCho[k];
            }

            // reset Power filter states
            Power._lpState1L = 0;
            Power._lpState2L = 0;
            Power._lpState1R = 0;
            Power._lpState2R = 0;
        }

        // reverb effect (recallable, with 12dB/oct filter)
        function reverb(input, key, opts = {}) {
            const gain = opts.gain ?? 0.995;
            const amountComb = opts.amountComb ?? 7;
            const valComb = opts.valComb ?? 8600;
            const subComb = opts.subComb ?? 750;
            const amountAP = opts.amountAP ?? 3;
            const valAP = opts.valAP ?? 1500;
            const subAP = opts.subAP ?? 200;
            const reverbVolume = opts.reverbVolume ?? 1;
            const inputVolume = opts.inputVolume ?? -1;

            const filterType = opts.filterType ?? 0; // 0=none, 1=LP, 2=HP, 3=BP
            const filterFreq = opts.filterFreq ?? 0.05; // 0..1 smoothing factor

            // --- init state ---
            if (!zRev[key]) {
                const state = {
                    output: [],
                    inputAP: [],
                    outputAP: [],
                    // filter memory for 2-pole filters
                    lp1: 0,
                    lp2: 0,
                    hp1: 0,
                    hp2: 0,
                    bp: 0,
                    hp1Prev: 0,
                    hp2Prev: 0
                };

                for (let i = 0; i < amountComb; i++) {
                    state.output.push(new Array(valComb - subComb * i).fill(0));
                }
                for (let i = 0; i < amountAP; i++) {
                    state.inputAP.push(new Array(valAP - subAP * i).fill(0));
                    state.outputAP.push(new Array(valAP - subAP * i).fill(0));
                }

                zRev[key] = state;
            }

            const s = zRev[key];

            // --- comb filters ---
            for (let i = 0; i < amountComb; i++) {
                const buf = s.output[i];
                const old = buf.shift();
                buf.push(input - gain * old);
            }

            // combine combs
            let combOut = 0;
            for (let i = 0; i < amountComb; i++) {
                const buf = s.output[i];
                combOut += buf[buf.length - 1];
            }
            combOut /= amountComb;

            // --- all-pass filters ---
            let apOut = combOut;
            for (let i = 0; i < amountAP; i++) {
                const inBuf = s.inputAP[i];
                const outBuf = s.outputAP[i];

                inBuf.shift();
                inBuf.push(apOut);

                outBuf.shift();
                const y = -gain * inBuf[inBuf.length - 1] + inBuf[0] + gain * outBuf[0];
                outBuf.push(y);

                apOut = y;
            }

            // --- filter stage 12dB/oct ---
            let filtered = apOut;
            if (filterType === 1) {
                // 2-pole low-pass (~12dB/oct)
                s.lp1 += filterFreq * (apOut - s.lp1);
                s.lp2 += filterFreq * (s.lp1 - s.lp2);
                filtered = s.lp2;
            } else if (filterType === 2) {
                // 2-pole high-pass (~12dB/oct)
                s.hp1 = (1-filterFreq) * (s.hp1 + apOut - (s.hp1Prev ?? 0));
                s.hp1Prev = apOut;
                s.hp2 = (1-filterFreq) * (s.hp2 + s.hp1 - (s.hp2Prev ?? 0));
                s.hp2Prev = s.hp1;
                filtered = s.hp2;
            } else if (filterType === 3) {
                // band-pass (unchanged)
                s.lp1 += filterFreq * (apOut - s.lp1);
                s.hp2 = apOut - s.lp1;
                s.bp += filterFreq * s.hp2;
                filtered = s.bp;
            }

            return input * inputVolume + filtered * reverbVolume;
        }

        // interpolation helper
        function readBufferLinear(buf, idxFloat) {
            const N = buf.length;
            let i0 = Math.floor(idxFloat);
            let frac = idxFloat - i0;
            i0 = (i0 + N) % N;
            const i1 = (i0 + 1) % N;
            return buf[i0] * (1 - frac) + buf[i1] * frac;
        }

        // chorus effect (used only inside Power)
        function chorus(input, key, opts = {}) {
            const depth = opts.depth ?? 1;          
            const feedback = opts.feedback ?? 0;    
            const maxx = opts.maxx ?? 1024;         
            const voices = opts.voices ?? 8;        
            const rate = opts.rate ?? 0.0000075;    
            const mix = opts.mix ?? 0.5;            

            if (!zCho[key]) {
                zCho[key] = {
                    buffer: new Float32Array(maxx).fill(0),
                    idx: 0,
                    t: 0
                };
            }

            const s = zCho[key];
            let out = input;

            for (let v = 0; v < voices; v++) {
                const phase = v * v;
                const lfo = (Math.sin(s.t * rate + phase) * 0.5 + 0.5) * depth;
                const delay = Math.floor(lfo * (maxx - 2)) + 1;

                let readIdx = s.idx - delay;
                if (readIdx < 0) readIdx += s.buffer.length;
                const delayed = readBufferLinear(s.buffer, readIdx);

                out += delayed;
            }

            // feedback
            s.buffer[s.idx] = input + (out - input) / voices * feedback;

            // advance
            s.idx = (s.idx + 1) % s.buffer.length;
            s.t++;

            return input * (1 - mix) + (out) * mix;
        }

        // === main Power function ===
        function Power(y, tt, iitt, t) {
            const PI = Math.PI;
            const dtA = 1 / 256;
            const deClickAttack = Math.min(t / 10000, 1);

            const w = t => Math.max(Math.min(Math.acos(Math.sin(-t * PI * 2 + Math.asin(Math.sin(-t * PI * 2)) / 3)) / PI * 4 - 2, 1), -1);
            const v = t => Math.sin((t % 1) * 5 - 2.5) + Math.max(Math.min(Math.tan(t * PI + PI / 2) / 100, 2), -2);

            let sumL = 0, sumR = 0;
            const m = 8;
            y /= 2;

            for (let i = 0; i < m; i++) {
                const detuneL = Math.sin(i);
                const detuneR = Math.sin(-i);

                const baseL1 = y / 128 * (1 + detuneL * dtA) + detuneL * 1e10;
                const baseL2 = y / 256 * (1 + detuneL * dtA) + detuneL * 1e10;
                const baseL3 = y / 512 * (1 + detuneL * dtA) + detuneL * 1e10;

                const baseR1 = y / 128 * (1 + detuneR * dtA) + detuneR * 1e10;
                const baseR2 = y / 256 * (1 + detuneR * dtA) + detuneR * 1e10;
                const baseR3 = y / 512 * (1 + detuneR * dtA) + detuneR * 1e10;

                sumL += v(baseL1) + v(baseL2) + w(baseL2)*2 + w(baseL3)*2;
                sumR += v(baseR1) + v(baseR2) + w(baseR2)*2 + w(baseR3)*2;
            }

            sumL /= m;
            sumR /= m;

            // --- smoothing filter (low-pass) ---
            if (Power._lpState1L === undefined) Power._lpState1L = 0;
            if (Power._lpState2L === undefined) Power._lpState2L = 0;
            if (Power._lpState1R === undefined) Power._lpState1R = 0;
            if (Power._lpState2R === undefined) Power._lpState2R = 0;

            const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
            const absT = Math.abs(t / sampleRate * PI / 6 % 2 - 1);
            const cutoff = Math.min((absT + 0.4) ** 2, 1 - 1e-5) / tt;
            let r = 0.5;
            r += r / (1 - cutoff);

            let lp1L = Power._lpState1L + cutoff * (sumL - Power._lpState1L + (Power._lpState1L - Power._lpState2L) * r);
            let lp2L = Power._lpState2L + cutoff * (lp1L - Power._lpState2L);
            Power._lpState1L = lp1L;
            Power._lpState2L = lp2L;

            let lp1R = Power._lpState1R + cutoff * (sumR - Power._lpState1R + (Power._lpState1R - Power._lpState2R) * r);
            let lp2R = Power._lpState2R + cutoff * (lp1R - Power._lpState2R);
            Power._lpState1R = lp1R;
            Power._lpState2R = lp2R;

            const chorusOpts = {
                depth: 1,
                feedback: 0,
                maxx: 2048,
                voices: 8,
                rate: 0.000005,
                mix: 1
            };

            // stable keys for left/right
            const leftKey = `Power_${iitt}_L`;
            const rightKey = `Power_${iitt}_R`;

            // apply chorus
            lp2L = chorus(lp2L, leftKey, chorusOpts) - 2;
            lp2R = chorus(lp2R, rightKey, chorusOpts) - 2;

            // de-click
            lp2L *= deClickAttack;
            lp2R *= deClickAttack;

            // ✅ return stereo output
            return [lp2L, lp2R];
        }

        // global cache
        const phasedStates = {};
        function getPhasedState(voiceIndex, noteIndex) {
            const key = `${voiceIndex}_${noteIndex}`;
            if (!phasedStates[key]) {
                phasedStates[key] = { L: {}, R: {} };
            }
            return phasedStates[key];
        }


        function createPhaserState(stages = 4) {
            return Array.from({ length: stages }, () => ({ p1: 0, p2: 0, p3: 0, p4: 0 }));
        }



        function Phaser(input, ag = 0, res = 0, stages = 4, state) {
            // Initialize per channel states properly
            if (!state.ap) {
                state.ap = [];
                state.fb = 0; // Feedback state for prob fb
                for (let i = 0; i < stages; i++) {
                state.ap.push({ p1: 0, p2: 0, p3: 0, p4: 0 });
                }
            }

            let x = input + state.fb * res; // Add feedback from previous output
            const a = Math.max(Math.min(1-ag, 1), 0);

            for (let i = 0; i < stages; i++) {
                const s = state.ap[i];

                // Standard all-pass chain
                const y1 = -a * x + s.p1 + a * s.p2;
                s.p1 = x;
                s.p2 = y1;

                const y2 = -a * y1 + s.p3 + a * s.p4;
                s.p3 = y1;
                s.p4 = y2;

                x = y2;
            }

            // Store output for feedback
            state.fb = x;

            return (input+x)/2; // isolated phaser output
        }

        function Phased(y, t, itt, state) {
            // LFO controlling the phaser depth
            let LFO = Math.acos(-Math.cos(t/44100*2*Math.PI/8)) / Math.PI *.7+.25

            // Spread for multiple voices
            let fL = 0, fR = 0;
            const m = 4;
            const sqrtM = Math.sqrt(m)*2;

            for (let k=0; k<m; k++) {
                const detuneL = Math.sqrt(k*2) / (sqrtM*2);
                const detuneR = Math.sqrt(k*2 + 1) / (sqrtM*2);
                fL += (y/128*(1+detuneL/64)+detuneL*1e10)%2-1;
                fR += (y/128*(1+detuneR/64)+detuneR*1e10)%2-1;
            }
            // fL /= m;
            // fR /= m;

            fL+=y/128%2-1
            fR+=y/128%2-1

            // Now apply phaser to the actual waveform
            const phasedL = Phaser(fL, LFO**2, 0.23, 6, state.L);
            const phasedR = Phaser(fR, LFO**2, 0.23, 6, state.R);

            return [phasedL, phasedR];
        }

        // Chip-style arpeggiator synth
        function Chip(pitchesArr, detuneL = 0, detuneR = 0, detuneAmount=0.02, voices = 1, t = 0, octShift) {
            if (pitchesArr.length === 0) return [0, 0];

            const arr = [...pitchesArr].sort((a, b) => a - b);

            const mod = (x,y) => x-Math.floor(x/y)*y

            const spt = t / 44100 * 32;  // step index
            const stepIndex = Math.floor(spt) % arr.length;
            const pitch = 2 ** ((arr[stepIndex] - 64.73) / 12 + octShift - 7); // MIDI→Hz ratio

            // Envelope decay inside step
            const spDec = (1 - (spt % 1)) ** 0.5;

            let outL = 0, outR = 0;

            const phaseL = t * pitch * (1 + detuneL * detuneAmount) + detuneL*1e10;
            const phaseR = t * pitch * (1 + detuneR * detuneAmount) + detuneR*1e10;

            const waveL = (mod(phaseL,2)-1)*spDec;
            const waveR = (mod(phaseR,2)-1)*spDec;

            outL += waveL * spDec;
            outR += waveR * spDec;

            return [outL, outR];
        }

        // Another Chip-style arpeggiator synth
        function Chip2(pitchesArr, detuneL = 0, detuneR = 0, detuneAmount = 0.02, voices = 1, t = 0, octShift = 0) {
            if (pitchesArr.length === 0) return [0, 0];

            // Sort pitches for consistency
            const arr = [...pitchesArr].sort((a, b) => a - b);

            // BPM sync (140 bpm default)
            const bpm = 140;
            const BPMnorm = bpm / 44100 * 256 * t;

            const step = (BPMnorm >> 13);   // step index
            const step8 = step & 7;         // 0..7

            const noteIndex = ((step % 8 / 5 | 0) + (step / 8 | 0) * 2) % arr.length | 0;
            const pitch = 2 ** ((arr[noteIndex] - 64.73) / 12 + octShift - 8); // MIDI→Hz ratio

            // --- pitch-map functions ---
            const pitchFuncs = [
                (y,tt)=> y * 2 % 2 - 1, // base
                (y,tt,nphase)=> (y*2+((Math.min(tt/2**13%1,.25)*11)**2)*(y-nphase)/tt*256+y*2*((tt/2**13%1*4|0)?1:0))%2-1, // slide
                (y,tt)=> y * 4 % 2 - 1,  // +1 octave
                (y,tt)=> y * 4 % 2 - 1,
                (y,tt)=> y % 2 - 1, // -1 octave
                (y,tt)=> y * 2 % 2 - 1, // base
                (y,tt)=> y * 2 % 2 - 1,
                (y,tt)=> y * 2 % 2 - 1
            ];

            // --- envelopes per step ---
            const envs = [
                BPMnorm/2**14 % 1,
                BPMnorm/2**14 % 1,
                BPMnorm/2**13 % 1,
                BPMnorm/2**13 % 1,
                BPMnorm/2**13 % 1,
                BPMnorm/2**14 % 1 - .5,
                BPMnorm/2**14 % 1 + .5,
                BPMnorm/2**13 % 1
            ];
            detuneL=Math.abs(detuneL)
            detuneR=Math.abs(detuneR)

            // Phase calculation
            const phaseL = t * pitch * (1 + detuneL * detuneAmount) + detuneL * 1e11;
            const phaseR = t * pitch * (1 + detuneR * detuneAmount) + detuneR * 1e10;

            const waveL = pitchFuncs[step8](phaseL, BPMnorm, detuneL * 1e11);
            const waveR = pitchFuncs[step8](phaseR, BPMnorm, detuneR * 1e10);

            const env = 1 - envs[step8];

            return [waveL * env, waveR * env];
        }

        // === synth with reverb (simplified) ===
        function Robotsaw(y, t, itt) {
            // --- basic oscillator ---
            const osc = (f) => (f*2%2-1) + Math.max(Math.min(Math.tan(f%1 * Math.PI + Math.PI / 2) / 100, 2), -2);
            y/=256

            // --- voice stacking with small detune ---
            let sumL = 0, sumR = 0;
            const voices = 4;
            const dta = 0.001
            for (let i = 0; i < voices; i++) {
                const detune = Math.sin(i);
                sumL += osc(y * (1 + detune*dta)+detune*1e6);
                sumR += osc(y * (1 - detune*dta)+detune*1e5);
            }
            sumL /= voices;
            sumR /= voices;

            // --- reusable reverb options ---
            const revOpts = {
                gain: 0.5,
                amountComb: 1,
                valComb: 8600,
                subComb: 750,
                amountAP: 3,
                valAP: 1500,
                subAP: 200,
                reverbVolume: 4,
                inputVolume: 1,
                filterType: 2,   // 0 = none, 1 = LP, 2 = HP, 3 = BP
                filterFreq: 0.075 // normalized 0..1 smoothing factor
            };

            // --- apply reverb ---
            sumL = reverb(sumL, `Robot_${itt}_L`, revOpts);
            sumR = reverb(sumR, `Robot_${itt}_R`, revOpts);

            // --- de-click attack ---
            const deClick = Math.min(t / 2000, 1);
            return [sumL * deClick, sumR * deClick];
        }

        // Modified processAudio function to use the synth
        function processAudio(buffer) {
            try {
                if (!loadedAudioBuffer) {
                    showErrorPopup('Please select a Modular audio file.',true);
                    return;
                }

                // Check if Synth is enabled
                const synthEnabled = document.getElementById('enableSynth')?.checked || false;
                
                if (!synthEnabled && !loadedCarrierBuffer) {
                    showErrorPopup('Please select a carrier audio file or enable Synth.',true);
                    return;
                }

                const iterations = parseInt(document.getElementById('iterations').value);
                if (iterations < 1) {
                    showErrorPopup('Please enter a valid number of iterations.',true);
                    return;
                }

                // Carrier determines total length
                const carrierDuration = loadedCarrierBuffer.length / loadedCarrierBuffer.sampleRate;
                const targetLength = Math.ceil(carrierDuration * buffer.sampleRate);

                // Resize input to carrier duration
                if (!synthEnabled) {
                    buffer = createLoopedBuffer(buffer, targetLength);
                }

                // Set up analyser (for live vis)
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                const bufferLength = analyser.frequencyBinCount;
                const frequencyData = new Float32Array(bufferLength);

                source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(analyser);
                analyser.connect(audioContext.destination);

                // Offline render context length = carrier length
                const offlineContext = new OfflineAudioContext(
                    2,
                    loadedCarrierBuffer.length,
                    loadedCarrierBuffer.sampleRate
                );

                let offlineSource = offlineContext.createBufferSource();
                offlineSource.buffer = buffer;

                const offlineAnalyser = offlineContext.createAnalyser();
                offlineAnalyser.fftSize = 2048;
                const offlineFrequencyData = new Uint8Array(offlineAnalyser.frequencyBinCount);

                offlineSource.connect(offlineAnalyser);
                offlineAnalyser.connect(offlineContext.destination);

                offlineSource.start();
                offlineContext.startRendering().then(function(renderedBuffer) {

                    let carrierLeft  = loadedCarrierBuffer.getChannelData(0);
                    let carrierRight = loadedCarrierBuffer.numberOfChannels > 1
                        ? loadedCarrierBuffer.getChannelData(1)
                        : loadedCarrierBuffer.getChannelData(0);

                    let inputLeft, inputRight;
                    if (synthEnabled) {
                        showProcessPOP_UP('Rendering synth... this will take a second', true);

                        // synth must fill to carrier length
                        const length = loadedCarrierBuffer.length;
                        inputLeft  = new Float32Array(length);
                        inputRight = new Float32Array(length);
                        SR = audioCtx.sampleRate

                        const voices   = synthOptimizer.cacheDOMValues().masterVoices;
                        const SRfix    = parseFloat(document.getElementById('SRfix').value)
                        resetSynthState()
                        const synthOBJ = {}

                        for (let i = 0; i < length; i++) {
                            const synthSample = polyFsawFromKeyboard(
                                voices,
                                synthState.heldNotes,
                                getMasterOctave(),  // Use master octave from new system
                                getMasterDetune(),  // Use master detune from new system
                                2, // Default waveform (will be overridden by individual OSC settings)
                                i,  // normalize to 44.1k reference
                                synthOBJ, //Use shared synth state
                                SR * SRfix
                            );
                            inputLeft[i]  = synthSample[0];
                            inputRight[i] = synthSample[1];
                        }
                    } else {
                        // looped input is already adjusted to carrier duration
                        inputLeft  = renderedBuffer.getChannelData(0);
                        inputRight = renderedBuffer.numberOfChannels > 1
                            ? renderedBuffer.getChannelData(1)
                            : renderedBuffer.getChannelData(0);
                    }

                    // process iterations — now both input + carrier aligned
                    processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer);
                
                    // Enable buttons
                    document.getElementById('playButton').disabled = false;
                    document.getElementById('pauseButton').disabled = false;
                    document.getElementById('stopButton').disabled = false;
                    document.getElementById('downloadButton').disabled = false;
                    document.getElementById('reprocessButton').disabled = false;

                    //visualize(offlineAnalyser, offlineFrequencyData);
                    showProcessPOP_UP('', false);
                }).catch(function(error) {
                    console.error('Error during offline rendering:', error);
                    showErrorPopup('An error occurred during audio processing: ' + error.message);
                    document.getElementById('playButton').disabled = true;
                    document.getElementById('pauseButton').disabled = true;
                    document.getElementById('stopButton').disabled = true;
                    document.getElementById('downloadButton').disabled = true;
                    showProcessPOP_UP_WL('', false); // Hide any pop-ups
                });


            } catch (error) {
                console.error('Error in processAudio:', error);
                showErrorPopup('An unexpected error occurred during audio processing setup: ' + error.message);
                document.getElementById('playButton').disabled = true;
                document.getElementById('pauseButton').disabled = true;
                document.getElementById('stopButton').disabled = true;
                document.getElementById('downloadButton').disabled = true;
                showProcessPOP_UP_WL('', false); // Hide any pop-ups
            }
        }

        async function processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer) {
            await new Promise(resolve => setTimeout(resolve, 20));
            if (iterations >= 2) {
                if (iterations == 69) {
                    showProcessPOP_UP_WL(`nice, 1/${iterations}`, true, true, 1 / iterations * 100);
                } else {
                    showProcessPOP_UP_WL(`Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done) \n1/${iterations} iterations`, true, true, 1 / iterations * 100);
                }
            } else {
                showProcessPOP_UP_WL('Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done)', true);
            }
            for (let i = 0; i < iterations; i++) {
                try {
                    if (iterations >= 2) {
                        if (iterations == 69) {
                            showProcessPOP_UP_WL(`nice, ${i + 1}/${iterations}`, true, true, (i + 1) / iterations * 100);
                        } else {
                            showProcessPOP_UP_WL(`Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done) \n${i + 1}/${iterations} iterations`, true, true, i / iterations * 100);
                        }
                    } else {
                        showProcessPOP_UP_WL('Processing vocoder... this will take a while (website is frozen so you can do anything until it\'s done)', true);
                    }

                    // Pause for 10ms (adjust as needed)
                    await new Promise(resolve => setTimeout(resolve, 10));
                    const SynthOnly = document.getElementById('SynthOnly')?.checked || false;
                        if (!SynthOnly) {
                            if (Vmode == 0) {
                                processedBuffer = applyFFTLogic(
                                    offlineContext,
                                    inputLeft,
                                    inputRight,
                                    carrierLeft,
                                    carrierRight,
                                    buffer.sampleRate
                                );
                            } else if (Vmode == 1) {
                                processedBuffer = applyAnalogLogic(
                                    offlineContext,
                                    inputLeft,
                                    inputRight,
                                    carrierLeft,
                                    carrierRight,
                                    buffer.sampleRate
                                );
                            } else if (Vmode == 2) {
                                processedBuffer = apply4ormLogic(
                                    offlineContext,
                                    inputLeft,
                                    inputRight,
                                    carrierLeft,
                                    carrierRight,
                                    buffer.sampleRate
                                );
                            } else if (Vmode == 3) {
                                processedBuffer = applySomeExperimentsLogic(
                                    offlineContext,
                                    inputLeft,
                                    inputRight,
                                    carrierLeft,
                                    carrierRight,
                                    buffer.sampleRate
                                );
                            }
                        } else {
                            // for debugging synth
                            const outputBuffer = offlineContext.createBuffer(2, inputLeft.length, buffer.sampleRate);
                            const outL = outputBuffer.getChannelData(0);
                            const outR = outputBuffer.getChannelData(1);
                            for (let t = 0; t < inputLeft.length; t++) {
                                // Simple passthrough (debug): copy input directly
                                const valL = inputLeft[t] || 0;  
                                const valR = inputRight[t] || 0;

                                outL[t] = valL;
                                outR[t] = valR;
                            }

                            processedBuffer = outputBuffer;
                        }


                        // For all modes, update input and carrier for next iteration
                        inputLeft = processedBuffer.getChannelData(0);
                        inputRight = processedBuffer.numberOfChannels > 1
                            ? processedBuffer.getChannelData(1)
                            : processedBuffer.getChannelData(0);

                        carrierLeft = inputLeft;
                        carrierRight = inputRight;
                } catch (error) {
                    showErrorPopup(`An error occurred during processing iteration ${i + 1}: ${error.message}. Processing stopped.`);
                    showProcessPOP_UP_WL('', false); // Hide any pop-ups
                    break; // Stop further iterations
                }
            }

                soundgoodizerVal = parseFloat(document.getElementById('SoundGoodizer').value);
                // apply SoundGoodizer (MBC) at end of each iteration

                if (soundgoodizerVal > 0) {
                    for (let t = 0; t < inputLeft.length; t++) {
                        inputLeft[t]  = SoundGoodizer(inputLeft[t], soundgoodizerVal, 0);
                        inputRight[t] = SoundGoodizer(inputRight[t], soundgoodizerVal, 1);

                        carrierLeft = inputLeft;
                        carrierRight = inputRight;
                    }
                }

            // Hide popup when done
            showProcessPOP_UP_WL('', false);
        }

        function apply4ormLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            try {
                const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
                const outL = outputBuffer.getChannelData(0);
                const outR = outputBuffer.getChannelData(1);

                // UI Parameters
                const ag = parseFloat(document.getElementById('Ag')?.value || 0.1);
                const res = parseFloat(document.getElementById('Resonance4orm')?.value || 0.999);
                const useArrLength = document.getElementById('UseArrLength')?.checked;
                const maxHarmonics = parseInt(document.getElementById('MaxHarm')?.value || 100);
                const harmExpr = document.getElementById('Harmonics')?.value || '[0,2,3,7].map(i => 2**(i/12))';
                const volume = parseFloat(document.getElementById('4ormVolume')?.value || 1.0);
                const _4ormFilterType = parseInt(document.getElementById('4ormFilterType')?.value || 0);
                const decayType = parseInt(document.getElementById('DecayType')?.value || 0);
                const HZ = context.sampleRate

                // Parse harmonic array
                let harmonics;
                try {
                    harmonics = eval(harmExpr);
                    if (!Array.isArray(harmonics)) throw 'Not an array';
                } catch (e) {
                    console.warn("Failed to evaluate harmonics expression, using default. Error:", e);
                    harmonics = [0, 2, 3, 7].map(i => 2 ** (i / 12));
                }

                // Clamp and slice harmonics to MaxHarm
                const harmonicList = harmonics;

                // Use array length as number of stages or default to 8
                const stages = useArrLength ? harmonicList.length : maxHarmonics;

                // Clear previous state
                z9 = [];
                z10 = [];
                z11 = []

                z5_4 = [];

                function peak(a, decayF, call) {
                    z5_4[call] ??= { var1: 0 };
                    z5_4[call].var1 = Math.max(Math.abs(a), z5_4[call].var1 - Math.sqrt(decayF) / 2);
                    return z5_4[call].var1 / 3;
                }
                function rms(a, decayF, call) {
                    z5_4[call] ??= { var1: 0 };
                    z5_4[call].var1 = (1 - decayF) * z5_4[call].var1 + decayF * a * a;
                    return Math.sqrt(z5_4[call].var1);
                }

                // Helper function: Repeats & wraps harmonic array with scaled octave down
                function repeatArr(inp, i) {
                    return inp[i % inp.length] * 2 ** (-Math.floor(i / inp.length));
                }

                // Local filter function (special purpose)
                function $ap(inputY, ag = 0, res = 0, callCount = 0) {
                    if (callCount >= z9.length || !z9[callCount]?.ap?.[0]) {
                        z9[callCount] = {
                            ap: Array.from({ length: 1 }, () => ({ p1: 0, p2: 0, p3: 0, p4: 0, pi: 0 }))
                        };
                    }

                    const state = z9[callCount].ap;
                    const nres = 1 - res;
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const a = Math.min(Math.max(1 - (ag * ag / 4), 0), 0.9999);
                    const s = state[0]; // Assuming only one stage per callCount

                    const input = inputY - s.pi * mr;

                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input;
                    s.p2 = y1;

                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;

                    s.pi = -y2;

                    return (s.pi + input);
                }

                function $lp(d, c, r = 0, callCount = 0) {
                    if (!z10[callCount]) {
                        z10[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                    }

                    const z = z10[callCount];
                    let cc = Math.min(Math.max(c, 0), 0.9999);
                    const fbv = r + r / (1 - cc);
                    z.lp[0] += cc * (d - z.lp[0] + fbv * (z.lp[0] - z.fp[0]));
                    z.fp[0] += cc * (z.lp[0] - z.fp[0]);
                    return z.fp[0];
                }

                function $bp(d, c, r = 0, callCount = 0) {
                    if (!z11[callCount]) {
                        z11[callCount] = { lp: new Array(1).fill(0), fp: new Array(1).fill(0) };
                    }

                    const z = z11[callCount];
                    let cc = Math.min(Math.max(c, 0), 0.9999);
                    const fbv = r + r / (1 - cc);
                    z.lp[0] += cc * (d - z.lp[0] + fbv * (z.lp[0] - z.fp[0]));
                    z.fp[0] += cc * (z.lp[0] - z.fp[0]);
                    return (z.fp[0] - z.lp[0]);
                }

                let tt = 0;
                const PWMwidth = parseFloat(document.getElementById('PWMwidth')?.value || 0.5);
                function generator(p, inp) {
                    const gen_type = parseInt(document.getElementById('gen_type')?.value || 0);
                    let wave = null;
                    switch (gen_type) {
                        case 0: // input 2
                            wave = (t) => inp;
                            break;
                        case 1: // Sine wave
                            wave = (t) => Math.sin(2 * Math.PI * t );
                            break;
                        case 4: // Square wave
                            wave = (t) => (t % 1 < PWMwidth ? PWMwidth-1 : PWMwidth);
                            break;
                        case 3: // Sawtooth wave
                            wave = (t) => (t * 2 % 2) - 1;
                            break;
                        case 2: // Triangle wave
                            wave = (t) => Math.abs((t % 1)*2-1) * 2 - 1;
                            break;
                        case 5: // Noise
                            wave = (t) => Math.random() * 2 - 1;
                            break;
                        default:
                            wave = (t) => Math.sin(2 * Math.PI * t);
                            break;
                    }
                    tt += 1;
                    return wave(tt*p/Math.PI/4);
                }
                const rel = parseFloat(document.getElementById('release')?.value || 0.0);
                const pitch = parseFloat(document.getElementById('pitch')?.value || 0.0);
                const pitchV = 2 ** (-pitch / 12);
                const resonance2 = parseFloat(document.getElementById('resonance2')?.value || 0.999);
                const $FUNC = (IP, c, r, stages, arr, call , IP2) => {
                    let F;
                    switch (_4ormFilterType) {
                        case 0: F = $lp; break;
                        case 1: F = $ap; break;
                        case 2: F = $bp; break;
                        default: F = $ap;
                    }
                    let out = 0;
                    for (let i = 0; i < stages; i++) {
                        let tt=0
                        const Fcall = call * stages*2 + i
                        const stageAg = ag * repeatArr(arr, i);
                        const dec=[rms,peak][decayType]
                        if (document.getElementById('use_gen')?.checked) {
                            const GENi = generator(stageAg/stages, IP2)*stages;
                            let GEN = 0
                            if (resonance2 == 0) {
                                GEN = GENi;
                            } else {
                                GEN = F(GENi, stageAg, resonance2, Fcall+stages)/2;
                            }


                            out += GEN*dec(Math.abs(F(IP, stageAg*pitchV, res, Fcall))/2,2**-((rel*3)**2)/400,Fcall);
                        } else {
                            // Use the input directly
                            out += F(IP, stageAg, res, Fcall);
                        }
                    }
                    return out/stages;
                }
                // Apply processing
                for (let t = 0; t < inputLeft.length; t++) {
                    const inL = carrierLeft[t];
                    const inR = carrierRight[t];

                    const inCL = inputLeft[t];
                    const inCR = inputRight[t];

                    //const $FUNC = [$lp, $ap, $bp][_4ormFilterType];

                    const valL = $FUNC(inL*volume, ag, res, stages, harmonicList, 0, inCL) / 8;
                    const valR = $FUNC(inR*volume, ag, res, stages, harmonicList, 1, inCR) / 8;

                    outL[t] = valL;
                    outR[t] = valR;
                }

                return outputBuffer;
            } catch (error) {
                console.error("Error in apply4ormLogic:", error);
                // Return an empty buffer or the original buffer to prevent crash
                return context.createBuffer(2, inputLeft.length, sampleRate);
            }
        }

        function applySomeExperimentsLogic(context, carrierLeft, carrierRight, inputLeft, inputRight, sampleRate) {
            try {
                const len = inputLeft.length;
                const buffer = context.createBuffer(2, len, sampleRate);
                const outL = buffer.getChannelData(0);
                const outR = buffer.getChannelData(1);

                const mode = +document.getElementById('expMode')?.value || 0;
                const ff   = +document.getElementById('expFF')?.value || 32;
                const res  = +document.getElementById('expRes')?.value || 0.9;
                const freq = +document.getElementById('expFreq')?.value || 440;
                const SR   = +document.getElementById('expBaseFreq')?.value || 48000;
                const decayType = +document.getElementById('DecayType')?.value || 0;
                const rel  = +document.getElementById('release')?.value || 0.0;

                // --- envelope helpers ---
                const z = [];
                const rms  = (a,d,i)=>(z[i]??={v:0},z[i].v=(1-d)*z[i].v+d*a*a,Math.sqrt(z[i].v));
                const peak = (a,d,i)=>(z[i]??={v:0},z[i].v=Math.max(a,z[i].v-Math.sqrt(d)/2),z[i].v/3);
                const dec  = [rms, peak][decayType];

                // --- state factory ---
                const createState = () => ({
                    flp:Array(ff).fill(0), fbp:Array(ff).fill(0),
                    alp:Array(ff).fill(0), abp:Array(ff).fill(0),
                    env:Array(ff).fill(0), phase:Array(ff).fill(0)
                });

                const stateL = createState();
                const stateR = createState();

                function process(s, mod, car) {
                    let out = 0;

                    for (let i = 0; i < ff; i++) {
                        const g = (i + 1) / ff;
                        const R = res;

                        // --- analysis ---
                        let hp = (mod - s.alp[i] - (1 - R) * s.abp[i]) / (1 + g * g);
                        s.abp[i] += g * hp;
                        s.alp[i] += g * s.abp[i];
                        s.env[i] = dec(Math.abs(s.abp[i]) * 0.5, 2 ** -((rel * 3) ** 2) / 400, i);

                        // --- resynthesis ---
                        switch (mode) {
                            case 0: // classic
                                hp = (car - s.flp[i] - (1 - R) * s.fbp[i]) / (1 + g * g);
                                s.fbp[i] += g * hp;
                                s.flp[i] += g * s.fbp[i];
                                out += s.fbp[i] * s.env[i];
                                break;

                            case 1: // chaotic drift
                                s.phase[i] += i + 1;
                                const cg = (Math.sin(s.phase[i] / 100000 / ff * 32) + 1) * 0.5 * g + 0.002;
                                hp = (car - s.flp[i] - (1 - R) * s.fbp[i]) / (1 + cg * cg);
                                s.fbp[i] += cg * hp;
                                s.flp[i] += cg * s.fbp[i];
                                out += s.fbp[i] * s.env[i];
                                break;

                            case 2: // nonlinear osc
                                s.fbp[i] += i * 0.1 + s.env[i] * 0.05;
                                s.fbp[i] += Math.sin(s.fbp[i] * 0.001 + i) * s.env[i] * 0.5;
                                out += Math.sin(s.fbp[i]) * s.env[i];
                                break;

                            case 3: // bitwise
                                s.fbp[i] += (s.abp[i] + 1) * (i + 1) / SR * freq;
                                out += ((s.fbp[i] & (s.env[i] * 8)) - (s.env[i] * 8 | 0) / 2) * 0.05;
                                break;

                            case 4:
                                s.fbp[i] += (s.abp[i] + 1) * (2 ** i) / SR * freq;
                                out += ((s.fbp[i] & (s.env[i] * 8)) - (s.env[i] * 8 | 0) / 2) * 0.05;
                                break;

                            case 5: // rectified logic
                                hp = (car - s.flp[i] - (1 - R) * s.fbp[i]) / (1 + g * g);
                                s.fbp[i] += g * hp;
                                s.flp[i] += g * s.fbp[i];
                                out += (Math.abs(s.fbp[i]) * 15 & s.env[i] * 15) * Math.sign(s.fbp[i]) * 0.025;
                                break;
                        }
                    }
                    return out / ff * 16;
                }

                for (let t = 0; t < len; t++) {
                    outL[t] = process(stateL, inputLeft[t],  carrierLeft[t]);
                    outR[t] = process(stateR, inputRight[t], carrierRight[t]);
                }

                return buffer;
            } catch (e) {
                console.error(e);
                return context.createBuffer(2, inputLeft.length, sampleRate);
            }
        }


        const clamp=(minn,maxx,value)=>Math.min(Math.max(value,minn),maxx)

        function studyAnalogFilters() {
            let z2S=[{lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0}]
            let z3S=[{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}]
            let z4S=[{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}]
            let z8S=[{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}]
            let z7S=[{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
            let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))}]
            let zEcoS = [{buffer:[],idx:0,buffer2:[],idx1:0,lastOut:0}]
            let zBPFFTS = [{ N: 0, buf: [], re: [], im: [], out: [], overlap: [], t: 0, ready: 0, outIndex: 0 }]
            let BPTCsvfStates = [{ stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))}]

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2S[callCount]) {
                    z2S[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2S[callCount].lp6 += cc * (f - z2S[callCount].lp6 + fbv * (z2S[callCount].lp6 - z2S[callCount].lp12));
                z2S[callCount].lp12 += cc * (z2S[callCount].lp6 - z2S[callCount].lp12);
                z2S[callCount].lp18 += cc * (z2S[callCount].lp12 - z2S[callCount].lp18);
                z2S[callCount].lp24 += cc * (z2S[callCount].lp18 - z2S[callCount].lp24);
                z2S[callCount].lp30 += cc * (z2S[callCount].lp24 - z2S[callCount].lp30);
                z2S[callCount].lp36 += cc * (z2S[callCount].lp30 - z2S[callCount].lp36);
                z2S[callCount].lp42 += cc * (z2S[callCount].lp36 - z2S[callCount].lp42);
                z2S[callCount].lp48 += cc * (z2S[callCount].lp42 - z2S[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2S[callCount].lp6;
                    case 2:  return z2S[callCount].lp12;
                    case 3:  return z2S[callCount].lp18;
                    case 4:  return z2S[callCount].lp24;
                    case 5:  return z2S[callCount].lp30;
                    case 6:  return z2S[callCount].lp36;
                    case 7:  return z2S[callCount].lp42;
                    case 8:  return z2S[callCount].lp48;
                    default: return z2S[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3S[callCount]) {
                    z3S[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3S[callCount].hp6 += cc * (f - z3S[callCount].hp6 + fbv * (z3S[callCount].hp6 - z3S[callCount].hp12));
                z3S[callCount].hp12 += cc * (z3S[callCount].hp6 - z3S[callCount].hp12);
                x = f - ((dbv >= 2) ? z3S[callCount].hp12 : z3S[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3S[callCount].hp18 += cc * (x - z3S[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3S[callCount].hp24 += cc * (x - z3S[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3S[callCount].hp30 += cc * (x - z3S[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3S[callCount].hp36 += cc * (x - z3S[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3S[callCount].hp42 += cc * (x - z3S[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3S[callCount].hp48 += cc * (x - z3S[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.5, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (callCount >= z4S.length) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4S[callCount].bp1 += cc * (f - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2));
                    z4S[callCount].bp2 += cc * (z4S[callCount].bp1 - z4S[callCount].bp2);
                    z4S[callCount].bp3 += cc * (z4S[callCount].bp2 - z4S[callCount].bp3);
                    z4S[callCount].bp4 += cc * (z4S[callCount].bp3 - z4S[callCount].bp4);
                    z4S[callCount].bp5 += cc * (z4S[callCount].bp4 - z4S[callCount].bp5);
                    z4S[callCount].bp6 += cc * (z4S[callCount].bp5 - z4S[callCount].bp6);
                    z4S[callCount].bp7 += cc * (z4S[callCount].bp6 - z4S[callCount].bp7);
                    z4S[callCount].bp8 += cc * (z4S[callCount].bp7 - z4S[callCount].bp8);
                    z4S[callCount].bp9 += cc * (z4S[callCount].bp8 - z4S[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4S[callCount].bp1 - z4S[callCount].bp2; break;
                        case 2: out = z4S[callCount].bp2 - z4S[callCount].bp3; break;
                        case 3: out = z4S[callCount].bp3 - z4S[callCount].bp4; break;
                        case 4: out = z4S[callCount].bp4 - z4S[callCount].bp5; break;
                        case 5: out = z4S[callCount].bp5 - z4S[callCount].bp6; break;
                        case 6: out = z4S[callCount].bp6 - z4S[callCount].bp7; break;
                        case 7: out = z4S[callCount].bp7 - z4S[callCount].bp8; break;
                        case 8: out = z4S[callCount].bp8 - z4S[callCount].bp9; break;
                        default: out = z4S[callCount].bp2 - z4S[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w=1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4S[callCount].bp3 += clamp(-1, 1, f - z4S[callCount].bp3) * cc;
                            z4S[callCount].bp1 += clamp(-1, 1, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4S[callCount].bp3 += clamp(-cc, cc, f - z4S[callCount].bp3);
                            z4S[callCount].bp1 += clamp(-cc, cc, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)));
                            break;
                    }
                    z4S[callCount].bp2 += clamp(-1, 1, z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    //z4S[callCount].bp3 += (f - z4S[callCount].bp3) * cc * (4 + cc * 1) / 5;
                    z4S[callCount].bp1 += (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)) * cc;
                    z4S[callCount].bp2 += (z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1 - z4S[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/32 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (callCount >= z7S.length) {
                        z7S.push({
                            p1: 0, p2: 0, p3: 0, p4: 0,
                            p5: 0, p6: 0, p7: 0, p8: 0,
                            pi: 0
                        });


                    }
                    const s = z7S[callCount];

                    const nres = 1 - res;
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const a = clamp(0, 0.9999, 1 - (ag*ag / 4));

                    const input = inputY - s.pi * mr;
                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input ;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;
                

                    s.pi = -y2;  // You can choose [y2, y4] for smoother vs sharper

                    callCount++;
                    return (y2+input)/64*(1+ag*8);
                } catch (e) {
                    throw e;
                }
            }

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });


                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPCS[callCount];
                
                    let f=d
                    // First stage
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);

                    f = (st.bp2 - st.bp1) * (1-r**2) / (1-cc)  * 1.25; // bp result from this stage
                    o = f;

                    // Cascade through remaining stages
                    for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);

                            f = (st.bp2 - st.bp1) * (1-r**2) / (1-cc) * 1.25; 
                            o = f;
                    }

                    return o / (1-(stages-1)/16) / (1+cc)// Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPCS[callCount]) {
                        zBPCS.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });


                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r

                    const s = zBPCS[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)
                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc)
                        f*=1-fb
                        o=f
                    }

                    return o*(.25+cc*4)*8 // Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            TBP = (input, depth = 1, feedback = 0.5, callCount, smooth = 1, maxx = 1024) => {
                if (!zEcoS[callCount]) {
                    zEcoS[callCount] = { 
                        buffer: [], 
                        idx: 0,
                        buffer2: [],
                        idx1: 0,
                        lastOut: 0   // store previous output for damper
                    };
                }
                const s = zEcoS[callCount];

                // main modulated buffer
                if (s.buffer.length !== maxx) {
                    s.buffer = new Array(maxx).fill(0);
                    s.idx = 0;
                }

                // second buffer for delayed input
                if (s.buffer2.length !== maxx) {
                    s.buffer2 = new Array(maxx).fill(0);
                    s.idx1 = 0;
                }

                // ---- Flanger modulated delay ----
                const lfo = (1/(depth*maxx/Math.PI)) * maxx;
                const delaySamples = 1 + Math.floor(lfo); 
                let readIdx = (s.idx - delaySamples + s.buffer.length) % s.buffer.length;
                let delayed = s.buffer[readIdx] || 0;
                feedback=(feedback*3+feedback**((delaySamples-4)/4))/4

                // write input + feedback into mod buffer
                s.buffer[s.idx] = input - delayed * feedback;
                s.idx = (s.idx + 1) % s.buffer.length;

                // ---- Fixed delay line ----
                let delayed2 = s.buffer2[s.idx1] || 0;
                s.buffer2[s.idx1] = input;

                // ---- Mix signals ----
                let rawOut = (delayed * (1 + feedback) - delayed2);

                // ---- Damper only if smooth === true ----
                let out;
                if (smooth) {
                    damp=1/(delaySamples-1)
                    out = rawOut * (damp) + s.lastOut * (1-damp);
                    s.lastOut = out;
                } else {
                    out = rawOut;
                }
                return out;
            }

            bpFFT = (sig, freq, q, db, call) => {
                try {
                    if (!zBPFFTS[call]) {
                        while (zBPFFTS.length <= call) {
                            zBPFFTS.push({ N: 0, buf: [], re: [], im: [], out: [], overlap: [], t: 0, ready: 0, outIndex: 0 });
                        }
                    }
                    let s = zBPFFTS[call];

                    // -------- FFT / IFFT --------
                    const fft = (re, im) => {
                        let N = re.length, j = 0;
                        for (let i = 0; i < N; i++) {
                            if (i < j) { [re[i], re[j]] = [re[j], re[i]]; [im[i], im[j]] = [im[j], im[i]]; }
                            let m = N >> 1;
                            while (j >= m && m > 0) { j -= m; m >>= 1; }
                            j += m;
                        }
                        for (let len = 2; len <= N; len <<= 1) {
                            let ang = -2 * Math.PI / len, wlenRe = Math.cos(ang), wlenIm = Math.sin(ang);
                            for (let i = 0; i < N; i += len) {
                                let wRe = 1, wIm = 0;
                                for (let k = 0; k < len / 2; k++) {
                                    let uRe = re[i + k], uIm = im[i + k],
                                        vRe = re[i + k + len / 2] * wRe - im[i + k + len / 2] * wIm,
                                        vIm = re[i + k + len / 2] * wIm + im[i + k + len / 2] * wRe;
                                    re[i + k] = uRe + vRe;
                                    im[i + k] = uIm + vIm;
                                    re[i + k + len / 2] = uRe - vRe;
                                    im[i + k + len / 2] = uIm - vIm;
                                    let tmp = wRe * wlenRe - wIm * wlenIm;
                                    wIm = wRe * wlenIm + wIm * wlenRe;
                                    wRe = tmp;
                                }
                            }
                        }
                    };

                    const ifft = (re, im) => {
                        let N = re.length;
                        for (let i = 0; i < N; i++) im[i] = -im[i]; // conjugate
                        fft(re, im);
                        for (let i = 0; i < N; i++) { re[i] /= N; im[i] = -im[i] / N; } // proper conjugate restoration
                        return re;
                    };

                    if (!s.N) {
                        s.N = 1024;
                        s.hop = s.N / 4;
                        s.buf = new Array(s.N).fill(0);
                        s.re = new Array(s.N).fill(0);
                        s.im = new Array(s.N).fill(0);
                        s.out = new Array(s.hop).fill(0);
                        s.overlap = new Array(s.N).fill(0); // Fixed: proper overlap buffer size
                    }

                    // push new sample
                    let t = s.t;
                    s.buf[t % s.N] = sig;

                    // Band-pass gain shaping function with db controlling window size
                    const filter = (x, f, q, db) => {
                        if (f <= 0) return 0; // avoid division by zero
                        const exWindow = Math.max(2, 8 * Math.abs(db-1)); // ensure positive window
                        const ratio = x / f;
                        const numerator = Math.abs(ratio) / q;
                        const denominator = Math.sqrt(Math.pow(1 - ratio * ratio, exWindow) + (ratio * ratio) / (q * q));
                        return denominator > 0 ? (numerator / denominator) * q / Math.max(1, exWindow/2) : 0;
                    }

                    // only process on hop boundary
                    if (t % s.hop === s.hop - 1) {
                        // Copy input buffer with proper indexing
                        for (let i = 0; i < s.N; i++) {
                            let idx = (t - s.N + 1 + i + s.N) % s.N; // Fixed: ensure positive modulo
                            s.re[i] = s.buf[idx];
                            s.im[i] = 0;
                        }

                        // Hann window for smooth overlap-add
                        for (let i = 0; i < s.N; i++) {
                            let win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (s.N - 1)));
                            s.re[i] *= win;
                        }

                        fft(s.re, s.im);

                        // Apply bandpass filter in frequency domain
                        const binSize = 44100 / s.N;
                        for (let k = 0; k < s.N; k++) {
                            let f = k <= s.N / 2 ? k * binSize : (k - s.N) * binSize;
                            let gain = filter(Math.abs(f), Math.abs(freq), Math.max(0.1, Math.abs(q)), Math.max(0.1, Math.abs(db)));
                            s.re[k] *= gain;
                            s.im[k] *= gain;
                        }

                        ifft(s.re, s.im);

                        // Proper overlap-add with windowing compensation
                        for (let i = 0; i < s.N; i++) {
                            s.overlap[i] += s.re[i]; // accumulate overlapping samples
                        }

                        // Output the first hop samples and shift overlap buffer
                        for (let i = 0; i < s.hop; i++) {
                            s.out[i] = s.overlap[i];
                        }
                        
                        // Shift overlap buffer left by hop samples
                        for (let i = 0; i < s.N - s.hop; i++) {
                            s.overlap[i] = s.overlap[i + s.hop];
                        }
                        
                        // Clear the end of overlap buffer
                        for (let i = s.N - s.hop; i < s.N; i++) {
                            s.overlap[i] = 0;
                        }

                        s.ready = 1;
                        s.outIndex = 0;
                    }

                    s.t++;
                    
                    // Return output sample with proper scaling
                    let output = 0;
                    if (s.ready && s.outIndex < s.hop) {
                        output = s.out[s.outIndex++] * 0.125; // Reduced scaling to prevent clipping
                    }
                    
                    return output;

                } catch (e) {
                    throw e;
                }
            };

            function BPTCsvf(inSample, freq, q = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfStates.length <= callCount) {
                        BPTCsvfStates.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfStates[callCount];

                    const OS = 3;          // oversample factor
                    let f = freq;          // scale cutoff for oversampling
                    let fb = 1 - q;        // resonance feedback

                    let bpOut = 0;

                    // Run 3x oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;

                        // First stage
                        let st = s.stage[0];
                        let hp0 = x - st.lp - fb * st.bp;
                        let bp0 = st.bp + f * hp0;
                        let lp0 = st.lp + f * bp0;
                        st.bp = bp0;
                        st.lp = lp0;

                        let stageOut = bp0 * fb * 1.25 * (1+f*8);

                        // Cascade remaining stages
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            let hp = stageOut - st.lp - fb * st.bp;
                            let bp = st.bp + f * hp;
                            let lp = st.lp + f * bp;
                            st.bp = bp;
                            st.lp = lp;
                            stageOut = bp * fb * 1.25;
                        }

                        bpOut = stageOut/stages; // keep last oversample output
                    }

                    return bpOut * 2;
                } catch (e) {
                    return 0;
                }
            }

            // makes woosh sounds
            function BPTCsvf_weird(inSample, freq, q = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfStates.length <= callCount) {
                        BPTCsvfStates.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfStates[callCount];

                    const OS = 3; // oversample factor
                    let f = Math.min(Math.max(freq, 0), 0.99999); // clamp cutoff coefficient
                    let fb = 1 - q; // resonance damping

                    let bpOut = 0;

                    // Run oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;

                        // First stage (with tanh nonlinearity at HP node)
                        let st = s.stage[0];

                        let hp0 = x - st.lp - fb * st.bp;
                        hp0 = Math.tanh(hp0 * 2) / 2; // nonlinear HP saturation

                        let bp0 = st.bp + f * hp0;
                        let lp0 = st.lp + f * bp0;

                        st.bp = bp0;
                        st.lp = lp0;

                        // You can choose what comes out of this stage:
                        //   nonlinear HP
                        //   BP (resonant band-pass)
                        //   LP (low-pass)
                        // Here I’ll mirror your svf return: emphasize hp
                        let stageOut = hp0; // + lp0 * 0.5 if you want blend

                        // Cascade remaining stages
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];

                            let hp = stageOut - st.lp - fb * st.bp;
                            hp = Math.tanh(hp * 2) / 2; // nonlinear saturation

                            let bp = st.bp + f * hp;
                            let lp = st.lp + f * bp;

                            st.bp = bp;
                            st.lp = lp;

                            stageOut = hp;
                        }

                        bpOut = stageOut; // keep last oversample output
                    }

                    return bpOut;
                } catch (e) {
                    return 0;
                }
            }

            function svfFilter(inSample, freq, res = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfStates.length <= callCount) {
                        BPTCsvfStates.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfStates[callCount];

                    const OS = 3;                            // oversample factor
                    const f = Math.min(Math.max(freq, 0), 0.99999); // clamp cutoff (normalized)
                    const q = 1 - res;                       // resonance factor

                    let out = 0;

                    // Run oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;
                        let stageOut = 0;

                        // First stage
                        let st = s.stage[0];
                        st.lp += f * st.bp;
                        let hp0 = x - st.lp - q * st.bp;
                        st.bp += f * hp0;

                        let lp0 = st.lp;
                        let bp0 = st.bp;

                        stageOut = lp0 
                        stageOut *= q

                        let lp = lp0;
                        let bp = bp0;
                        let hp = hp0;

                        // Cascade additional stages if needed
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            st.lp += f * st.bp;
                            hp = stageOut - st.lp - q * st.bp;
                            st.bp += f * hp;

                            lp = st.lp;
                            bp = st.bp;

                            stageOut = lp
                            stageOut *= q
                        }

                        out = inSample/64+bp/2
                    }

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            const canvas = document.getElementById('filterView');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get analog control values
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const resonance = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const bpwidth = parseFloat(document.getElementById('BPwidth').value);
            const altBP = parseInt(document.getElementById('Alt_BP').value) || 0;

            // Frequency range (log scale)
            const minFreq = 20, maxFreq = 20000;
            const sampleRate = 44100;
            const points = canvas.width;
            let testInput = 0;

            // Prepare for drawing
            ctx.save();
            ctx.strokeStyle = "#4af";
            ctx.lineWidth = 2;
            ctx.beginPath();

            // For each frequency, compute filter response
            // Smoothing window size (must be odd)
            const SMOOTH_WINDOW = 9;
            const halfWindow = Math.floor(SMOOTH_WINDOW / 2);
            const dbVals = [];

            // First, calculate all dB values (unsmoothed)
            for (let x = 0; x < points; x++) {
                // Logarithmic frequency mapping
                const freq = minFreq * Math.pow(maxFreq / minFreq, x / (points - 1));
                const FLTcutoff = .1;

                // Reset filter state for each frequency
                let z2S = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
                let z3S = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
                let z4S = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
                let z8S = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
                let z7S = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}]
                let zBPCS = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];
                let zEcoS = [{buffer:[],idx:0,buffer2:[],idx1:0,lastOut:0}]
                let zBPFFTS = [{ N: 0, buf: [], re: [], im: [], out: [], t: 0 }]
                let BPTCsvfStates = [{ stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))}]

                //console.log(altBP)

                // Sine wave test: run for several cycles and measure output amplitude
                const cycles = 1;
                const samplesPerCycle = Math.round(sampleRate / freq);
                const totalSamples = cycles * samplesPerCycle;
                let maxOut = 0;

                for (let t = 0; t < totalSamples; t++) {
                    const testInput = Math.sin(2 * Math.PI * freq * t / sampleRate);
                    let out = 0;
                    
                    switch (altBP) {
                        case 0:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 1:
                            out = bp2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 2:
                            out = bp3(testInput*4, FLTcutoff, resonance, db, 0);
                            break;
                        case 3:
                            out = bp4(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 4:
                            out = bp5(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 5:
                            out = ap(testInput, FLTcutoff, resonance, 0);
                            break;
                        case 6:
                            out = bpTC(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 7:
                            out = bpTC2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 8:
                            out = TBP(testInput, FLTcutoff, resonance, 0)
                            break;
                        case 9: 
                            out = bpFFT(testInput,2e4*FLTcutoff,.5+resonance**10*100,db,0)
                            break
                        case 10: 
                            out = BPTCsvf(testInput, FLTcutoff, resonance, db, 0)
                            break
                        case 11: 
                            out = BPTCsvf_weird(testInput, FLTcutoff, resonance, db, 0)
                            break
                        case 12:
                            out = svfFilter(testInput, FLTcutoff, resonance, db, 0)
                            break
                        default:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                    }
                    // Use peak amplitude (or accumulate RMS if you prefer)
                    if (t > totalSamples - samplesPerCycle) { // Only last cycle for steady-state
                        maxOut = Math.max(maxOut, Math.abs(out));
                    }
                }

                // Convert to dB
                let dbVal = 20 * Math.log10(maxOut + 1e-8);
                dbVals[x] = dbVal-20;   //it goes off grapth so i subtract it by 20
            }

            // Now, smooth the dB values using a moving average
            const smoothedDbVals = [];
            for (let x = 0; x < points; x++) {
                let sum = 0, count = 0;
                for (let k = -halfWindow; k <= halfWindow; k++) {
                    const idx = x + k;
                    if (idx >= 0 && idx < points) {
                        sum += dbVals[idx];
                        count++;
                    }
                }
                smoothedDbVals[x] = sum / count;
            }

            // Draw the smoothed graph
            for (let x = 0; x < points; x++) {
                // Normalize to canvas height (0 dB at 1/4 from top, -60 dB at bottom)
                const y = canvas.height * 0.25 + (canvas.height * 0.75) * (1 - (smoothedDbVals[x] + 60) / 60);

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            // Draw frequency grid
            ctx.save();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.font = "10px Arial";
            ctx.fillStyle = "#aaa";
            for (let f of [50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000]) {
                const x = Math.log(f / minFreq) / Math.log(maxFreq / minFreq) * (canvas.width - 1);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.fillText(f + "Hz", x + 2, canvas.height - 2);
            }
            ctx.restore();
        }

        // Draw on page load
        document.addEventListener('DOMContentLoaded', studyAnalogFilters);

        function applyAnalogLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Helper functions and state
            const min = Math.min, max = Math.max, abs = Math.abs, pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, PI = Math.PI;
            const clamp = (minn, maxx, value) => min(max(value, minn), maxx);

            let z2 = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
            let z3 = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
            let z4 = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
            let z8 = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
            let z5 = [{var1:0}];
            let z7 = [{p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0}];
            let zBPC = [{stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))}];
            let zHPC = [{stage: Array.from({ length: 8 }, () => ({ hp1: 0, hp2: 0 }))}]
            let zEco = [{buffer:[],idx:0,buffer2:[],idx1:0,lastOut:0}]
            let zBPFFT = [{ N: 0, buf: [], re: [], im: [], out: [], overlap: [], t: 0, ready: 0, outIndex: 0 }]
            let BPTCsvfState = [{ stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))}]

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2[callCount]) {
                    z2[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2[callCount].lp6 += cc * (f - z2[callCount].lp6 + fbv * (z2[callCount].lp6 - z2[callCount].lp12));
                z2[callCount].lp12 += cc * (z2[callCount].lp6 - z2[callCount].lp12);
                z2[callCount].lp18 += cc * (z2[callCount].lp12 - z2[callCount].lp18);
                z2[callCount].lp24 += cc * (z2[callCount].lp18 - z2[callCount].lp24);
                z2[callCount].lp30 += cc * (z2[callCount].lp24 - z2[callCount].lp30);
                z2[callCount].lp36 += cc * (z2[callCount].lp30 - z2[callCount].lp36);
                z2[callCount].lp42 += cc * (z2[callCount].lp36 - z2[callCount].lp42);
                z2[callCount].lp48 += cc * (z2[callCount].lp42 - z2[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2[callCount].lp6;
                    case 2:  return z2[callCount].lp12;
                    case 3:  return z2[callCount].lp18;
                    case 4:  return z2[callCount].lp24;
                    case 5:  return z2[callCount].lp30;
                    case 6:  return z2[callCount].lp36;
                    case 7:  return z2[callCount].lp42;
                    case 8:  return z2[callCount].lp48;
                    default: return z2[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3[callCount]) {
                    z3[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3[callCount].hp6 += cc * (f - z3[callCount].hp6 + fbv * (z3[callCount].hp6 - z3[callCount].hp12));
                z3[callCount].hp12 += cc * (z3[callCount].hp6 - z3[callCount].hp12);
                x = f - ((dbv >= 2) ? z3[callCount].hp12 : z3[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3[callCount].hp18 += cc * (x - z3[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3[callCount].hp24 += cc * (x - z3[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3[callCount].hp30 += cc * (x - z3[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3[callCount].hp36 += cc * (x - z3[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3[callCount].hp42 += cc * (x - z3[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3[callCount].hp48 += cc * (x - z3[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function hpTC(input, c, r = 0, stages = 2, callCount) {
                try {
                    if (!zHPC[callCount]) {
                            zHPC[callCount] = {
                                stage: Array.from({ length: 8 }, () => ({ hp1: 0, hp2: 0 }))
                            };
                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zHPC[callCount];
                    let f = input, o = 0;

                    // First stage
                    let st = s.stage[0];
                    st.hp1 += cc * (f - st.hp1 + fb * (st.hp1 - st.hp2));
                    st.hp2 += cc * (st.hp1 - st.hp2);
                    f = f - st.hp1; // HP result from this stage
                    o = f;

                    // Cascade through remaining stages
                    for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            st.hp1 += cc * (f - st.hp1 + fb * (st.hp1 - st.hp2));
                            st.hp2 += cc * (st.hp1 - st.hp2);
                            f = f - st.hp1; 
                            o = f;
                    }

                    // Output after last stage
                    return o
                } catch (e) {
                    return 0;
                }
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16 * (1+c**3*(1-dww)*200);
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);
                    z4[callCount].bp3 += cc * (z4[callCount].bp2 - z4[callCount].bp3);
                    z4[callCount].bp4 += cc * (z4[callCount].bp3 - z4[callCount].bp4);
                    z4[callCount].bp5 += cc * (z4[callCount].bp4 - z4[callCount].bp5);
                    z4[callCount].bp6 += cc * (z4[callCount].bp5 - z4[callCount].bp6);
                    z4[callCount].bp7 += cc * (z4[callCount].bp6 - z4[callCount].bp7);
                    z4[callCount].bp8 += cc * (z4[callCount].bp7 - z4[callCount].bp8);
                    z4[callCount].bp9 += cc * (z4[callCount].bp8 - z4[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4[callCount].bp1 - z4[callCount].bp2; break;
                        case 2: out = z4[callCount].bp2 - z4[callCount].bp3; break;
                        case 3: out = z4[callCount].bp3 - z4[callCount].bp4; break;
                        case 4: out = z4[callCount].bp4 - z4[callCount].bp5; break;
                        case 5: out = z4[callCount].bp5 - z4[callCount].bp6; break;
                        case 6: out = z4[callCount].bp6 - z4[callCount].bp7; break;
                        case 7: out = z4[callCount].bp7 - z4[callCount].bp8; break;
                        case 8: out = z4[callCount].bp8 - z4[callCount].bp9; break;
                        default: out = z4[callCount].bp2 - z4[callCount].bp3;
                    }

                    return out*(db**.75)/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w = 1,callCount) {
                try {
                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;
                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4[callCount].bp3 += clamp(-1, 1, f - z4[callCount].bp3) * cc;
                            z4[callCount].bp1 += clamp(-1, 1, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4[callCount].bp3 += clamp(-cc, cc, f - z4[callCount].bp3);
                            z4[callCount].bp1 += clamp(-cc, cc, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2)));
                            break;
                    }
                    z4[callCount].bp2 += clamp(-1, 1, z4[callCount].bp1 - z4[callCount].bp2) * cc;

                    out = z4[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0});
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);

                    let out=0;
                    out = z4[callCount].bp1 - z4[callCount].bp2;

                    return out/4*(1+cc*8);
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/128 * (1+c*16+c**5*(1-dww)*200);
            }

            ap = (inputY, ag = 0, res = 0, callCount = 1) => {
                try {
                    if (!z7[callCount]) {
                        z7[callCount] = {p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, p7: 0, p8: 0, pi: 0};
                    }
                    const s = z7[callCount];

                    const nres = 1 - res;
                    const mr = 1 - nres * (0.5 + nres / 2);
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);

                    const a = clamp(0, 0.9999, 1 - (ag * ag / 4));

                    const input = inputY - s.pi * mr;

                    // 1st all-pass
                    const y1 = -a * input + s.p1 + a * s.p2;
                    s.p1 = input;
                    s.p2 = y1;

                    // 2nd all-pass
                    const y2 = -a * y1 + s.p3 + a * s.p4;
                    s.p3 = y1;
                    s.p4 = y2;

                    s.pi = -y2;

                    return (y2+input)/64*(1+ag*8)
                } catch (e) {
                    throw e;
                }
            };

            bpTC = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0, hp:0 }))
                        });


                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c);
                    const fb = r + r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d
                    // First stage
                    let st = s.stage[0];
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);
                    st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                    st.bp2 += cc * (st.bp1 - st.bp2);

                    f = (st.bp2 - st.bp1) * (1-r**2) / (1-cc)  * 1.25; // bp result from this stage
                    o = f;

                    // Cascade through remaining stages
                    for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);
                            st.bp1 += cc * (f - st.bp1 + fb * (st.bp1 - st.bp2));
                            st.bp2 += cc * (st.bp1 - st.bp2);

                            f = (st.bp2 - st.bp1) * (1-r**2) / (1-cc) * 1.25; 
                            o = f;
                    }

                    return o / (1-(stages-1)/16) / (1+cc)// Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            bpTC2 = (d, c, r = 0, stages = 2, callCount) => {
                try {
                    if (!zBPC[callCount]) {
                        zBPC.push({
                            // Each stage has two state vars
                            stage: Array.from({ length: 8 }, () => ({ bp1: 0, bp2: 0 }))
                        });


                    }

                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(1e-6, 0.99, c**2);
                    const fb = r //+ r / (1 - cc);

                    const s = zBPC[callCount];
                
                    let f=d
                    let st = s.stage[0];
                    st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                    f = -st.bp2 / (cc) * (1-fb)

                    o=f

                    // Process cascade
                    for (let i = 1; i < stages; i++) {
                        let st = s.stage[i];
                        st.bp1 += st.bp2 += cc*(f-st.bp1)-st.bp2*(1-fb)
                        f = st.bp2 / (cc) * (1-fb)
                        o=f
                    }

                    return o*(.25+cc)*8// Output of last stage
                } catch (e) {
                    return 0;
                }
            }

            
            TBP = (input, depth = 1, feedback = 0.5, callCount, smooth = 1, maxx = 1024) => {
                if (!zEco[callCount]) {
                    zEco[callCount] = { 
                        buffer: [], 
                        idx: 0,
                        buffer2: [],
                        idx1: 0,
                        lastOut: 0   // store previous output for damper
                    };
                }
                const s = zEco[callCount];

                // main modulated buffer
                if (s.buffer.length !== maxx) {
                    s.buffer = new Array(maxx).fill(0);
                    s.idx = 0;
                }

                // second buffer for delayed input
                if (s.buffer2.length !== maxx) {
                    s.buffer2 = new Array(maxx).fill(0);
                    s.idx1 = 0;
                }

                // ---- Flanger modulated delay ----
                const lfo = (1/(depth*maxx/2+1)) * maxx;
                const delaySamples = 1 + Math.floor(lfo); 
                let readIdx = (s.idx - delaySamples + s.buffer.length) % s.buffer.length;
                let delayed = s.buffer[readIdx] || 0;
                feedback=(feedback*3+feedback**((delaySamples-4)/4))/4

                // write input + feedback into mod buffer
                s.buffer[s.idx] = input - delayed * feedback;
                s.idx = (s.idx + 1) % s.buffer.length;

                // ---- Fixed delay line ----
                let delayed2 = s.buffer2[s.idx1] || 0;
                s.buffer2[s.idx1] = input;

                // ---- Mix signals ----
                let rawOut = (delayed * (1 + feedback) - delayed2);

                // ---- Damper only if smooth === true ----
                let out;
                if (smooth) {
                    damp=1/(delaySamples-1)
                    out = rawOut * (damp) + s.lastOut * (1-damp);
                    s.lastOut = out;
                } else {
                    out = rawOut;
                }
                return out;
            }

            bpFFT = (sig, freq, q, db, call) => {
                try {
                    if (!zBPFFT[call]) {
                        while (zBPFFT.length <= call) {
                            zBPFFT.push({ N: 0, buf: [], re: [], im: [], out: [], overlap: [], t: 0, ready: 0, outIndex: 0 });
                        }
                    }
                    let s = zBPFFT[call];

                    // -------- FFT / IFFT --------
                    const fft = (re, im) => {
                        let N = re.length, j = 0;
                        for (let i = 0; i < N; i++) {
                            if (i < j) { [re[i], re[j]] = [re[j], re[i]]; [im[i], im[j]] = [im[j], im[i]]; }
                            let m = N >> 1;
                            while (j >= m && m > 0) { j -= m; m >>= 1; }
                            j += m;
                        }
                        for (let len = 2; len <= N; len <<= 1) {
                            let ang = -2 * Math.PI / len, wlenRe = Math.cos(ang), wlenIm = Math.sin(ang);
                            for (let i = 0; i < N; i += len) {
                                let wRe = 1, wIm = 0;
                                for (let k = 0; k < len / 2; k++) {
                                    let uRe = re[i + k], uIm = im[i + k],
                                        vRe = re[i + k + len / 2] * wRe - im[i + k + len / 2] * wIm,
                                        vIm = re[i + k + len / 2] * wIm + im[i + k + len / 2] * wRe;
                                    re[i + k] = uRe + vRe;
                                    im[i + k] = uIm + vIm;
                                    re[i + k + len / 2] = uRe - vRe;
                                    im[i + k + len / 2] = uIm - vIm;
                                    let tmp = wRe * wlenRe - wIm * wlenIm;
                                    wIm = wRe * wlenIm + wIm * wlenRe;
                                    wRe = tmp;
                                }
                            }
                        }
                    };

                    const ifft = (re, im) => {
                        let N = re.length;
                        for (let i = 0; i < N; i++) im[i] = -im[i]; // conjugate
                        fft(re, im);
                        for (let i = 0; i < N; i++) { re[i] /= N; im[i] = -im[i] / N; } // proper conjugate restoration
                        return re;
                    };

                    if (!s.N) {
                        s.N = 1024;
                        s.hop = s.N / 4;
                        s.buf = new Array(s.N).fill(0);
                        s.re = new Array(s.N).fill(0);
                        s.im = new Array(s.N).fill(0);
                        s.out = new Array(s.hop).fill(0);
                        s.overlap = new Array(s.N).fill(0); // Fixed: proper overlap buffer size
                    }

                    // push new sample
                    let t = s.t;
                    s.buf[t % s.N] = sig;

                    // Band-pass gain shaping function with db controlling window size
                    const filter = (x, f, q, db) => {
                        if (f <= 0) return 0; // avoid division by zero
                        const exWindow = Math.max(2, 8 * Math.abs(db-1)); // ensure positive window
                        const ratio = x / f;
                        const numerator = Math.abs(ratio) / q;
                        const denominator = Math.sqrt(Math.pow(1 - ratio * ratio, exWindow) + (ratio * ratio) / (q * q));
                        return denominator > 0 ? (numerator / denominator) * q / Math.max(1, exWindow/2) : 0;
                    }

                    // only process on hop boundary
                    if (t % s.hop === s.hop - 1) {
                        // Copy input buffer with proper indexing
                        for (let i = 0; i < s.N; i++) {
                            let idx = (t - s.N + 1 + i + s.N) % s.N; // Fixed: ensure positive modulo
                            s.re[i] = s.buf[idx];
                            s.im[i] = 0;
                        }

                        // Hann window for smooth overlap-add
                        for (let i = 0; i < s.N; i++) {
                            let win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (s.N - 1)));
                            s.re[i] *= win;
                        }

                        fft(s.re, s.im);

                        // Apply bandpass filter in frequency domain
                        const binSize = 44100 / s.N;
                        for (let k = 0; k < s.N; k++) {
                            let f = k <= s.N / 2 ? k * binSize : (k - s.N) * binSize;
                            let gain = filter(Math.abs(f), Math.abs(freq), Math.max(0.1, Math.abs(q)), Math.max(0.1, Math.abs(db)));
                            s.re[k] *= gain;
                            s.im[k] *= gain;
                        }

                        ifft(s.re, s.im);

                        // Proper overlap-add with windowing compensation
                        for (let i = 0; i < s.N; i++) {
                            s.overlap[i] += s.re[i]; // accumulate overlapping samples
                        }

                        // Output the first hop samples and shift overlap buffer
                        for (let i = 0; i < s.hop; i++) {
                            s.out[i] = s.overlap[i];
                        }
                        
                        // Shift overlap buffer left by hop samples
                        for (let i = 0; i < s.N - s.hop; i++) {
                            s.overlap[i] = s.overlap[i + s.hop];
                        }
                        
                        // Clear the end of overlap buffer
                        for (let i = s.N - s.hop; i < s.N; i++) {
                            s.overlap[i] = 0;
                        }

                        s.ready = 1;
                        s.outIndex = 0;
                    }

                    s.t++;
                    
                    // Return output sample with proper scaling
                    let output = 0;
                    if (s.ready && s.outIndex < s.hop) {
                        output = s.out[s.outIndex++] * 0.125 * (1+freq/2**12.5); // Reduced scaling to prevent clipping
                    }
                    
                    return output;

                } catch (e) {
                    throw e;
                }
            };

            function BPTCsvf(inSample, freq, q = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfState.length <= callCount) {
                        BPTCsvfState.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfState[callCount];

                    const OS = 3;          // oversample factor
                    let f = min(freq,1);          // scale cutoff for oversampling
                    let fb = 1 - q;        // resonance feedback

                    let bpOut = 0;

                    // Run 3x oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;

                        // First stage
                        let st = s.stage[0];
                        let hp0 = x - st.lp - fb * st.bp;
                        let bp0 = st.bp + f * hp0;
                        let lp0 = st.lp + f * bp0;
                        st.bp = bp0;
                        st.lp = lp0;

                        let stageOut = bp0 * fb * 1.25 * (1+f*8);

                        // Cascade remaining stages
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            let hp = stageOut - st.lp - fb * st.bp;
                            let bp = st.bp + f * hp;
                            let lp = st.lp + f * bp;
                            st.bp = bp;
                            st.lp = lp;
                            stageOut = bp * fb * 1.25;
                        }

                        bpOut = stageOut/stages; // keep last oversample output
                    }

                    return bpOut * 2;
                } catch (e) {
                    return 0;
                }
            }

            // makes woosh sounds
            function BPTCsvf_weird(inSample, freq, q = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfState.length <= callCount) {
                        BPTCsvfState.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfState[callCount];

                    const OS = 3; // oversample factor
                    let f = Math.min(Math.max(freq, 0), 0.99999); // clamp cutoff coefficient
                    let fb = 1 - q; // resonance damping

                    let bpOut = 0;

                    // Run oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;

                        // First stage (with tanh nonlinearity at HP node)
                        let st = s.stage[0];

                        let hp0 = x - st.lp - fb * st.bp;
                        hp0 = Math.tanh(hp0 * 2) / 2; // nonlinear HP saturation

                        let bp0 = st.bp + f * hp0;
                        let lp0 = st.lp + f * bp0;

                        st.bp = bp0;
                        st.lp = lp0;

                        // You can choose what comes out of this stage:
                        //   nonlinear HP
                        //   BP (resonant band-pass)
                        //   LP (low-pass)
                        // Here I’ll mirror your svf return: emphasize hp
                        let stageOut = hp0; // + lp0 * 0.5 if you want blend

                        // Cascade remaining stages
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];

                            let hp = stageOut - st.lp - fb * st.bp;
                            hp = Math.tanh(hp * 2) / 2; // nonlinear saturation

                            let bp = st.bp + f * hp;
                            let lp = st.lp + f * bp;

                            st.bp = bp;
                            st.lp = lp;

                            stageOut = hp;
                        }

                        bpOut = stageOut; // keep last oversample output
                    }

                    return bpOut;
                } catch (e) {
                    return 0;
                }
            }

            // "Filter"
            // this should sound similar to Magix's vocoder filters
            function svfFilter(inSample, freq, res = 0.5, stages = 2, callCount = 0) {
                try {
                    // Ensure state array is big enough
                    while (BPTCsvfState.length <= callCount) {
                        BPTCsvfState.push({
                            stage: Array.from({ length: 8 }, () => ({ lp: 0, bp: 0 }))
                        });


                    }

                    const s = BPTCsvfState[callCount];

                    const OS = 3;                            // oversample factor
                    const f = Math.min(Math.max(freq, 0), 0.99999); // clamp cutoff (normalized)
                    const q = 1 - res;                       // resonance factor

                    let out = 0;

                    // Run oversampled passes
                    for (let os = 0; os < OS; os++) {
                        let x = inSample;
                        let stageOut = 0;

                        // First stage
                        let st = s.stage[0];
                        st.lp += f * st.bp;
                        let hp0 = x - st.lp - q * st.bp;
                        st.bp += f * hp0;

                        let lp0 = st.lp;
                        let bp0 = st.bp;

                        stageOut = lp0
                        stageOut *= q

                        let lp = lp0;
                        let bp = bp0;
                        let hp = hp0;

                        // Cascade additional stages if needed
                        for (let i = 1; i < stages; i++) {
                            st = s.stage[i];
                            st.lp += f * st.bp;
                            hp = stageOut - st.lp - q * st.bp;
                            st.bp += f * hp;

                            lp = st.lp;
                            bp = st.bp;

                            stageOut = lp;
                            stageOut *= q
                        }

                        out = inSample/64+bp/2
                    }

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            // UI values
            const sel = parseInt(document.getElementById('decayType').value)-1;
            const rel = parseFloat(document.getElementById('release').value);
            const fb = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const dw = parseFloat(document.getElementById('BPwidth').value);
            const vol = parseFloat(document.getElementById('Volboost').value);
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const flip = document.getElementById('FreqFlip').checked;
            const pitch = parseFloat(document.getElementById('pitch').value);
            const decayByFreq = parseInt(document.getElementById('decayByFreq').value) || 0;
            const freqCurve = parseFloat(document.getElementById('freqCurve').value) || 0;
            const UseResBasedOnDistance = document.getElementById('UseResBasedOnDistance').checked;
            const addLPtoLowEnd = document.getElementById('addLPtoLowEnd').checked;
            const addHPtoHighEnd = document.getElementById('addHPtoHighEnd').checked;

            // Envelope followers
            function peak(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = Math.max(abs(a), z5[call].var1 - sqrt(decayF) / 2);
                return z5[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = (1 - decayF) * z5[call].var1 + decayF * a * a;
                return sqrt(z5[call].var1);
            }
            
            function bandFrequency(bands, index, sampleRate, convertToFloat = true) {
                const fmin = 20;                         // lowest frequency
                const fmax = sampleRate / 2.205;         // Nyquist-ish limit
                const ratio = Math.pow(fmax / fmin, 1 / bands); // geometric step

                // center frequency of this band
                let freq = fmin * Math.pow(ratio, index + 0.5);

                // optionally normalize to [0,1]
                if (convertToFloat) {
                    freq = freq / (sampleRate / 2);
                }
                return freq;
            }

            let modulatedValue = 1
            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
            const duration = inputLeft.length / sampleRate;

            function curve(i, nv) {
                switch (freqCurve) {
                    case 0:
                        ic = i / nv;
                        EQvol = 1;
                        distance = (i+1)/nv - i/nv;
                        break;
                    case 1:
                        ic = Math.log(i/nv+1)/Math.LOG2E;
                        EQvol = 1-ic/10;
                        distance = (Math.log((i+1)/nv+1)/Math.LOG2E) - ic;
                        break;
                    case 2:
                        ic = Math.exp(i/nv)-1;
                        EQvol = .9+ic/10;
                        distance = (Math.exp((i+1)/nv)-1) - ic;
                        break;
                    case 3:
                        ic = 2**(i/nv*8-8);
                        EQvol = 3-ic*2.5;
                        distance = 2**((i+1)/nv*8-8) - ic
                        break;
                    case 4:
                        ic = (i/nv)**2;
                        EQvol = .9+ic/10;
                        distance = ((i+1)/nv)**2 - ic;
                        break;
                    case 5:
                        ic = bandFrequency(nv,i,48000)**.5
                        EQvol = 1
                        distance = bandFrequency(nv,i+1,48000)**.5 - ic;
                        break;
                    case 6:
                        ic = 2**(i/nv*8-8);
                        EQvol = 1;
                        distance = 2**((i+1)/nv*8-8) - ic
                        break;
                    default:
                        ic = i/nv;
                        EQvol = 1;
                        distance = (i+1)/nv - ic;
                        break;
                }

                return {ic, distance, EQvol};
            }

            // Vocoder function
            function vocoder(inp, car, bool=false) {
                let relv = 0, nv = n, volv = vol, fbv = fb, dbv = db, dww = dw, selv = sel;
                let p = [rms, peak][max(min(selv, 2), 0)];
                let result = 0;
                let carrierSum = 0, modSum = 0;
                const Alt_BP=parseInt(document.getElementById('Alt_BP').value) || 0;
                let distance = 0;
                let EQvol = 1;

                for (let i = 1; i <= nv; i++) {

                    // Filter input (modulator) and carrier
                    const filter = (v, m, f = 0, dwo, FRQ) => {
                        // Flip FRQ if f flag is set
                        FRQ = f ? 1 - FRQ : FRQ;

                        if (Alt_BP === 0) {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 1) {
                            return bp2(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 2) {
                            return bp3(v * 256, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 3) {
                            return bp4(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 4) {
                            return bp5(v * 64, FRQ, fbv, dbv, dwo, m);
                        } else if (Alt_BP === 5) {
                            return ap(v * 64, FRQ, fbv, m);
                        } else if (Alt_BP === 6) {
                            return bpTC(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 7) {
                            return bpTC2(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 8) {
                            return TBP(v * 64, FRQ, fbv, m)
                        } else if (Alt_BP === 9) {
                            return bpFFT(v * 64, 2e4*FRQ, .5+fbv**2*100, dbv, m)
                        } else if (Alt_BP === 10) {
                            return BPTCsvf(v * 64, FRQ, fbv, dbv, m);
                        } else if (Alt_BP === 11) {
                            return BPTCsvf_weird(v, FRQ, fbv, dbv, m) * 32;
                        } else if (Alt_BP === 12) {
                            return svfFilter(v * 64, FRQ, fbv, dbv, m);
                        } else {
                            return bp(v * 64, FRQ, fbv, dbv, dwo, m);
                        }
                    };

                    let vol = 1;

                    // Get curve values
                    let { ic, distance, EQvol} = curve(i, nv);

                    //console.log(i, ic, distance)
                    if (UseResBasedOnDistance && (freqCurve==6 || freqCurve==5 || freqCurve==4 || freqCurve==3)) {
                        fbv = fb * (1 - distance*1.75);
                        //EQvol = 1
                    }

                    switch (decayByFreq) {
                        case 0:
                            relv = rel;
                            break;
                        case 1:
                            relv = rel + ic/4;
                            break;
                        case 2:
                            relv = rel + (1-ic)/4;
                            break;
                        default:
                            relv = rel;
                    }

                    // if (Alt_BP===6||Alt_BP===10){
                    //     ic=ic**1.5
                    // }

                    const g = ic / 2**(pitch/12);

                    const modFiltered = filter(inp, i + 0 + bool*n*3, flip, dww, g)*EQvol;
                    const carFiltered = filter(car, i + n + bool*n*3, false, dww, ic)*EQvol;

                    const absFilterX = abs(modFiltered);
                    const mod = p(absFilterX, 2**-((relv*3)**2)/400, i + bool*n*3);

                    // For debugging: sum up mod and carrier
                    //modSum += mod;
                    //carrierSum = carFiltered;
                    //combined = modFiltered/512

                    // If mod is always zero, you will only hear silence or the modular
                    const combined = mod * carFiltered * (1 - fbv) / sqrt(nv * 10) * (1 - g);
                    result += combined * volv;

                    //console.log(result, mod, carFiltered, combined, inp, car, i, nv, modulatedValue);
                }

                let LPOUT = 0
                let HPOUT = 0
                if (addLPtoLowEnd) {
                    let { ic, distance, EQvol: eqv } = curve(1, nv);

                    fbvv = UseResBasedOnDistance?fb*(1-distance*1.75):fb
                    LPC = lp(car*64, ic, fbv, 2, n*2+2 + bool*n*3);
                    LPM = lp(inp*64, ic, fbv, 2, n*2+3 + bool*n*3);

                    ABSLPC = abs(LPM);
                    LPOUT = LPC * p(ABSLPC, 2**-((rel*3)**2)/400, n*2+2)
                }

                if (addHPtoHighEnd) {
                    let { ic, distance, EQvol: eqv } = curve(nv, nv);

                    fbvv = UseResBasedOnDistance?fb*(1-distance*1.75):fb
                    HPC = hpTC(car*64, ic, fbv/2, 2, n*2+2 + bool*n*3);
                    HPM = hpTC(inp*64, ic, fbv/2, 2, n*2+3 + bool*n*3);

                    ABSHPC = abs(HPM);
                    HPOUT = HPC * p(ABSHPC, 2**-((rel*3)**2)/400, n*2+3)
                }

                let LOUT = HPOUT * volv * dbv + LPOUT * volv / 8 * dbv + result*n/2;

                // Prevent NaN/Infinity
                if (!isFinite(result) || isNaN(result)) result = 0;
                return LOUT / 128;
            }

            // Output buffer
            const bufferLen = inputLeft.length;
            const outputBuffer = context.createBuffer(2, bufferLen, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);
            // Analog vocoder processing
            for (let idx = 0; idx < bufferLen; idx++) {
                const idxL = idx % carrierLeft.length;
                const idxR = idx % carrierRight.length;
                outputLeft[idx] = vocoder(carrierLeft[idxL], inputLeft[idx], 0);
                outputRight[idx] = vocoder(carrierRight[idxR], inputRight[idx], 1);
            }

            return outputBuffer;
        }

        function applyFFTLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Add the new FFT functions for classic magnitude transfer
            function bitReverseIndexes(n){
                const rev = new Uint32Array(n); 
                const bits = Math.log2(n)|0; 
                for(let i=0;i<n;i++){ 
                    let j=0, x=i; 
                    for(let b=0;b<bits;b++){ j=(j<<1)|(x&1); x>>=1 } 
                    rev[i]=j; 
                } 
                return rev; 
            }

            const type = parseInt(document.getElementById('BR_voc_Type').value);
            const wave = (o) => {
                switch (type) {
                    case 0:
                        return sin(o);
                    case 1:
                        return asin(sin(o)) / PI * 2.25;
                    case 2:
                        return sin(sin(o) * 2) * 0.9;
                    case 3:
                        return sin(o * 2) * 0.9;
                    case 4:
                        return sin(o * 3) * 0.8;
                    case 5:
                        return o / PI & 1 ? 0.65 : -0.65;
                    case 6:
                        return ((o / PI) % 2 - 1) / 1.4;
                    case 7:
                        return sin(sin(sin(o) * 2) * 2) * 0.8;
                    case 8:
                        return sin(o / 2) * 0.9;
                    case 9:
                        return sin(o ** 2) * 0.95;
                    case 10:
                        return sin(o) ** 2;
                    case 11:
                        return (-abs(sin(o / 2)) + 0.5) * 1.7;
                    case 12:
                        return (abs(sin(o / 2 + PI / 4) ** 3) - 0.5) * 1.8;
                    case 13:
                        return sin(rand(o / 1e10) * PI) * 0.9;
                    case 14:
                        return sin(o) ** 3 * 1.15;
                    case 15:
                        return sin(o * sin(o)) / 2;
                    case 16:
                        return harm(o) * 0.8;
                    case 17:
                        return harmS(o) * 0.9;
                    case 18:
                        return sin((o * 128 / PI | o * 127 / PI) / 128 * PI);
                    case 19:
                        return sin((o * 4 / PI | 0) / 4 * PI);
                    default:
                        return sin(o);
                }
            };

            function fft_classic(re, im, useWave = false, clampWave = false){ 
                const n = re.length; 
                if(n<=1) return; 
                const rev = bitReverseIndexes(n); 
                const cre = new Float32Array(n), cim = new Float32Array(n); 
                for(let i=0;i<n;i++){ cre[i]=re[rev[i]]; cim[i]=im[rev[i]] } 
                for(let len=2; len<=n; len<<=1){ 
                    const ang = -2*Math.PI/len; 
                    let wlenRe, wlenIm;
                    
                    if(useWave) {
                        wlenRe = wave(ang + Math.PI/2);  // cos equivalent using wave
                        wlenIm = wave(ang);              // sin equivalent using wave
                        
                        // Clamp wave output between -1 and 1
                        if(clampWave) {
                            wlenRe = Math.max(-1, Math.min(1, wlenRe));
                            wlenIm = Math.max(-1, Math.min(1, wlenIm));
                        }
                    } else {
                        wlenRe = Math.cos(ang);
                        wlenIm = Math.sin(ang);
                    }
                    
                    for(let i=0;i<n;i+=len){ 
                        let ur=1, ui=0; 
                        for(let j=0;j<len/2;j++){ 
                            const evenR = cre[i+j], evenI = cim[i+j]; 
                            const oddR = cre[i+j+len/2], oddI = cim[i+j+len/2]; 
                            const tr = ur*oddR - ui*oddI; 
                            const ti = ur*oddI + ui*oddR; 
                            cre[i+j] = evenR + tr; 
                            cim[i+j] = evenI + ti; 
                            cre[i+j+len/2] = evenR - tr; 
                            cim[i+j+len/2] = evenI - ti; 
                            const tmp = ur*wlenRe - ui*wlenIm; 
                            ui = ur*wlenIm + ui*wlenRe; 
                            ur = tmp; 
                        } 
                    } 
                } 
                re.set(cre); im.set(cim); 
            }

            function ifft_classic(re, im, useWave = false, clampWave = false){ 
                // conjugate, forward fft, conjugate, divide 
                for(let i=0;i<re.length;i++) im[i] = -im[i]; 
                fft_classic(re, im, useWave, clampWave); 
                for(let i=0;i<re.length;i++){ re[i] = re[i]/re.length; im[i] = -im[i]/re.length } 
            }

            const FFTsize = document.getElementById('FFTsize').value;
            const SIZE = 2 ** FFTsize;

            const OVERLAP = 4;
            const HOP_SIZE = SIZE / OVERLAP;
            const PI = Math.PI;
            const cos = Math.cos;
            const sin = Math.sin;
            const asin = Math.asin;
            const abs = Math.abs;

            // Usage example in your X function:
            const X = o => {
                return { 
                    r: wave(o + PI / 2), 
                    i: wave(o) 
                };
            };

            const X2 = o => ({ r: cos(o), i: sin(o) }); //back up
            const M = (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + b.r * a.i });
            const A = (a, b) => ({ r: a.r + b.r, i: a.i + b.i });

            const FFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = { r: I[ii], i: 0 };
                else {
                    FFT(O, I, oi, ii, N / 2, s * 2);
                    FFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(-2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            const IFFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = I[ii];
                else {
                    IFFT(O, I, oi, ii, N / 2, s * 2);
                    IFFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            // Calculate the duration of the audio buffer
            const duration = inputLeft.length / sampleRate;

            // Create output buffer (stereo)
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);

            // Initialize buffers
            const I = Array.from({ length: SIZE }, () => 0);
            const O = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));
            const I2 = Array.from({ length: SIZE }, () => 0);
            const O2 = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));

            const pitch = parseInt(document.getElementById('pitch').value);
            const Shift = parseInt(document.getElementById('BandShift').value)
            const divbands = parseInt(document.getElementById('divbands').value);

            const DecayType = parseInt(document.getElementById('decayType').value);
            const Release = parseFloat(document.getElementById('release').value) ** (1 / (4 + (divbands - 1) * 2));
            const BassBoost = parseFloat(document.getElementById('BassBoost').value);

            const envelopeStateLeft = Array(SIZE).fill(0);
            const envelopeStateRight = Array(SIZE).fill(0);

            let ReverbStateLeft = Array(SIZE).fill(0);
            let ReverbStateRight = Array(SIZE).fill(0);

            const window = Array.from({ length: SIZE }, (_, i) =>
                0.5 * (1 - Math.cos(2 * Math.PI * i / (SIZE - 1)))
            );

            const clampOut = parseFloat(document.getElementById('clamp_output').value);
            const Threshold = parseFloat(document.getElementById('threshold').value);

            // Check if classic magnitude transfer mode is enabled
            const useClassicMagnitudeTransfer = parseInt(document.getElementById('FFTmode').value||0);

            // Process left and right channels separately
            const processChannel = (inputData, carrierData, outputData, envelopeState, ReverbState) => {
                const startTime = performance.now();
                const Break = document.getElementById('BandBreak').checked;
                const flip = document.getElementById('FreqFlip').checked

                for (let t = 0; t < inputData.length; t += HOP_SIZE) {
                    const currentTime = (performance.now() - startTime) / 1000; // Current time in seconds

                    // === CLASSIC MAGNITUDE TRANSFER MODE ===
                    if (!(useClassicMagnitudeTransfer==0)) {
                        const reM = new Float32Array(SIZE);
                        const imM = new Float32Array(SIZE);
                        const reC = new Float32Array(SIZE);
                        const imC = new Float32Array(SIZE);

                        // Fill input buffers with windowing
                        for (let i = 0; i < SIZE; i++) {
                            reC[i] = (inputData[t + i] || 0) * window[i];
                            imC[i] = 0;
                            reM[i] = (carrierData[t + i] || 0) * window[i];
                            imM[i] = 0;
                        }

                        // Perform FFT
                        const brOut = parseInt(document.getElementById('BR_out').value);
                        clampWaveOutput = 1;
                        switch (brOut) {
                            case 1:
                                fft_classic(reM, imM, true, clampWaveOutput);
                                fft_classic(reC, imC, true, clampWaveOutput);
                                break;
                            case 2:
                                fft_classic(reM, imM, true, clampWaveOutput);
                                fft_classic(reC, imC, false, false);
                                break;
                            case 3:
                                fft_classic(reM, imM, false, false);
                                fft_classic(reC, imC, true, clampWaveOutput);
                                break;
                            default:
                                fft_classic(reM, imM, false, false);
                                fft_classic(reC, imC, false, false);
                        }

                        // Use the channel-specific envelope state instead of shared static variable
                        const env = envelopeState;

                        const DecayType = parseInt(document.getElementById('decayType').value);
                        const Release   = parseFloat(document.getElementById('release').value) 
                                        ** (1 / (4 + (SIZE / 1024 - 1) * 2)); // similar scaling
                        const Ratio     = SIZE / 1024;

                        // Extract magnitude and phase
                        const magM = new Array(SIZE);
                        const phC  = new Array(SIZE);
                        const magC = new Array(SIZE);

                        for (let i = 0; i < SIZE; i++) {
                            const instMag = Math.sqrt(reM[i] * reM[i] + imM[i] * imM[i]); // modulator magnitude
                            const carrierMag = Math.sqrt(reC[i] * reC[i] + imC[i] * imC[i]); // carrier magnitude

                            // --- envelope smoothing for modulator ---
                            const REL = Math.min((1 - Release) * Ratio, 1);
                            switch (DecayType) {
                                case 1: // RMS-like smoothing
                                    env[i] = (1 - REL) * env[i] + REL * instMag * instMag;
                                    magM[i] = Math.sqrt(env[i]);
                                    break;
                                case 2: // Peak hold + exponential release
                                    env[i] = Math.max(instMag, env[i] * (1 - REL));
                                    magM[i] = env[i];
                                    break;
                                default: // raw
                                    magM[i] = instMag;
                            }

                            magC[i] = carrierMag;
                            phC[i]  = Math.atan2(imC[i], reC[i]);
                        }

                        if (useClassicMagnitudeTransfer === 1) {
                            // Mode 1: classic magnitude transfer
                            for (let i = 0; i < SIZE; i++) {
                                const outMag = magM[i];
                                const outPh  = phC[i];
                                reM[i] = outMag * Math.cos(outPh);
                                imM[i] = outMag * Math.sin(outPh);
                            }
                        } else if (useClassicMagnitudeTransfer === 2) {
                            for (let i = 0; i < SIZE; i++) {
                                const outPh = phC[i];

                                // pick a neighborhood width (e.g. 8 bins like before)
                                const step = Math.floor(5*(SIZE/1024));
                                const center = Math.floor(i / step) * step;

                                let weightedMag = 0;
                                let weightSum   = 0;

                                // Hann blend over neighborhood [center-step, center+step]
                                for (let k = -step; k <= step; k++) {
                                    const idx = center + k;
                                    if (idx < 0 || idx >= SIZE) continue;

                                    // Hann weight (cosine taper)
                                    const w = 0.5 * (1 - Math.cos(2 * Math.PI * (k + step) / (2 * step)));

                                    weightedMag += magM[idx] * w;
                                    weightSum   += w;
                                }

                                // normalize weighted magnitude
                                const smoothMagM = weightedMag / (weightSum || 1);

                                // apply your shaping
                                const mappedMag = magC[i] *
                                    Math.min(smoothMagM * (Math.sin(i / SIZE * Math.PI) ** 2.5 + 0.01) * 40 , 3*Math.sqrt(SIZE/1024)); // Rule #1: never clamp your bins (MAGIX), if you dont want it to be loud use a compressor or limiter like how Image Line did :)


                                reM[i] = mappedMag * Math.cos(outPh);
                                imM[i] = mappedMag * Math.sin(outPh);
                            }
                        } else if (useClassicMagnitudeTransfer === 3) {
                            for (let i = 0; i < SIZE; i++) {
                                const outPh = phC[i];

                                const mappedMag = magC[i] * magM[i] * Math.sin(i / SIZE * Math.PI) * 4;

                                reM[i] = mappedMag * Math.cos(outPh);
                                imM[i] = mappedMag * Math.sin(outPh);
                            }
                        }

                        // Apply volume and normalization
                        const volume = parseFloat(document.getElementById('volume').value) / Math.sqrt(SIZE / 1024);
                        for (let i = 0; i < SIZE; i++) {
                            reM[i] *= volume;
                            imM[i] *= volume;
                        }

                        // IFFT
                        ifft_classic(reM, imM);

                        // Overlap-add with windowing
                        for (let i = 0; i < SIZE; i++) {
                            const inputt = outputData[t + i] + reM[i] * window[i];
                            if (clampOut == 1) {
                                outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt)) / 3;
                            } else {
                                outputData[t + i] += reM[i] * window[i] / 3;
                            }
                        }
                    } else {
                        // Fill input buffer for input data with windowing
                        for (let i = 0; i < SIZE; i++) {
                            I[i] = (inputData[t + i] || 0) * window[i];
                            I2[i] = (carrierData[t + i] || 0) * window[i];
                        }

                        // Perform FFT on input data
                        FFT(O, I, 0, 0, SIZE, 1);

                        // Perform FFT on carrier data
                        FFT(O2, I2, 0, 0, SIZE, 1);
                        // === ORIGINAL PROCESSING MODE ===
                        // Modulate frequency components
                        for (let i = 0; i < SIZE; i++) {
                            let timer = currentTime; // Timer value between 0 and 1
                            const speedType = parseInt(document.getElementById('speedType').value)

                            switch (speedType) {
                                case 0:
                                    timer = currentTime / 8;
                                    break;
                                case 1:
                                    timer = currentTime / duration;
                                    break;
                                case 2:
                                    timer = currentTime * parseFloat(document.getElementById('userSpeed').value);
                                    break;
                            }

                            // Apply envelope following
                            let envelope = 0;
                            const mag1 = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                            let mag2 = 0;
                            let ip = 0;
                            let ip_ = 0;
                            const Ratio = (SIZE / 1024);

                            let callCount = 0;

                            const lin = (a, b, t) => a * (1 - t) + b * t;

                            // divide bands
                            for (let j = 0; j <= divbands; j++) {
                                ip = (i / 2 ** (pitch / 12) | 0);
                                const weight = 1 - abs(j - divbands / 2) / divbands;
                                
                                ip_ = Math.round(ip + (j - divbands / 2) + Shift);

                                if (flip) {
                                    ip_=Math.round(SIZE/16-ip_)
                                }

                                if (ip_ >= 0 && ip_ < SIZE && O2[ip_]) {
                                    mag2 += Math.sqrt(O2[ip_].r * O2[ip_].r + O2[ip_].i * O2[ip_].i) * weight;
                                } else {
                                    mag2 += 0;
                                }

                                const REL = Math.min((1 - Release) * Ratio, 1);

                                switch (DecayType) {
                                    case 1: // RMS
                                        envelopeState[i] = (1 - REL) * envelopeState[i] + REL * mag2 * mag2;
                                        envelope += Math.sqrt(envelopeState[i]);
                                        break;
                                    case 2: // Peak
                                        envelopeState[i] = Math.max(mag2, envelopeState[i] * (1 - REL));
                                        envelope += envelopeState[i];
                                        break;
                                }

                                const reverbAMT = parseFloat(document.getElementById("reverbAMT").value)
                                const reverbSIZE = parseFloat(document.getElementById("reverbSIZE").value)
                                
                                const RSIZE = Math.min((1 - reverbSIZE) * Ratio, 1);

                                const mag3 = envelope
                                
                                ReverbState[i] = (1 - RSIZE) * ReverbState[i] + RSIZE * mag3 * mag3;
                                envelope = Math.sqrt(ReverbState[i])*reverbAMT+mag3*(1-reverbAMT);
                                // somehow (1 + 2 / divbands / 2) solved the volume issue
                                envelope /= divbands * ((1 + 2 / divbands) / 2);
                            }

                            // Apply modulation with normalization and volume with BassBoost
                            const BassCurveType = parseInt(document.getElementById('BassCurve').value);
                            const normEQcurveType = parseInt(document.getElementById('EQType').value);

                            let BassCurve = 0;
                            switch (BassCurveType) {
                                case 0:
                                    BassCurve = 1;
                                    break;
                                case 1:
                                    BassCurve = 10 / (i + 1);
                                    break;
                                case 2:
                                    BassCurve = ((1 - i / SIZE) ** 2);
                                    break;
                            }

                            let normEQcurve = 0;
                            switch (normEQcurveType) {
                                case 0:
                                    normEQcurve = Math.min(1, (i < SIZE / 2 ? i : SIZE - i) / (SIZE / 4));
                                    break;
                                case 1:
                                    normEQcurve = Math.sin(i / SIZE * PI);
                                    break;
                            }

                            // Example calculation using the timer
                            let modulatedValue = 1
                            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
                            const modulatedInput = i*((timer*256|0)/256);

                            switch (simpleChorus) {
                                case 1:
                                    modulatedValue = sin(modulatedInput*PI);
                                    break;
                                case 2:
                                    modulatedValue = cos(modulatedInput*PI);
                                    break;
                                case 3:
                                    modulatedValue = asin(sin(modulatedInput*PI));
                                    break;
                                case 4:
                                    modulatedValue = asin(cos(modulatedInput*PI));
                                    break;
                            }

                            const normEQ = (normEQcurve + BassBoost * BassCurve / (Math.sqrt(Ratio)*1024) * 20) * modulatedValue

                            // Apply modulation based on BR_out value
                            switch (parseInt(document.getElementById('BR_out').value)) {
                                case 1:
                                    O[i] = M(O[i], X(2 * PI * i / SIZE));
                                    O2[i] = M(O2[i], X(2 * PI * i / SIZE));
                                    break;
                                case 3:
                                    O[i] = M(O[i], X2(2 * PI * i / SIZE));
                                    break;
                                case 2:
                                    O2[i] = M(O2[i], X2(2 * PI * i / SIZE));
                                    break;
                            }

                            const volume = document.getElementById('volume').value / Math.sqrt(Ratio);

                            const steps = parseFloat(document.getElementById('steps').value);
                            const RoundType = [Math.floor, Math.round, Math.ceil][parseInt(document.getElementById('RoundType').value)];
                            envelope = steps ? RoundType(envelope * (steps / 16)) / (steps / 16) : envelope;

                            O[i].r *= envelope * volume * normEQ;
                            O[i].i *= envelope * volume * normEQ;

                            if (clampOut == 2) {
                                O[i].r = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].r));
                                O[i].i = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].i));
                            }
                        }

                        let frequencyMagnitudes = Array(SIZE).fill(0);
                        if (clampOut == 4) {
                            for (let i = 0; i < SIZE; i++) {
                                const ratio = 2; // Compression ratio

                                // Calculate the magnitude of the frequency component
                                const magni = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                                frequencyMagnitudes[i] = Math.sqrt((frequencyMagnitudes[i] ** 2 * 24 + magni ** 2) / 25);
                                let level = frequencyMagnitudes[i];

                                let gain = Math.min(1, (Threshold / level) ** (ratio - 1)); // Compute gain reduction

                                O[i].r *= gain;
                                O[i].i *= gain;
                            }
                        }

                        if (Break) {
                            // Reverse the second half of the spectrum
                            for (let i = 1; i < SIZE / 2; i++) {
                                let tmp = O[i];
                                O[i] = O[SIZE - i];
                                O[SIZE - i] = tmp;
                            }
                            // discard the second half of the spectrum
                            for (let i = SIZE / 2; i < SIZE; i++) {
                                O[i].r = 0;
                                O[i].i = 0;
                            }
                        }

                        // Perform IFFT
                        IFFT(I, O, 0, 0, SIZE, 1);

                        // Overlap-add with windowing
                        for (let i = 0; i < SIZE; i++) {
                            const inputt =  outputData[t + i] + I[i].r / SIZE * window[i];
                            if (clampOut == 1) {
                                outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt));
                            } else {
                                outputData[t + i] += (I[i].r / SIZE) * window[i];
                            }
                        }
                    }
                }
            };

            // Process left channel
            processChannel(inputLeft, carrierLeft, outputLeft, envelopeStateLeft, ReverbStateLeft);

            // Process right channel
            processChannel(inputRight, carrierRight, outputRight, envelopeStateRight, ReverbStateRight);

            return outputBuffer;
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const synthKeyboardContainer = document.getElementById("synthKeyboardContainer");
            if (synthKeyboardContainer) {
                renderSynthKeyboard(synthKeyboardContainer, synthState.heldNotes);
                
                window.addEventListener('resize', () => {
                    renderSynthKeyboard(synthKeyboardContainer, synthState.heldNotes);
                });


            }
        });


        /*
         * Visualize the frequency response of the analog filters based on current analog control properties.
         * Draws the response on the #filterView canvas.
         */
        // global for it to not reset on each call
        let visState = 0;

        /*
         * syncMethod:
         * 0 = Rising Zero Crossing
         * 1 = Falling Zero Crossing
         * 2 = Any Zero Crossing
         * 3 = Positive Peak
         * 4 = Negative Trough
         * 5 = Steepest Rising Edge
         * 6 = Steepest Falling Edge
         * 7 = RMS Trigger
         * 8 = Hysteresis Trigger
         * 9 = Correlation Sync
         */

        syncMethod = 7

        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        canvas.addEventListener('click', function () {
            visState = (visState + 1) % 4;
        });


        function visualize(analyserL, analyserR, dataArrayL, dataArrayR) {
            const bufferLength = analyserL.frequencyBinCount;

            // Global visualization state:
            // 0 = Linear Spectrum
            // 1 = Log Spectrum
            // 2 = Scope
            // 3 = Mixed (Log + Scope)

            // Toggle on click

            function draw() {
                const width = canvas.width;
                const height = canvas.height;

                // Pull FFT + Time-domain data
                analyserL.getByteFrequencyData(dataArrayL);
                analyserR.getByteFrequencyData(dataArrayR);

                const timeDataL = new Uint8Array(analyserL.fftSize);
                const timeDataR = new Uint8Array(analyserR.fftSize);
                analyserL.getByteTimeDomainData(timeDataL);
                analyserR.getByteTimeDomainData(timeDataR);

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                switch (visState) {
                    case 0: // Linear Spectrum
                        drawSpectrumLinear(dataArrayL);
                        break;

                    case 1: // Log Spectrum
                        drawSpectrumLog(dataArrayL);
                        break;

                    case 2: // Scope
                        drawScope(timeDataL, timeDataR, 1.0);
                        break;

                    case 3: // Mixed
                        ctx.globalAlpha = 0.25;
                        drawSpectrumLog(dataArrayL);
                        ctx.globalAlpha = 1.0;
                        drawScope(timeDataL, timeDataR, 1.0);
                        break;
                }

                requestAnimationFrame(draw);
            }

            function drawSpectrumLinear(dataArray) {
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] * 1.56;
                    const barH = barHeight * 1.26 / 2;
                    const B255 = (Math.min(barH, 255) / 255) ** 1.5 * 255;
                    ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }

            function drawSpectrumLog(dataArray) {
                const func = Math.log;
                const logMin = 1;
                const logMax = func(bufferLength + 1);
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    const x = (func(i + logMin) / logMax) * canvas.width;
                    const nextX = (func(i + 1 + logMin) / logMax) * canvas.width;
                    const barWidthLog = nextX - x + 1;
                    const barH = barHeight * 1.26 / 2;
                    const B255 = (Math.min(barH, 255) / 255) ** 1.5 * 255;
                    ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidthLog, barHeight);
                }
            }

            function drawScope(timeDataL, timeDataR, alpha = 1.0) {
                ctx.globalAlpha = alpha;
                ctx.lineWidth = 1.5;
                
                // All sync methods
                function findRisingZeroCrossing(d){for(let i=0;i<d.length-1;i++){if(d[i]<128&&d[i+1]>=128)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findFallingZeroCrossing(d){for(let i=0;i<d.length-1;i++){if(d[i]>128&&d[i+1]<=128)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findAnyZeroCrossing(d){for(let i=0;i<d.length-1;i++){if((d[i]<128&&d[i+1]>=128)||(d[i]>128&&d[i+1]<=128))return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findPositivePeak(d){let m=-1,i0=0,c=false;for(let i=0;i<d.length;i++){if(d[i]>m){m=d[i];i0=i;c=true}}return {index:i0,canSync:c&&m>140}}
                function findNegativeTrough(d){let m=256,i0=0,c=false;for(let i=0;i<d.length;i++){if(d[i]<m){m=d[i];i0=i;c=true}}return {index:i0,canSync:c&&m<116}}
                function findSteepestRisingEdge(d){let m=0,i0=0,c=false;for(let i=0;i<d.length-1;i++){let s=d[i+1]-d[i];if(s>m){m=s;i0=i;c=true}}return {index:i0,canSync:c&&m>10}}
                function findSteepestFallingEdge(d){let m=0,i0=0,c=false;for(let i=0;i<d.length-1;i++){let s=d[i]-d[i+1];if(s>m){m=s;i0=i;c=true}}return {index:i0,canSync:c&&m>10}}
                function findRMSTrigger(d,w=32,t=20){for(let i=0;i<d.length-w;i++){let r=0;for(let j=0;j<w;j++){let s=d[i+j]-128;r+=s*s}r=Math.sqrt(r/w);if(r>t)return {index:i,canSync:true}}return {index:0,canSync:false}}
                function findCorrelationSync(d,p,l=64){if(!p||p.length<l)return {index:0,canSync:false};let bc=-1,bi=0;for(let i=0;i<=d.length-l;i++){let c=0,na=0,nb=0;for(let j=0;j<l;j++){const a=d[i+j]-128,b=p[j]-128;c+=a*b;na+=a*a;nb+=b*b}if(na>0&&nb>0){c/=Math.sqrt(na*nb);if(c>bc){bc=c;bi=i}}}return {index:bi,canSync:bc>0.7}}
                function findHysteresisTrigger(d,low=120,high=136){let trig=false;for(let i=0;i<d.length-1;i++){if(!trig&&d[i]<low)trig=true;else if(trig&&d[i]>high)return {index:i,canSync:true}}return {index:0,canSync:false}}
                
                function getSyncPoint(timeData, method = 'risingZero', previousPattern = null) {
                    switch (method) {
                        case 0: return findRisingZeroCrossing(timeData);
                        case 1: return findFallingZeroCrossing(timeData);
                        case 2: return findAnyZeroCrossing(timeData);
                        case 3: return findPositivePeak(timeData);
                        case 4: return findNegativeTrough(timeData);
                        case 5: return findSteepestRisingEdge(timeData);
                        case 6: return findSteepestFallingEdge(timeData);
                        case 7: return findRMSTrigger(timeData);
                        case 8: return findHysteresisTrigger(timeData);
                        case 9: return findCorrelationSync(timeData, previousPattern);
                        default: return findRisingZeroCrossing(timeData);
                    }
                }
                
                // Find sync point for each channel separately using selected method
                const syncResultL = getSyncPoint(timeDataL, syncMethod);
                const syncResultR = getSyncPoint(timeDataR, syncMethod);
                const startIndexL = syncResultL.index;
                const startIndexR = syncResultR.index;
                const canSyncL = syncResultL.canSync;
                const canSyncR = syncResultR.canSync;
                
                // Enable additive blending so red+blue = magenta
                ctx.globalCompositeOperation = "lighter";
                
                // Left channel (red) - synchronized to its own trigger point
                ctx.strokeStyle = "rgb(255, 0, 0)";
                ctx.beginPath();
                for (let i = 0; i < timeDataL.length; i++) {
                    const index = canSyncL ? (startIndexL + i) % timeDataL.length : i;
                    const x = (i / timeDataL.length) * canvas.width;
                    // Convert from 0-255 range to centered waveform
                    const y = ((255 - timeDataL[index]) / 255.0) * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Right channel (blue) - synchronized to its own trigger point
                ctx.strokeStyle = "rgb(0, 0, 255)";
                ctx.beginPath();
                for (let i = 0; i < timeDataR.length; i++) {
                    const index = canSyncR ? (startIndexR + i) % timeDataR.length : i;
                    const x = (i / timeDataR.length) * canvas.width;
                    // Convert from 0-255 range to centered waveform
                    const y = ((255 - timeDataR[index]) / 255.0) * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Restore normal drawing mode for next layers
                ctx.globalCompositeOperation = "source-over";
                
                // Draw sync indicators and method label
                ctx.beginPath();
                ctx.arc(10, 10, 5, 0, 2 * Math.PI);
                ctx.fillStyle = canSyncL ? 'red' : 'gray';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(25, 10, 5, 0, 2 * Math.PI);
                ctx.fillStyle = canSyncR ? 'blue' : 'gray';
                ctx.fill();
                
                // Display current sync method
                ctx.fillStyle = 'white';
                ctx.font = '12px monospace';
                //ctx.fillText(`Sync: ${syncMethod}`, 45, 15);
            }

            draw();
        }

        // --- Global audio state ---
        let isPlaying = false;
        let pausedAt = 0;
        let startedAt = 0;

        // Stereo analysers (so visualize() can use them outside)
        let analyserL = null;
        let analyserR = null;
        let dataArrayL = null;
        let dataArrayR = null;

        function playAudio() {
            if (!processedBuffer) {
                alert("No audio loaded/processed yet!");
                return;
            }

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (isPlaying) return; // already playing

            // --- Create buffer source ---
            playbackSource = audioContext.createBufferSource();
            playbackSource.buffer = processedBuffer;

            // --- Split stereo ---
            const splitter = audioContext.createChannelSplitter(2);

            // --- Analysers ---
            analyserL = audioContext.createAnalyser();
            analyserR = audioContext.createAnalyser();
            analyserL.fftSize = 2048;
            analyserR.fftSize = 2048;

            dataArrayL = new Uint8Array(analyserL.frequencyBinCount);
            dataArrayR = new Uint8Array(analyserR.frequencyBinCount);

            // --- Merger (to keep stereo intact) ---
            const merger = audioContext.createChannelMerger(2);

            // --- Routing ---
            playbackSource.connect(splitter);
            splitter.connect(analyserL, 0); // Left channel → analyserL
            splitter.connect(analyserR, 1); // Right channel → analyserR
            analyserL.connect(merger, 0, 0); // analyserL → Left
            analyserR.connect(merger, 0, 1); // analyserR → Right
            merger.connect(audioContext.destination);

            // --- Resume from pause or fresh start ---
            startedAt = audioContext.currentTime - pausedAt;
            playbackSource.start(0, pausedAt);

            // Reset state on end
            playbackSource.onended = () => {
                if (!isPlaying) return;
                stopAudio();
            };

            isPlaying = true;

            // --- Kick off visualization ---
            visualize(analyserL, analyserR, dataArrayL, dataArrayR);

            // Button state handling
            document.getElementById("playButton").disabled = true;
            document.getElementById("pauseButton").disabled = false;
            document.getElementById("stopButton").disabled = false;
        }

        function pauseAudio() {
            if (!isPlaying) return;

            playbackSource.stop();
            pausedAt = audioContext.currentTime - startedAt;
            isPlaying = false;

            document.getElementById("playButton").disabled = false;
            document.getElementById("pauseButton").disabled = true;
            document.getElementById("stopButton").disabled = false;
        }

        function stopAudio() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource.disconnect();
            }
            playbackSource = null;
            isPlaying = false;
            pausedAt = 0;
            startedAt = 0;

            document.getElementById("playButton").disabled = false;
            document.getElementById("pauseButton").disabled = true;
            document.getElementById("stopButton").disabled = true;
        }

        // --- Attach to UI ---
        document.getElementById("playButton").addEventListener("click", playAudio);
        document.getElementById("pauseButton").addEventListener("click", pauseAudio);
        document.getElementById("stopButton").addEventListener("click", stopAudio);

        document.getElementById('downloadButton').addEventListener('click', function() {
            const carrierInput = document.getElementById('carrierInput');
            const audioInput = document.getElementById('audioInput');
            let carrierName = 'No name';
            let modularName = 'No name';

            if (carrierInput.files.length > 0) {
                carrierName = carrierInput.files[0].name.split('.').slice(0, -1).join('.');
            }
            if (audioInput.files.length > 0) {
                modularName = audioInput.files[0].name.split('.').slice(0, -1).join('.');
            }

            if (processedBuffer) {
                const wavBuffer = bufferToWav(processedBuffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${carrierName} (${modularName}).wav`;
                a.click();
                URL.revokeObjectURL(url);
            }
        });


        function bufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = loadedCarrierBuffer.length * numOfChan * 2 + 44; // Use carrier buffer length
            const bufferArray = new ArrayBuffer(length);
            const view = new DataView(bufferArray);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length

            // Write interleaved audio data
            let offset = 44;
            for (let i = 0; i < loadedCarrierBuffer.length; i++) { // Use carrier buffer length
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
