<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="IconCFFTV.png">
    <title>Crappy FFT Vocoder</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 1px solid #fff;
        }
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            padding: 10px;
            background-color: #111;
            border-radius: 10px;
        }

        @media (max-width: 600px) {
            #controls {
                width: 90%;
            }
            canvas {
                width: 100%;
                height: auto;
            }
        }
        #controls2 {
            width: 96%;
            margin-top: 20px;
            padding: 10px;
            background-color: #222;
            border-radius: 10px;
            text-align: center;
            align-items: center;
            gap: 10px;
        }
        #controls2 > * {
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #iterations {
            width: 50px;
        }
        #helpPopup {
            display: none;
            position: fixed;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 5px 20px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #666;
        }
        button:disabled {
            background-color: #333;
            cursor: not-allowed;
        }
        input[type="file"] {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 2px 3px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="file"]::file-selector-button {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 3px 10px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #666;
        }
        select {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        select:hover {
            background-color: #666;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 125px;
            margin: 10px 0;
            background-color: #444;
            border-radius: 5px;
            height: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background-color: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background-color: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-moz-range-thumb:hover {
            background-color: #666;
        }

        input[type="range"]::-webkit-slider-runnable-track,
        input[type="range"]::-moz-range-track {
            background-color: #444;
            border-radius: 5px;
            height: 5px;
        }
        input[type="number"] {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 4px 5px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        
        .drag-over {
            border: 2px dashed #fff;
            background-color: #333;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .expanded {
            transform: scale(1.1);
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="controls" style="overflow-y: auto; max-height: 80vh;">

        <div style="text-align: center; line-height: 1.5;">
          <div id="Title" style="font-size: 35px;">Crappy FFT Vocoder</div>
            <div id="what_is">a Fast Fourier Transform vocoder</div>
          <div style="color: #aaa; font-size: 10px;">by DX3050/D3nschot</div>
            <div id="randomQuote" style="display: none;"></div>
        </div>
        <script>
            const quotes = [
                "FFT? I only know it as Functional Family Therapy", //found this while searching for FFT (fast fourier transform)
                "I love math -D3nschot",
                "I love math -DX3050",
                "probably gonna make Crappy Analog Vocoder",
                "A fast Fourier transform (FFT) is an algorithm \n that computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT). \n A Fourier transform converts a signal from its original domain (often time or space)\n to a representation in the frequency domain and vice versa. -wikipedia",
                "Don't we love how long it takes to process audio files? :D",
            ];
            document.getElementById('Title').addEventListener('click', function() {
                document.getElementById('randomQuote').style.display = 'block';
                document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];
            });
            document.getElementById('randomQuote').addEventListener('click', function() {
                document.getElementById('randomQuote').style.display = 'block';
                document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];
            })
            document.getElementById('randomQuote').innerText = quotes[Math.floor(Math.random() * quotes.length)];
        </script>
        <br>
        <canvas id="visualizer" width="800" height="400"></canvas>
        <div id="controls2">
            <div id="changeBack" style="display: block;">
                <button id="changeBackButton">Change to Analog Mode</button>
            </div>
        <button id="ViewProperties">View properties</button>
        |
        <input type="file" id="carrierInput" accept="audio/*,video/*" title="Choose an Input audio or video file" placeholder="Select Input audio or video file" />
        |
        <input type="file" id="audioInput" accept="audio/*,video/*" title="Choose an Carrier file for input" placeholder="Select Carrier audio file" />
        <br>
        <label for="decayType">Decay Type:</label>
        <select id="decayType">
            <option value="1">RMS</option>
            <option value="2">Peak</option>
        </select>
        |
        <label for="release">Release:</label>
        <input type="range" id="release" value="0" min="0" max="0.99" step="0.01" />
        <br>
        <label for="pitch">Pitch: 000</label>
        <input type="range" id="pitch" value="0" min="-24" max="24" step="1" />
        |
        <label for="BandShift">Shift: 000</label>
        <input type="range" id="BandShift" value="0" min="-100" max="100" step="1" />
        |
        <label for="FreqFlip">Flip:</label>
        <input type="checkbox" id="FreqFlip">
        
        <div id="FFTcontrols" style="display: block;">
            <label for="BandBreak">Band Break:</label>
            <input type="checkbox" id="BandBreak">
            <br>
            <label for="BR_voc_Type">Broken vocoder:</label>
            <select id="BR_voc_Type"> <!--anything with F  L  A  T, i don't recomend using for vocoding -->
                <option value="0">OFF</option>
                <!--waveforms-->
                <option value="1">Triangle</option> <!--Best sounding (sounds like it's bit-crushed)-->
                <option value="5">Square</option> <!--F  L  A  T-->
                <option value="6">Sawtooth</option> <!--F  L  A  T  2-->
                <option value="11">semi-sine</option> <!--0 bass at all it's all treble (don't recomend for vocoding)-->
                <!--repeated functions-->
                <option value="2">double sine</option> <!--no bass (still good tho)-->
                <option value="7">triple sine</option> <!--same as double sine-->
                <option value="8">half sine</option> <!--it sounds like the bands are wide-->
                <option value="10">sine squared</option> <!--F  L  A  T  3-->
                <option value="14">sine cubed</option> <!--kinda like the trianle one-->
                <!--multiplication (sin(o*2))-->
                <option value="3">2 sine</option> <!--it's half sine but with more bass and it's wider-->
                <option value="4">3 sine</option> <!--B  A  S  S-->
                <option value="9">squared sine</option> <!--F  L  A  T  4-->
                <!--Special waves-->
                <option value="12">IDK</option> <!--i genuinely have no idea what this is but it sounds like a retro game comming from an old TV-->
                <option value="13">Noise</option> <!--F  L  A  T  5-->
                <option value="15">sine sine</option> <!--this is a joke, sin(o*sin(o))-->
                <option value="16">harmonics sq</option> <!--harmonic serries-->
                <option value="17">harmonics saw</option> <!--harmonic serries-->
                <option value="18">Bitwise</option> <!--sounds like Triangle but more bit-crushed-->
                <option value="19">Floor</option> <!--sounds like Triangle but more bit-crushed-->
            </select>
            |
            <label for="BR_out">Broken vocoder out</label>
            <select id="BR_out">
                <option value="1">Both</option>
                <option value="2">Input</option>
                <option value="3">Carrier</option>
            </select>
            <br>
            <label for="iterations">Iterations:</label>
            <input type="number" id="iterations" value="1" min="1" />
            it may get loud (or not, i don't recomend using this with long audio files)
            <br>
            <label for="volume">volume: 1.00</label>
            <input type="range" id="volume" value="1" min="0" max="2" step="0.01" />
            |
            <label for="clamp_output">Clamp out</label>
            <select id="clamp_output">
                <option value="0">Off</option>
                <option value="1">On</option>
                <option value="2">individual</option>
                <!--option value="3">Compressor</option-->
                <option value="4">individual (soft)</option>
            </select>
            |
            <label for="threshold">Clamp Threshold: 1.00</label>
            <input type="range" id="threshold" value="1" min="0" max="1" step="0.01"/>
            <br>
            <label for="divbands">Divide bands: 1</label>
            <input type="range" id="divbands" value="1" min="1" max="64"/>
            |
            <label for="FFTsize">FFT size: 2^10 (1024)</label>
            <input type="range" id="FFTsize" value="10" min="2" max="14" step="1"/>
            <br>
            <label for="BassBoost">Bass Boost: 0.00</label>
            <input type="range" id="BassBoost" value="0" min="-4" max="4" step=".01"/>
            |
            <label for="BassCurve">Bass Curve</label>
            <select id="BassCurve">
                <option value="0">+1</option>
                <option value="1">x/i</option>
                <option value="2">quadratic</option>
            </select>
            |
            <label for="EQType">Norm EQ type</label>
            <select id="EQType">
                <option value="0">original</option>
                <option value="1">sin</option>
            </select>
            <br>
            <label for="steps">Steps: OFF</label>
            <input type="range" id="steps" value="0" min="0" max="16" step="1"/>
            |
            <label for ="RoundType">Round Type</label>
            <select id="RoundType">
                <option value="0">Floor</option>
                <option value="1">Round</option>
                <option value="2">Ceil</option>
            </select>
            |
            <label for="SoundGoodizer">SoundGoodizer? OFF:</label>
            <input type="range" id="SoundGoodizer" value="0" min="0" max="1" step="0.01"/>
            <br>
            <label for="simpleChorus">simple Chorus</label>
            <select id="simpleChorus">
                <option value="0">OFF</option>
                <option value="1">sin</option>
                <option value="2">cos</option>
                <option value="3">asin</option>
                <option value="4">acos</option>
            </select>
            |
            <label for="speedType">speed</label>
            <select id="speedType">
                <option value="0">Auto</option>
                <option value="1">file length</option>
                <option value="2">user</option>
            </select>
            <label for="userSpeed">| speed: 1.00 Hz</label>
            <input type="range" id="userSpeed" value="1" min="0" max="100" step="0.01"/>
            <br>
        </div>
        <div id="analogControls" style="display: none;">
        <!-- Add this inside the #analogControls section -->
        <div style="margin-top: 10px;">
        <label for="Auto-update Filters">Auto-update Filters:</label>
        <input type="checkbox" id="AutoUpdateFilters" checked>
        <button id="ManualStudyFilters" style="display: none; margin-left: 10px;">Update Study Filters</button>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                // Reference to checkbox and button
                const autoUpdateCheckbox = document.getElementById('AutoUpdateFilters');
                const manualStudyButton = document.getElementById('ManualStudyFilters');

                // Watch checkbox toggle to show/hide the manual update button
                autoUpdateCheckbox.addEventListener('change', () => {
                    manualStudyButton.style.display = autoUpdateCheckbox.checked ? 'none' : 'inline-block';
                });

                // Attach event listener to the manual button
                manualStudyButton.addEventListener('click', () => {
                    if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
                });

                // Attach to analog controls for live update if auto-update is enabled
                ['TotalBands', 'Resonance', 'DBperOct', 'BPwidth', 'Alt_BP'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        const handler = () => {
                            const autoUpdate = document.getElementById('AutoUpdateFilters');
                            if (!autoUpdate || autoUpdate.checked) {
                                studyAnalogFilters();
                                el.addEventListener('input', handler);
                                el.addEventListener('change', handler);
                            }
                        };
                    }
                });

                // Call studyAnalogFilters once on page load if available
                if (typeof studyAnalogFilters === 'function') studyAnalogFilters();
            });
            </script>

            <canvas id="filterView" width="700" height="100"></canvas>
            <br>
            <label for="TotalBands">Total Bands: 40</label>
            <input type="range" id="TotalBands" value="40" min="1" max="1024" step="1"/>
            |
            <label for="Resonance">Resonance: 0.920</label>
            <input type="range" id="Resonance" value=".92" min="0" max=".999" step="0.001"/>
            <br>
            <label for="BPwidth">Bandpass Width: 0.00</label>
            <input type="range" id="BPwidth" value="0" min="0" max="1" step="0.01"/>
            |
            <label for="Volboost">Volume Boost: 1.00</label>
            <input type="range" id="Volboost" value="1" min="0" max="10" step="0.01"/>
            <br>
            <label for="DBperOct">dB per Octave: 12</label>
            <input type="range" id="DBperOct" value="2" min="1" max="8" step="1"/>
            |
            <label for="Alt_BP">Alt Bandpass:</label>
            <select id="Alt_BP">
                <option value="0">Default</option>
                <option value="1">normal</option>
                <option value="2">weird</option>
                <option value="3">fast</option>
                <option value="4">3FLT</option>
            </select>
        </div>
        <br>
        <button id="playButton" disabled>Play Audio</button>
        <button id="pauseButton" disabled>Pause Audio</button>
        <button id="stopButton" disabled>Stop Audio</button>
        <button id="downloadButton" disabled>Download Audio</button>
        <button id="reprocessButton" disabled>Reprocess Audio</button>
        <button id="helpButton">Help</button>
        </div>
        
        <div id="helpPopup" style="display: none;">
            <div style="background-color: #333; padding: 20px; border-radius: 10px; color: #fff; max-width: 600px; text-align: left; max-height: 80vh; overflow-y: auto;">
            <h2>Help</h2>
            <p>Welcome to the Crappy FFT Vocoder!</p>
            <p>this is a Fast Fourier Transform based vocoder that uses a lot of math to process audio files.</p>
            <p><strong>What is FFT?</strong></p>
            <p>The Fast Fourier Transform (FFT) is an algorithm that quickly converts a signal from its original time domain into a frequency domain. This allows the vocoder to analyze and manipulate the different frequency components of audio, enabling effects like filtering, modulation, and vocoding.</p>
            <p>Learn more about the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank" rel="noopener noreferrer" style="color:#4af;">Fast Fourier Transform (FFT)</a> on Wikipedia.</p>
            <p>this is why it's taking so long to process</p>

            <p>fun fact: dividing the FFT index by 2 will multiply the pitch by 2, multiplying it will do the opposite
            <p>Here are some instructions and information to get you started:</p>
            <ul>
            <li><strong>Decay Type:</strong> Choose between RMS and Peak for the decay type.</li>
            <li><strong>Release:</strong> Adjust the release time for the vocoder (0 is no release and 1 is max release).</li>
            <li><strong>Pitch:</strong> Adjust the pitch of the vocoded audio (input only).</li>
            <li><strong>Shift:</strong> Shifts the FFT bands of the vocoded audio (input only)</li>
            
            <p><strong>FFT Vocoder Mode:</strong></p>
            <li><strong>BandBreak:</strong> this shifts the bands a couple of times</li>
            <li><strong>Flip:</strong> self explanitory it flips the bands</li>
            <li><strong>Broken Vocoder Type:</strong> Select the type of broken vocoder effect.</li>
            <ul>
                <p>All the types with it's desciption I added</p>
                <li>Triangle: Best sounding (sounds like it's bit-crushed)</li>
                <li>Square: F L A T</li>
                <li>Sawtooth: F L A T 2</li>
                <li>semi-sine: 0 bass at all it's all treble (don't recommend for vocoding)</li>
                <li>double sine: no bass (still good tho)</li>
                <li>triple sine: same as double sine</li>
                <li>half sine: it sounds like the bands are wide</li>
                <li>sine squared: F L A T 3</li>
                <li>sine cubed: kinda like the triangle one</li>
                <li>2 sine: it's half sine but with more bass and it's wider</li>
                <li>3 sine: B A S S</li>
                <li>squared sine: F L A T 4</li>
                <li>IDK: i genuinely have no idea what this is but it sounds like a retro game coming from an old TV</li>
                <li>Noise: F L A T 5</li>
                <li>sine sine: this is a joke, sin(o*sin(o)) also very flat</li>
                <li>harmonics saw: harmonic series of a sawtooth also it's phase shifted by 90</li>
                <li>harmonics sq: harmonic series of a square also it's phase shifted by 90</li>
                <li>Bitwise: sounds like Triangle but more bit-crushed</li>
                <li>Floor: sounds like Triangle but more bit-crushed</li>
            </ul>
            <br>
            <li><strong>Broken Vocoder Out:</strong> Choose which audio to output (Both, Input, Carrier).</li>
            <li><strong>Iterations:</strong> Set the number of iterations for processing.</li>
            <li><strong>Volume:</strong> Adjust the volume of the output audio.</li>
            <li><strong>Divide Bands:</strong> Adjust the number of bands to divide the audio into.</li>
            <li><strong>Clamp Out:</strong> Choose whether to clamp the output audio (Off, On, individual bands).</li>
            <li><strong>Clamp Threshold:</strong> Adjust the threshold for clamping the output audio.</li>
            <li><strong>FFT Size:</strong> Adjust the size of the FFT (Fast Fourier Transform) used for processing.</li>
            <li><strong>Bass Boost:</strong> Adjust the Bass boost level for the audio. (putting it in the negatives won't decrease it, it will increase it in a different way)</li>
            <li><strong>Steps:</strong> Adjust the number of steps for quantizing the envelope (OFF means no quantization).</li>
            <li><strong>Round Type:</strong> Choose the rounding type for the steps (Floor, Round, Ceil).</li>
            
            <p><strong>Analog Vocoder Mode:</strong></p>

                <li><strong>Total Bands:</strong> Sets the number of filter bands (more bands = more detailed vocoding).</li>
                <li><strong>Resonance:</strong> Controls the sharpness of the bandpass filters (higher values = more pronounced filtering).</li>
                <li><strong>Bandpass Width:</strong> Adjusts the width of each bandpass filter. (only anvalibe ont the default bandpass)</li>
                <li><strong>Volume Boost:</strong> Increases the output volume after processing.</li>
                <li><strong>dB per Octave:</strong> Sets the filter slope (steepness) in decibels per octave.</li>
                <li><strong>Alternative Bandpass:</strong> Switches to an alternative bandpass filter algorithm. (first one is really sensitive/strong)</li>
                <ul>
                    <li>Default: Default bandpass filter. it is really sensitive when Bandpass Width is 0</li>
                    <li>Normal: A standard bandpass filter.</li>
                    <li>Weird: non-linear filter.</li>
                    <li>Fast: A faster bandpass filter with less processing time.</li>
                    <li>3FLT: A bandpass filter that uses three filters for better sound.</li>
                </ul>
            
            <p>just another way of vocoding</p>
            
            <li><strong>Simple Chorus:</strong> Choose the type of simple chorus effect.</li>
            <li><strong>Speed:</strong> Choose the speed type for the chorus effect.</li>
            <li><strong>User Speed:</strong> Adjust the user-defined speed for the chorus effect.</li>
            <br>
            <div id="version">version 1.2</div> <!--current version-->
            Made by D3nschot (DX3050)
            </ul>
            <button id="closeHelpButton">Close</button>
            </div>
        </div>

        <script>
            // Function to clean up the URL by removing disallowed characters
            function CleanUpLink() {
                const DisAllowsCharacters = '(|^*%$#@!<>,/\\:\';\"{}[]~+")';
                const regex = new RegExp('[' + DisAllowsCharacters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']', 'g');
                const url = window.location.href;
                if (regex.test(url)) {
                    const newurl = url.replace(regex, '');
                    window.history.replaceState({}, '', newurl);
                }
            }

            document.addEventListener('DOMContentLoaded', CleanUpLink);

            let Vmode=0; // 0 for FFT, 1 for analog

            document.getElementById('changeBackButton').addEventListener('click', function() {
                // Toggle between 0 (FFT) and 1 (analog)
                Vmode = ((Number(Vmode) || 0) + 1) % 2;

                if (Vmode === 0) {
                    document.getElementById('Title').textContent = 'Crappy FFT Vocoder';
                    document.getElementById('what_is').textContent = 'a Fast Fourier Transform vocoder';
                    document.getElementById('changeBackButton').textContent = 'Change to Analog Mode';
                    document.getElementById('FFTcontrols').style.display = 'block';
                    document.getElementById('analogControls').style.display = 'none';
                    document.getElementById('changeBack').style.display = 'block';
                } else {
                    document.getElementById('Title').textContent = 'Crappy Analog Vocoder';
                    document.getElementById('what_is').textContent = 'an Analog Vocoder';
                    document.getElementById('FFTcontrols').style.display = 'none';
                    document.getElementById('analogControls').style.display = 'block';
                    document.getElementById('changeBackButton').textContent = 'Change to FFT Mode';
                    document.getElementById('changeBack').style.display = 'block';
                }

                // Update the URL with the new Vmode
                const params = new URLSearchParams(window.location.search);
                params.set('Vmode', Vmode);
                const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
                window.history.replaceState({}, '', newUrl);
            });

            document.addEventListener('DOMContentLoaded', function() {
                const params = new URLSearchParams(window.location.search);
                Vmode = Number(params.get('Vmode')) || 0; // Default to 0 if not set

                if (Vmode === 0) {
                    document.getElementById('Title').textContent = 'Crappy FFT Vocoder';
                    document.getElementById('what_is').textContent = 'a Fast Fourier Transform vocoder';
                    document.getElementById('changeBackButton').textContent = 'Change to Analog Mode';
                    document.getElementById('FFTcontrols').style.display = 'block';
                    document.getElementById('analogControls').style.display = 'none';
                    document.getElementById('changeBack').style.display = 'block';
                } else {
                    document.getElementById('Title').textContent = 'Crappy Analog Vocoder';
                    document.getElementById('what_is').textContent = 'an Analog Vocoder';
                    document.getElementById('FFTcontrols').style.display = 'none';
                    document.getElementById('analogControls').style.display = 'block';
                    document.getElementById('changeBackButton').textContent = 'Change to FFT Mode';
                    document.getElementById('changeBack').style.display = 'block';
                }

                
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                const speedTypeSelect = new URLSearchParams(window.location.search).get('speedType') || '0';

                if (speedTypeSelect == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            
            });
        </script>
        
        <script>
            const cornerElement = document.createElement('a');
            cornerElement.href = 'https://github.com/D3nschot/crappy-FFT-vocoder';
            cornerElement.style.position = 'fixed';
            cornerElement.style.bottom = '10px';
            cornerElement.style.right = '10px';
            cornerElement.style.backgroundColor = '#444';
            cornerElement.style.color = '#fff';
            cornerElement.style.padding = '10px';
            cornerElement.style.borderRadius = '5px';
            cornerElement.style.zIndex = '1000';
            cornerElement.textContent = 'Fork me on GitHub :)';
            document.body.appendChild(cornerElement);

            document.getElementById('helpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').style.display = 'block';
            });

            document.getElementById('closeHelpButton').addEventListener('click', function() {
            document.getElementById('helpPopup').style.display = 'none';
            });

            function handleDragOver(event) {
                event.preventDefault();
                event.target.classList.add('drag-over');
                event.target.classList.add('expanded');
            }

            function handleDragLeave(event) {
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.target.classList.remove('drag-over');
                event.target.classList.remove('expanded');
                const fileInput = event.target;
                const files = event.dataTransfer.files;
                fileInput.files = files;

                // Trigger change event manually
                const changeEvent = new Event('change');
                fileInput.dispatchEvent(changeEvent);
            }

            document.getElementById('carrierInput').addEventListener('dragover', handleDragOver);
            document.getElementById('carrierInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('carrierInput').addEventListener('drop', handleDrop);

            document.getElementById('audioInput').addEventListener('dragover', handleDragOver);
            document.getElementById('audioInput').addEventListener('dragleave', handleDragLeave);
            document.getElementById('audioInput').addEventListener('drop', handleDrop);

            document.getElementById('speedType').addEventListener('change', function(event) {
                const userSpeedLabel = document.querySelector('label[for="userSpeed"]');
                const userSpeedSlider = document.getElementById('userSpeed');
                if (event.target.value == '2') {
                    userSpeedLabel.style.display = 'inline';
                    userSpeedSlider.style.display = 'inline';
                } else {
                    userSpeedLabel.style.display = 'none';
                    userSpeedSlider.style.display = 'none';
                }
            });

            const inputs='input[type="range"], input[type="number"], input[type="checkbox"], select'

            // Initialize the visibility of the speed slider based on the current selection
            document.getElementById('speedType').dispatchEvent(new Event('change'));

            // Function to update the URL with the current state

            function updateURLParams() {
                const params = new URLSearchParams();

                // Collect all slider, select, and checkbox values
                document.querySelectorAll(inputs).forEach(input => {
                    if (input.type === 'checkbox') {
                        params.set(input.id, input.checked ? 'true' : 'false');
                    } else {
                        params.set(input.id, input.value);
                    }
                });

                params.set('Vmode', Vmode);

                // Update the URL without reloading the page
                const newUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
                window.history.replaceState({}, '', newUrl);
            }


            // Function to load state from the URL
            function loadStateFromURL() {
                const params = new URLSearchParams(window.location.search);

                params.forEach((value, key) => {
                    if (key === 'Vmode') {
                        window.Vmode = value;
                        return;
                    }
                    const input = document.getElementById(key);
                    if (input) {
                        if (input.type === 'checkbox') {
                            input.checked = value === 'true';
                        } else {
                            input.value = value;
                        }
                        input.dispatchEvent(new Event('input'));
                    }
                });
            }

            // Attach event listeners to all sliders and dropdowns
            document.addEventListener('DOMContentLoaded', () => {
                document.querySelectorAll(inputs).forEach(input => {
                    input.addEventListener('input', updateURLParams);
                    input.addEventListener('change', updateURLParams);
                });

                // Load state from URL on page load
                loadStateFromURL();
            });

            document.getElementById('ViewProperties').addEventListener('click', function() {
                const inputs = document.querySelectorAll('input, select');
                const fileInputs = document.querySelectorAll('input[type="file"]');
                const properties = [];
                const fileInfo = [];

                // Collect input values
                inputs.forEach(input => {
                    if (input.type === 'range' || input.type === 'number' || input.type === 'checkbox' || input.tagName === 'SELECT') {
                        properties.push(`${input.id}: ${input.value}`);
                    }
                });
                properties.push(`Mode: ${Vmode ? 'Analog Mode' : 'FFT Mode'}`); // Add Vmode as a property
                // Collect file input details
                fileInputs.forEach(fileInput => {
                    const file = fileInput.files[0];
                    if (file) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            audioContext.decodeAudioData(e.target.result, function(buffer) {
                                const duration = buffer.duration.toFixed(2);
                                fileInfo.push(`
                                    <h2>${file.name}</h2>
                                    <li>Size: ${(file.size / 1024).toFixed(2)} KB</li>
                                    <li>Duration: ${Math.floor(duration / 60)}:${Math.floor(duration % 60).toString().padStart(2, '0')}:${Math.floor((duration % 1) * 1000).toString().padStart(3, '0')} (${duration} seconds)</li>
                                    <li>Sample Rate: ${buffer.sampleRate} Hz</li>
                                    <li>Channels: ${buffer.numberOfChannels}</li>
                                    <li>Codec: ${(co=file.type.split('/')[1]|| 'failed to get Codec') , file.type === 'audio/wav' || file.type.includes('pcm') ? co + ` (PCM ${buffer.getChannelData(0).BYTES_PER_ELEMENT * 8})`: co}</li>
                                `);

                                // Update the popup content dynamically
                                const popup = document.querySelector('div[style*="z-index: 1000"]');
                                if (popup) {
                                    popup.innerHTML = `
                                        <h1>Properties</h1>
                                        ${fileInfo.join('')}
                                        <br>
                                        <h1>Input Values</h1>
                                        <ul>${properties.map(prop => `<li>${prop}</li>`).join('')}</ul>
                                        <button id="ExportJSON" style="margin-top: 10px;">Export as JSON</button>|<button id="closePropertiesButton" style="margin-top: 10px;">Close</button>
                                    `;

                                    // Reattach the close button event listener
                                    document.getElementById('closePropertiesButton').addEventListener('click', function() {
                                        document.body.removeChild(popup);
                                    });

                                    // Add ExportJSON functionality
                                    document.getElementById('ExportJSON').addEventListener('click', function() {
                                        const jsonObject = {};
                                        inputs.forEach(input => {
                                            if (input.type === 'range' || input.type === 'number' || input.tagName === 'SELECT') {
                                                jsonObject[input.id] = input.value;
                                            } else if (input.type === 'checkbox') {
                                                jsonObject[input.id] = input.checked;
                                            }
                                        });

                                        // Add Vmode as a property
                                        jsonObject.Mode = Vmode ? 'Analog Mode' : 'FFT Mode';

                                        const jsonBlob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                                        const jsonUrl = URL.createObjectURL(jsonBlob);
                                        const downloadLink = document.createElement('a');
                                        downloadLink.href = jsonUrl;
                                        downloadLink.download = 'properties.json';
                                        downloadLink.click();
                                        URL.revokeObjectURL(jsonUrl);
                                    });
                                }
                            });
                        };
                        reader.readAsArrayBuffer(file);
                    } else {
                        fileInfo.push(`
                            <h2>${fileInput.id}</h2>
                            <li>No file selected</li>
                        `);
                    }
                });

                // Create the popup
                const popup = document.createElement('div');
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = '#333';
                popup.style.color = '#fff';
                popup.style.padding = '20px';
                popup.style.borderRadius = '10px';
                // Responsive and flex styles:
                popup.style.width = '90vw';
                popup.style.maxWidth = '600px';
                popup.style.minWidth = '220px';
                popup.style.maxHeight = '80vh';
                popup.style.overflowY = 'auto';
                popup.style.overflowX = 'hidden';
                popup.style.zIndex = '1000';
                popup.style.display = 'flex';
                popup.style.flexDirection = 'column';
                popup.style.alignItems = 'flex-start'; // or 'center' if you want centered content
                popup.style.justifyContent = 'flex-start';
                popup.style.boxSizing = 'border-box';
                popup.style.textAlign = 'left';

                // Add content to the popup
                popup.innerHTML = `
                    <h2>Properties</h2>
                    ${fileInfo.join('')}
                    <br>
                    <h2>Input Values</h2>
                    <ul style="width:100%;word-break:break-word;overflow-wrap:anywhere;padding:1;margin:0;">
                        ${properties.map(prop => `<li style="word-break:break-word;overflow-wrap:anywhere;">${prop}</li>`).join('')}
                    </ul>
                    <br>
                    <div>
                        <button id="ExportJSON" style="margin-top: 10px;">Export as JSON</button> |
                        <button id="ImportJSON" style="margin-top: 10px;">Import JSON</button> |
                        <button id="closePropertiesButton" style="margin-top: 10px;">Close</button>
                    </div>
                `;

                // Append the popup to the body
                document.body.appendChild(popup);

                // Add event listener to close the popup
                document.getElementById('closePropertiesButton').addEventListener('click', function() {
                    document.body.removeChild(popup);
                });

                // Add ExportJSON functionality
                document.getElementById('ExportJSON').addEventListener('click', function() {
                    const jsonObject = {};
                    inputs.forEach(input => {
                        if (input.type === 'range' || input.type === 'number' || input.tagName === 'SELECT') {
                            jsonObject[input.id] = input.value;
                        } else if (input.type === 'checkbox') {
                            jsonObject[input.id] = input.checked;
                        }
                    });

                    // Add Vmode as a property
                    jsonObject.Mode = Vmode ? 'Analog Mode' : 'FFT Mode';

                    const jsonBlob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: 'application/json' });
                    const jsonUrl = URL.createObjectURL(jsonBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = jsonUrl;
                    downloadLink.download = 'properties.json';
                    downloadLink.click();
                    URL.revokeObjectURL(jsonUrl);
                });

                document.getElementById('ImportJSON').addEventListener('click', function() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    input.addEventListener('change', function(event) {
                        const file = event.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                try {
                                    const jsonObject = JSON.parse(e.target.result);
                                    Object.keys(jsonObject).forEach(key => {
                                        if (key === 'Mode' || key === 'Vmode') {
                                            // Handle Vmode/Mode property
                                            window.Vmode = jsonObject[key];
                                            // Optionally update UI if needed
                                            return;
                                        }
                                        const inputElement = document.getElementById(key);
                                        if (inputElement) {
                                            if (inputElement.type === 'checkbox') {
                                                inputElement.checked = jsonObject[key] === true || jsonObject[key] === 'true';
                                            } else {
                                                inputElement.value = jsonObject[key];
                                            }
                                            // Trigger input and change events to update UI
                                            inputElement.dispatchEvent(new Event('input'));
                                            inputElement.dispatchEvent(new Event('change'));
                                        }
                                    });
                                    alert('Properties imported successfully!');
                                } catch (error) {
                                    alert('Invalid JSON file. Please select a valid properties file.');
                                }
                            };
                            reader.readAsText(file);
                        }
                    });
                    input.click();
                });;
            });
        </script>
    <script>
        let audioContext, analyser, source, processedBuffer, audioData, carrierBuffer;
        let loadedAudioBuffer = null;
        let loadedCarrierBuffer = null;
        let playbackSource = null;

        function extractAudioFromVideo(file, callback) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            video.play();

            video.addEventListener('canplaythrough', function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                source.connect(destination);
                const recorder = new MediaRecorder(destination.stream);
                const chunks = [];

                recorder.ondataavailable = function(event) {
                    chunks.push(event.data);
                };

                recorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(blob);
                };

                recorder.start();
                video.play();
                setTimeout(() => {
                    recorder.stop();
                    video.pause();
                    URL.revokeObjectURL(video.src);
                }, video.duration * 1000);
            });
        }

        function handleFileInput(event, callback) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    extractAudioFromVideo(file, callback);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        callback(e.target.result);
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        document.getElementById('audioInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioData = e.target.result;
                    audioContext.decodeAudioData(audioData, function(buffer) {
                        loadedAudioBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding carrier audio data:', error);
                        alert('Error decoding carrier audio data. Please select a valid audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // this fixed the issue of requireing the carrier file to be loaded first
        function tryProcessAudio(B) {
            if (loadedCarrierBuffer && loadedAudioBuffer) {
                processAudio(B);
            }
        }

        document.getElementById('carrierInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const carrierData = e.target.result;
                    audioContext.decodeAudioData(carrierData, function(buffer) {
                        loadedCarrierBuffer = buffer;
                        carrierBuffer = buffer;
                        tryProcessAudio(loadedAudioBuffer);
                    }, function(error) {
                        console.error('Error decoding modular audio data:', error);
                        alert('Error decoding modular audio data. Please select a valid input audio file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('reprocessButton').addEventListener('click', function() {
            if (loadedAudioBuffer && loadedCarrierBuffer) {
                processAudio(loadedAudioBuffer);
            } else {
                alert('Please load both audio and input files first.');
            }
        });

        document.getElementById('pitch').addEventListener('input', function(event) {
            document.querySelector('label[for="pitch"]').textContent = `Pitch: ${(parseFloat(event.target.value)<=0?parseFloat(event.target.value)==0?'0':'-':'+')+Math.abs(parseFloat(event.target.value)).toString().padStart(2, '0')}`;
        });

        document.getElementById('BandShift').addEventListener('input',function(event) {
            document.querySelector('label[for="BandShift"]').textContent = `Shift: ${(parseFloat(event.target.value)<=0?parseFloat(event.target.value)==0?'0':'-':'+')+Math.abs(parseFloat(event.target.value)).toString().padStart(2, '0')}`;
        })

        document.getElementById('volume').addEventListener('input', function(event) {
            document.querySelector('label[for="volume"]').textContent = `volume: ${parseFloat(event.target.value).toFixed(2)}`;
        });
        
        document.getElementById('divbands').addEventListener('input', function(event) {
            document.querySelector('label[for="divbands"]').textContent = `Divide bands: ${parseFloat(event.target.value)}`;
        });

        document.getElementById('FFTsize').addEventListener('input', function(event) {
            document.querySelector('label[for="FFTsize"]').textContent = `FFT size: 2^${parseFloat(event.target.value)} (${2**parseFloat(event.target.value)})`;
        });
        
        document.getElementById('BassBoost').addEventListener('input', function(event) {
            document.querySelector('label[for="BassBoost"]').textContent = `Bass Boost: ${parseFloat(event.target.value).toFixed(2)}`;
        });

        document.getElementById('steps').addEventListener('input', function(event) {
            document.querySelector('label[for="steps"]').textContent = `Steps: ${parseFloat(event.target.value)?parseFloat(event.target.value).toFixed(2):'OFF'}`;
        });
        
        document.getElementById('threshold').addEventListener('input', function(event) {
            document.querySelector('label[for="threshold"]').textContent = `Clamp Threshold: ${parseFloat(event.target.value).toFixed(2)}`;
        });

        document.getElementById('userSpeed').addEventListener('input', function(event) {
            document.querySelector('label[for="userSpeed"]').textContent = `| speed: ${parseFloat(event.target.value).toFixed(2)} Hz`;
        });

        document.getElementById('SoundGoodizer').addEventListener('input', function(event) {
            document.querySelector('label[for="SoundGoodizer"]').textContent = `SoundGoodizer? ${parseFloat(event.target.value)!==0?parseFloat(event.target.value).toFixed(2):'OFF'}`;
        });

        document.getElementById('Resonance').addEventListener('input', function(event) {
            document.querySelector('label[for="Resonance"]').textContent = `Resonance: ${parseFloat(event.target.value).toFixed(3)}`;
        });
        document.getElementById('BPwidth').addEventListener('input', function(event) {
            document.querySelector('label[for="BPwidth"]').textContent = `Bandpass Width: ${parseFloat(event.target.value).toFixed(2)}`;
        });
        document.getElementById('TotalBands').addEventListener('input', function(event) {
            document.querySelector('label[for="TotalBands"]').textContent = `Total Bands: ${parseInt(event.target.value)}`;
        });
        document.getElementById('Volboost').addEventListener('input', function(event) {
            document.querySelector('label[for="Volboost"]').textContent = `Volume Boost: ${parseFloat(event.target.value).toFixed(2)}`;
        });
        document.getElementById('DBperOct').addEventListener('input', function(event) {
            document.querySelector('label[for="DBperOct"]').textContent = `dB per Octave: ${parseFloat(event.target.value)*6}`;
        });

        function createLoopedBuffer(buffer, targetLength) {
            const sampleRate = buffer.sampleRate;
            const numberOfChannels = buffer.numberOfChannels;
            const newBuffer = audioContext.createBuffer(numberOfChannels, targetLength, sampleRate);
            
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const nowBuffering = newBuffer.getChannelData(channel);
                const originalData = buffer.getChannelData(channel);
                
                for (let i = 0; i < targetLength; i++) {
                    nowBuffering[i] = originalData[i % originalData.length];
                }
            }
            
            return newBuffer;
        }

        function showProcessPOP_UP(text, block = true, bar = false, per) {
            let popup = document.getElementById('processPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'processPopup';
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = '#222';
                popup.style.color = '#fff';
                popup.style.padding = '30px 40px';
                popup.style.borderRadius = '12px';
                popup.style.boxShadow = '0 4px 24px #000a';
                popup.style.zIndex = '2000';
                popup.style.fontSize = '1.2em';
                popup.style.textAlign = 'center';
                popup.style.display = 'flex';
                popup.style.flexDirection = 'column';
                popup.style.alignItems = 'center';
                popup.style.justifyContent = 'center';
                popup.style.width = '90vw';        // Responsive width
                popup.style.maxWidth = '600px';    // Maximum width
                popup.style.minWidth = '220px';    // Minimum width for usability
                popup.style.maxHeight = '90vh';    // Responsive height
                //popup.style.overflowY = 'auto';    // Enable vertical scroll if needed
                document.body.appendChild(popup);
            }

            // Clear popup content
            popup.innerHTML = '';

            // Add text
            const textDiv = document.createElement('div');
            textDiv.innerHTML = text.replace(/\n/g, '<br>');
            popup.appendChild(textDiv);

            // Add or update progress bar
            if (bar) {
                let progressBar = document.getElementById('progressBar');
                let progressFill = document.getElementById('progressFill');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.id = 'progressBar';
                    progressBar.style.width = '100%';
                    progressBar.style.height = '20px';
                    progressBar.style.backgroundColor = '#444';
                    progressBar.style.borderRadius = '10px';
                    progressBar.style.marginTop = '10px';

                    progressFill = document.createElement('div');
                    progressFill.id = 'progressFill';
                    progressFill.style.height = '100%';

                    const B255 = (Math.min(per/100*255, 255) / 255) ** 1.5 * 255;
                    progressFill.style.backgroundColor = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                    progressFill.style.borderRadius = '10px';

                    progressBar.appendChild(progressFill);
                    popup.appendChild(progressBar);
                }
                // Always update width
                progressFill.style.width = `${per || 0}%`;
            }

            // Remove any fixed height so it grows/shrinks automatically
            popup.style.height = '';

            popup.style.display = block && text ? 'block' : 'none';
        }

        async function processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer) {
            await new Promise(resolve => setTimeout(resolve, 20));
            if (iterations >= 2) {
                if (iterations == 69) {
                    showProcessPOP_UP(`nice, 1/${iterations}`, true, true, 1 / iterations * 100);
                } else {
                    showProcessPOP_UP(`Processing... this will take a while (website is frozen so you can do anything until it\'s done) \n1/${iterations} iterations`, true, true, 1 / iterations * 100);
                }
            } else {
                showProcessPOP_UP('Processing... this will take a while (website is frozen so you can do anything until it\'s done)', true);
            }
            for (let i = 0; i < iterations; i++) {
                
                if (iterations >= 2) {
                    if (iterations == 69) {
                        showProcessPOP_UP(`nice, ${i + 1}/${iterations}`, true, true, (i + 1) / iterations * 100);
                    } else {
                        showProcessPOP_UP(`Processing... this will take a while (website is frozen so you can do anything until it\'s done) \n${i + 1}/${iterations} iterations`, true, true, i / iterations * 100);
                    }
                } else {
                    showProcessPOP_UP('Processing... this will take a while (website is frozen so you can do anything until it\'s done)', true);
                }

                // Pause for 10ms (adjust as needed)
                await new Promise(resolve => setTimeout(resolve, 10));

                if (Vmode==0){
                    // Apply the provided logic to process the audio
                    processedBuffer = applyFFTLogic(
                        offlineContext,
                        inputLeft,
                        inputRight,
                        carrierLeft,
                        carrierRight,
                        buffer.sampleRate
                    );

                    // Use the processed buffer as the new carrier for the next iteration
                    carrierLeft = processedBuffer.getChannelData(0);
                    carrierRight = processedBuffer.numberOfChannels > 1
                        ? processedBuffer.getChannelData(1)
                        : processedBuffer.getChannelData(0);
                } else if (Vmode==1) {
                    // Analog mode processing logic
                    processedBuffer = applyAnalogLogic(
                        offlineContext,
                        inputLeft,
                        inputRight,
                        carrierLeft,
                        carrierRight,
                        buffer.sampleRate
                    );

                    // Use the processed buffer as the new carrier for the next iteration
                    carrierLeft = processedBuffer.getChannelData(0);
                    carrierRight = processedBuffer.numberOfChannels > 1
                        ? processedBuffer.getChannelData(1)
                        : processedBuffer.getChannelData(0);
                }
            }
            // Hide popup when done
            showProcessPOP_UP('', false);
        }

        function processAudio(buffer) {
            if (!loadedCarrierBuffer) {
                alert('Please select a carrier audio file.');
                return;
            }
            if (!loadedAudioBuffer) {
                alert('Please select a Modular audio file.');
                return;
            }

            // Get the number of iterations
            const iterations = parseInt(document.getElementById('iterations').value);
            if (iterations < 1) {
                alert('Please enter a valid number of iterations.');
                return;
            }
            
            // Create looped version of input to match the carrier length
            const carrierDuration = loadedCarrierBuffer.length / loadedCarrierBuffer.sampleRate;
            const targetLength = Math.ceil(carrierDuration * buffer.sampleRate);
            buffer = createLoopedBuffer(buffer, targetLength);

            // Set up analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Float32Array(bufferLength);

            // Create a buffer source for the original audio
            source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Perform FFT and reconstruct audio using the provided logic
            const offlineContext = new OfflineAudioContext(2, buffer.length, buffer.sampleRate); // Stereo
            let offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = buffer;

            const offlineAnalyser = offlineContext.createAnalyser();
            offlineAnalyser.fftSize = 2048;
            const offlineFrequencyData = new Uint8Array(offlineAnalyser.frequencyBinCount);

            offlineSource.connect(offlineAnalyser);
            offlineAnalyser.connect(offlineContext.destination);

            offlineSource.start();
            offlineContext.startRendering().then(function(renderedBuffer) {
                let inputLeft = buffer.getChannelData(0);
                let inputRight = buffer.numberOfChannels > 1 ? buffer.getChannelData(1) : buffer.getChannelData(0);
                let carrierLeft = loadedCarrierBuffer.getChannelData(0);
                let carrierRight = loadedCarrierBuffer.numberOfChannels > 1 ? loadedCarrierBuffer.getChannelData(1) : loadedCarrierBuffer.getChannelData(0);

                processAudioIterations(iterations, offlineContext, inputLeft, inputRight, carrierLeft, carrierRight, buffer);

                // Enable buttons
                document.getElementById('playButton').disabled = false;
                document.getElementById('pauseButton').disabled = false;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('reprocessButton').disabled = false;

                // Visualize the sine wave volumes
                visualize(offlineAnalyser, offlineFrequencyData);

                // Hide processing indicator
                showProcessPOP_UP('', false);
            });
        }

        /**
         * Visualize the frequency response of the analog filters based on current analog control properties.
         * Draws the response on the #filterView canvas.
         */


        const clamp=(minn,maxx,value)=>Math.min(Math.max(value,minn),maxx)

        function studyAnalogFilters() {
            let z2S=[{lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0}]
            let z3S=[{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}]
            let z4S=[{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}]
            let z8S=[{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}]

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2S[callCount]) {
                    z2S[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2S[callCount].lp6 += cc * (f - z2S[callCount].lp6 + fbv * (z2S[callCount].lp6 - z2S[callCount].lp12));
                z2S[callCount].lp12 += cc * (z2S[callCount].lp6 - z2S[callCount].lp12);
                z2S[callCount].lp18 += cc * (z2S[callCount].lp12 - z2S[callCount].lp18);
                z2S[callCount].lp24 += cc * (z2S[callCount].lp18 - z2S[callCount].lp24);
                z2S[callCount].lp30 += cc * (z2S[callCount].lp24 - z2S[callCount].lp30);
                z2S[callCount].lp36 += cc * (z2S[callCount].lp30 - z2S[callCount].lp36);
                z2S[callCount].lp42 += cc * (z2S[callCount].lp36 - z2S[callCount].lp42);
                z2S[callCount].lp48 += cc * (z2S[callCount].lp42 - z2S[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2S[callCount].lp6;
                    case 2:  return z2S[callCount].lp12;
                    case 3:  return z2S[callCount].lp18;
                    case 4:  return z2S[callCount].lp24;
                    case 5:  return z2S[callCount].lp30;
                    case 6:  return z2S[callCount].lp36;
                    case 7:  return z2S[callCount].lp42;
                    case 8:  return z2S[callCount].lp48;
                    default: return z2S[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3S[callCount]) {
                    z3S[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.99, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3S[callCount].hp6 += cc * (f - z3S[callCount].hp6 + fbv * (z3S[callCount].hp6 - z3S[callCount].hp12));
                z3S[callCount].hp12 += cc * (z3S[callCount].hp6 - z3S[callCount].hp12);
                x = f - ((dbv >= 2) ? z3S[callCount].hp12 : z3S[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3S[callCount].hp18 += cc * (x - z3S[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3S[callCount].hp24 += cc * (x - z3S[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3S[callCount].hp30 += cc * (x - z3S[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3S[callCount].hp36 += cc * (x - z3S[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3S[callCount].hp42 += cc * (x - z3S[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3S[callCount].hp48 += cc * (x - z3S[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16;
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.5, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (callCount >= z4S.length) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4S[callCount].bp1 += cc * (f - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2));
                    z4S[callCount].bp2 += cc * (z4S[callCount].bp1 - z4S[callCount].bp2);
                    z4S[callCount].bp3 += cc * (z4S[callCount].bp2 - z4S[callCount].bp3);
                    z4S[callCount].bp4 += cc * (z4S[callCount].bp3 - z4S[callCount].bp4);
                    z4S[callCount].bp5 += cc * (z4S[callCount].bp4 - z4S[callCount].bp5);
                    z4S[callCount].bp6 += cc * (z4S[callCount].bp5 - z4S[callCount].bp6);
                    z4S[callCount].bp7 += cc * (z4S[callCount].bp6 - z4S[callCount].bp7);
                    z4S[callCount].bp8 += cc * (z4S[callCount].bp7 - z4S[callCount].bp8);
                    z4S[callCount].bp9 += cc * (z4S[callCount].bp8 - z4S[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4S[callCount].bp1 - z4S[callCount].bp2; break;
                        case 2: out = z4S[callCount].bp2 - z4S[callCount].bp3; break;
                        case 3: out = z4S[callCount].bp3 - z4S[callCount].bp4; break;
                        case 4: out = z4S[callCount].bp4 - z4S[callCount].bp5; break;
                        case 5: out = z4S[callCount].bp5 - z4S[callCount].bp6; break;
                        case 6: out = z4S[callCount].bp6 - z4S[callCount].bp7; break;
                        case 7: out = z4S[callCount].bp7 - z4S[callCount].bp8; break;
                        case 8: out = z4S[callCount].bp8 - z4S[callCount].bp9; break;
                        default: out = z4S[callCount].bp2 - z4S[callCount].bp3;
                    }

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w=1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4S[callCount].bp3 += clamp(-1, 1, f - z4S[callCount].bp3) * cc;
                            z4S[callCount].bp1 += clamp(-1, 1, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4S[callCount].bp3 += clamp(-cc, cc, f - z4S[callCount].bp3);
                            z4S[callCount].bp1 += clamp(-cc, cc, (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)));
                            break;
                    }
                    z4S[callCount].bp2 += clamp(-1, 1, z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    if (!z4S[callCount]) {
                        z4S.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;

                    //z4S[callCount].bp3 += (f - z4S[callCount].bp3) * cc * (4 + cc * 1) / 5;
                    z4S[callCount].bp1 += (f - z4S[callCount].bp3 - z4S[callCount].bp1 + fb * (z4S[callCount].bp1 - z4S[callCount].bp2)) * cc;
                    z4S[callCount].bp2 += (z4S[callCount].bp1 - z4S[callCount].bp2) * cc;

                    out = z4S[callCount].bp1 - z4S[callCount].bp2;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/32;
            }

            const canvas = document.getElementById('filterView');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get analog control values
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const resonance = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const bpwidth = parseFloat(document.getElementById('BPwidth').value);
            const altBP = parseInt(document.getElementById('Alt_BP').value) || 0;

            // Frequency range (log scale)
            const minFreq = 20, maxFreq = 20000;
            const sampleRate = 44100;
            const points = canvas.width;
            let testInput = 0;

            // Prepare for drawing
            ctx.save();
            ctx.strokeStyle = "#4af";
            ctx.lineWidth = 2;
            ctx.beginPath();

            // For each frequency, compute filter response
            // Smoothing window size (must be odd)
            const SMOOTH_WINDOW = 9;
            const halfWindow = Math.floor(SMOOTH_WINDOW / 2);
            const dbVals = [];

            // First, calculate all dB values (unsmoothed)
            for (let x = 0; x < points; x++) {
                // Logarithmic frequency mapping
                const freq = minFreq * Math.pow(maxFreq / minFreq, x / (points - 1));
                const FLTcutoff = .1;

                // Reset filter state for each frequency
                let z2S = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
                let z3S = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
                let z4S = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
                let z8S = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
                //console.log(altBP)

                // Sine wave test: run for several cycles and measure output amplitude
                const cycles = 1;
                const samplesPerCycle = Math.round(sampleRate / freq);
                const totalSamples = cycles * samplesPerCycle;
                let maxOut = 0;

                for (let t = 0; t < totalSamples; t++) {
                    const testInput = Math.sin(2 * Math.PI * freq * t / sampleRate);
                    let out = 0;
                    
                    switch (altBP) {
                        case 0:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        case 1:
                            out = bp2(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 2:
                            out = bp3(testInput*4, FLTcutoff, resonance, db, 0);
                            break;
                        case 3:
                            out = bp4(testInput, FLTcutoff, resonance, db, 0);
                            break;
                        case 4:
                            out = bp5(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                        default:
                            out = bp(testInput, FLTcutoff, resonance, db, bpwidth, 0);
                            break;
                    }
                    // Use peak amplitude (or accumulate RMS if you prefer)
                    if (t > totalSamples - samplesPerCycle) { // Only last cycle for steady-state
                        maxOut = Math.max(maxOut, Math.abs(out));
                    }
                }

                // Convert to dB
                let dbVal = 20 * Math.log10(maxOut + 1e-8);
                dbVals[x] = dbVal-20;   //it goes off grapth so i subtract it by 20
            }

            // Now, smooth the dB values using a moving average
            const smoothedDbVals = [];
            for (let x = 0; x < points; x++) {
                let sum = 0, count = 0;
                for (let k = -halfWindow; k <= halfWindow; k++) {
                    const idx = x + k;
                    if (idx >= 0 && idx < points) {
                        sum += dbVals[idx];
                        count++;
                    }
                }
                smoothedDbVals[x] = sum / count;
            }

            // Draw the smoothed graph
            for (let x = 0; x < points; x++) {
                // Normalize to canvas height (0 dB at 1/4 from top, -60 dB at bottom)
                const y = canvas.height * 0.25 + (canvas.height * 0.75) * (1 - (smoothedDbVals[x] + 60) / 60);

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            // Draw frequency grid
            ctx.save();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.font = "10px Arial";
            ctx.fillStyle = "#aaa";
            for (let f of [50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000]) {
                const x = Math.log(f / minFreq) / Math.log(maxFreq / minFreq) * (canvas.width - 1);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                ctx.fillText(f + "Hz", x + 2, canvas.height - 2);
            }
            ctx.restore();
        }

        // Draw on page load
        document.addEventListener('DOMContentLoaded', studyAnalogFilters);

        function applyAnalogLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            // Helper functions and state
            const min = Math.min, max = Math.max, abs = Math.abs, pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, PI = Math.PI;
            const clamp = (minn, maxx, value) => min(max(value, minn), maxx);

            let z2 = [{lp6:0,lp12:0,lp18:0,lp24:0,lp30:0,lp36:0,lp42:0,lp48:0}];
            let z3 = [{hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0}];
            let z4 = [{bp1:0,bp2:0,bp3:0,bp4:0,bp5:0,bp6:0,bp7:0,bp8:0,bp9:0}];
            let z8 = [{pi:0,p1:0,p2:0,p3:0,p4:0,p5:0,p6:0,pi:0}];
            let z5 = [{var1:0}];

            function lp(d, c, r = 0, dbv = 2, callCount) {
                if (!z2[callCount]) {
                    z2[callCount] = {lp6:0, lp12:0, lp18:0, lp24:0, lp30:0, lp36:0, lp42:0, lp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = d;
                z2[callCount].lp6 += cc * (f - z2[callCount].lp6 + fbv * (z2[callCount].lp6 - z2[callCount].lp12));
                z2[callCount].lp12 += cc * (z2[callCount].lp6 - z2[callCount].lp12);
                z2[callCount].lp18 += cc * (z2[callCount].lp12 - z2[callCount].lp18);
                z2[callCount].lp24 += cc * (z2[callCount].lp18 - z2[callCount].lp24);
                z2[callCount].lp30 += cc * (z2[callCount].lp24 - z2[callCount].lp30);
                z2[callCount].lp36 += cc * (z2[callCount].lp30 - z2[callCount].lp36);
                z2[callCount].lp42 += cc * (z2[callCount].lp36 - z2[callCount].lp42);
                z2[callCount].lp48 += cc * (z2[callCount].lp42 - z2[callCount].lp48);
                switch (dbv) {
                    case 1:  return z2[callCount].lp6;
                    case 2:  return z2[callCount].lp12;
                    case 3:  return z2[callCount].lp18;
                    case 4:  return z2[callCount].lp24;
                    case 5:  return z2[callCount].lp30;
                    case 6:  return z2[callCount].lp36;
                    case 7:  return z2[callCount].lp42;
                    case 8:  return z2[callCount].lp48;
                    default: return z2[callCount].lp12;
                }
            }

            function hp(input, c, r = 0, dbv = 2, callCount) {
                if (!z3[callCount]) {
                    z3[callCount] = {hp6:0,hp12:0,hp18:0,hp24:0,hp30:0,hp36:0,hp42:0,hp48:0};
                }
                const cc = clamp(0, 0.9999, c);
                const fbv = r + r / (1 - cc);
                const f = input;
                let x = f;
                z3[callCount].hp6 += cc * (f - z3[callCount].hp6 + fbv * (z3[callCount].hp6 - z3[callCount].hp12));
                z3[callCount].hp12 += cc * (z3[callCount].hp6 - z3[callCount].hp12);
                x = f - ((dbv >= 2) ? z3[callCount].hp12 : z3[callCount].hp6);
                if (dbv === 1 || dbv === 2) return x;
                x = x - (z3[callCount].hp18 += cc * (x - z3[callCount].hp18)); if (dbv === 3) return x;
                x = x - (z3[callCount].hp24 += cc * (x - z3[callCount].hp24)); if (dbv === 4) return x;
                x = x - (z3[callCount].hp30 += cc * (x - z3[callCount].hp30)); if (dbv === 5) return x;
                x = x - (z3[callCount].hp36 += cc * (x - z3[callCount].hp36)); if (dbv === 6) return x;
                x = x - (z3[callCount].hp42 += cc * (x - z3[callCount].hp42)); if (dbv === 7) return x;
                x = x - (z3[callCount].hp48 += cc * (x - z3[callCount].hp48)); if (dbv === 8) return x;
                return x;
            }

            function bp(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = dd;

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww*6))/16;
            }

            function bp2(d, c, r = 0, db = 2, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);
                    z4[callCount].bp3 += cc * (z4[callCount].bp2 - z4[callCount].bp3);
                    z4[callCount].bp4 += cc * (z4[callCount].bp3 - z4[callCount].bp4);
                    z4[callCount].bp5 += cc * (z4[callCount].bp4 - z4[callCount].bp5);
                    z4[callCount].bp6 += cc * (z4[callCount].bp5 - z4[callCount].bp6);
                    z4[callCount].bp7 += cc * (z4[callCount].bp6 - z4[callCount].bp7);
                    z4[callCount].bp8 += cc * (z4[callCount].bp7 - z4[callCount].bp8);
                    z4[callCount].bp9 += cc * (z4[callCount].bp8 - z4[callCount].bp9);

                    let out;
                    switch (db) {
                        case 1: out = z4[callCount].bp1 - z4[callCount].bp2; break;
                        case 2: out = z4[callCount].bp2 - z4[callCount].bp3; break;
                        case 3: out = z4[callCount].bp3 - z4[callCount].bp4; break;
                        case 4: out = z4[callCount].bp4 - z4[callCount].bp5; break;
                        case 5: out = z4[callCount].bp5 - z4[callCount].bp6; break;
                        case 6: out = z4[callCount].bp6 - z4[callCount].bp7; break;
                        case 7: out = z4[callCount].bp7 - z4[callCount].bp8; break;
                        case 8: out = z4[callCount].bp8 - z4[callCount].bp9; break;
                        default: out = z4[callCount].bp2 - z4[callCount].bp3;
                    }

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp3(d, c, r = 0, w = 1,callCount) {
                try {
                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0, bp4: 0, bp5: 0, bp6: 0, bp7: 0, bp8: 0, bp9: 0 });
                    }
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0, 0.9999, c);
                    const fb = r + r / (1 - cc);
                    const f = d;
                    let out = 0;
                    w = clamp(1, 2, w);

                    switch (w) {
                        case 1:
                            z4[callCount].bp3 += clamp(-1, 1, f - z4[callCount].bp3) * cc;
                            z4[callCount].bp1 += clamp(-1, 1, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2))) * cc;
                            break;
                        case 2:
                            z4[callCount].bp3 += clamp(-cc, cc, f - z4[callCount].bp3);
                            z4[callCount].bp1 += clamp(-cc, cc, (f - z4[callCount].bp3 - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2)));
                            break;
                    }
                    z4[callCount].bp2 += clamp(-1, 1, z4[callCount].bp1 - z4[callCount].bp2) * cc;

                    out = z4[callCount].bp1;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp4(d, c, r = 0, w = 1, callCount) {
                try {
                    const clamp = (minn, maxx, value) => Math.min(Math.max(value, minn), maxx);
                    const cc = clamp(0.001, 0.9999, c);
                    const fb = r + r / (1.0 - cc)
                    const f = d;

                    if (!z4[callCount]) {
                        z4.push({ bp1: 0, bp2: 0, bp3: 0});
                    }

                    z4[callCount].bp1 += cc * (f - z4[callCount].bp1 + fb * (z4[callCount].bp1 - z4[callCount].bp2));
                    z4[callCount].bp2 += cc * (z4[callCount].bp1 - z4[callCount].bp2);

                    let out=0;
                    out = z4[callCount].bp1 - z4[callCount].bp2;

                    return out;
                } catch (e) {
                    return 0;
                }
            }

            function bp5(dd, c, r = 0, dbv = 2, dww = 0, call) {
                const d = bp4(dd, c, r, dbv, call);

                // Frequency spread
                const c1 = c * 2 ** (+dww);
                const c2 = c * 2 ** (-dww);
                const rl = c1>0.9999?0:r;

                // Filter chain
                const low = lp(d, c1, rl, dbv, call);
                const high = hp(low, c2, r, dbv, call);

                // === Shape-based gain adjustment ===
                const norm = dbv / 8;
                const power = 2 + 2 * (1 - dww);
                const mult = 10 * 2 ** (4 * (1 - dww));
                const shapeFactor = 1 + norm ** power * mult;

                return (high * shapeFactor * (1+dww) * (2**(dww*3-1)))/32;
            }

            // UI values
            const sel = parseInt(document.getElementById('decayType').value)-1;
            const rel = parseFloat(document.getElementById('release').value);
            const fb = parseFloat(document.getElementById('Resonance').value);
            const db = parseInt(document.getElementById('DBperOct').value);
            const dw = parseFloat(document.getElementById('BPwidth').value);
            const vol = parseFloat(document.getElementById('Volboost').value);
            const n = parseInt(document.getElementById('TotalBands').value) || 40;
            const flip = document.getElementById('FreqFlip').checked;
            const pitch = parseFloat(document.getElementById('pitch').value);

            // Envelope followers
            function peak(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = Math.max(abs(a), z5[call].var1 - sqrt(decayF) / 2);
                return z5[call].var1 / 3;
            }
            function rms(a, decayF, call) {
                z5[call] ??= { var1: 0 };
                z5[call].var1 = (1 - decayF) * z5[call].var1 + decayF * a * a;
                return sqrt(z5[call].var1);
            }
            
            let modulatedValue = 1
            const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
            const duration = inputLeft.length / sampleRate;
            // Vocoder function
            function vocoder(inp, car) {
                let relv = rel, nv = n, volv = vol, fbv = fb, dbv = db, dww = dw, selv = sel;
                let dd = 0.025 / pow(1 - fbv, 0.83362376);
                let p = [rms, peak][max(min(selv, 2), 0)];
                let result = 0;
                let carrierSum = 0, modSum = 0;
                const Alt_BP=parseInt(document.getElementById('Alt_BP').value) || 0;

                for (let i = 1; i <= nv; i++) {

                    const g = i / nv * 2**(pitch/12);
                    // Filter input (modulator) and carrier
                    const filter = (v, m, f = 0, dwo) => {
                        switch (Alt_BP) {
                            case 0:
                                return bp(v * 64, (f ? 1 - g : g), fbv, dbv, dwo, m);
                            case 1:
                                return bp2(v * 64, (f ? 1 - g : g), fbv, dbv, m);
                            case 2:
                                return bp3(v * 256, (f ? 1 - g : g), fbv, dbv, m);
                            case 3:
                                return bp4(v * 64, (f ? 1 - g : g), fbv, dbv, m);
                            case 4:
                                return bp5(v * 64, (f ? 1 - g : g), fbv, dbv, dwo, m);
                            default:
                                return bp(v * 64, (f ? 1 - g : g), fbv, dbv, dwo, m);
                        } 
                    };
                    const modFiltered = filter(inp, i, flip, dww);
                    const carFiltered = filter(car, i + n, false, dww);

                    const absFilterX = abs(modFiltered);
                    const mod = p(absFilterX, 2**-((rel*3)**2)/800, i);

                    // For debugging: sum up mod and carrier
                    //modSum += mod;
                    //carrierSum += carFiltered;

                    // If mod is always zero, you will only hear silence or the modular
                    const combined = mod * carFiltered * (1 - fbv) / sqrt(nv * 10) * (1 - g);
                    result += combined * volv*8;

                    //console.log(result, mod, carFiltered, combined, inp, car, i, nv, modulatedValue);
                }

                // Prevent NaN/Infinity
                if (!isFinite(result) || isNaN(result)) result = 0;
                return result / 128;
            }

            // Output buffer
            const bufferLen = inputLeft.length;
            const outputBuffer = context.createBuffer(2, bufferLen, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);
            // Analog vocoder processing
            for (let idx = 0; idx < bufferLen; idx++) {
                const idxL = idx % carrierLeft.length;
                const idxR = idx % carrierRight.length;
                outputLeft[idx] = vocoder(carrierLeft[idxL], inputLeft[idx]);
                outputRight[idx] = vocoder(carrierRight[idxR], inputRight[idx]);
            }

            return outputBuffer;
        }

        function applyFFTLogic(context, inputLeft, inputRight, carrierLeft, carrierRight, sampleRate) {
            const FFTsize = document.getElementById('FFTsize').value;
            const SIZE = 2 ** FFTsize;
            const OVERLAP = 4;
            const HOP_SIZE = SIZE / OVERLAP;
            const PI = Math.PI;
            const cos = Math.cos;
            const sin = Math.sin;
            const asin = Math.asin;
            const abs = Math.abs;

            const X = o => {
                switch (parseInt(document.getElementById('BR_voc_Type').value)) {
                    default:
                        return { r: cos(o), i: sin(o) }
                    case 1:
                        return { r: asin(cos(o)) / PI * 2.25, i: asin(sin(o)) / PI * 2.25 };
                    case 2:
                        return { r: sin(cos(o) * 2) * .9 , i: sin(sin(o) * 2) * .9};
                    case 3:
                        return { r: cos(o * 2) * .9, i: sin(o * 2) * .9};
                    case 4:
                        return { r: cos(o * 3) * .8, i: sin(o * 3) * .8}
                    case 5:
                        return { r: o / PI + PI / 4 & 1 ? 0.65 : -0.65, i: o / PI & 1 ? 0.65 : -0.65 }
                    case 6:
                        return { r: ((o / PI + PI / 4) % 2 - 1)/1.4 , i: ((o / PI)% 2 - 1) / 1.4 }
                    case 7:
                        return { r: sin(sin(cos(o) * 2) * 2) * .8 , i: sin(sin(sin(o) * 2) * 2) * .8}
                    case 8:
                        return { r: cos(o / 2) * 0.9, i: sin(o / 2) * 0.9}
                    case 9:
                        return { r: cos(o ** 2) * 0.95, i: sin(o ** 2) * 0.95 }
                    case 10:
                        return { r: cos(o) ** 2, i: sin(o) ** 2 }
                    case 11:
                        return { r: (-abs(cos(o / 2)) + 0.5) * 1.7, i: (-abs(sin(o / 2)) + 0.5) * 1.7}
                    case 12:
                        return { r: (abs(sin(o / 2 + PI / 2) ** 3) - 0.5) * 1.8, i: (abs(sin(o / 2 + PI / 4) ** 3) - 0.5) * 1.8 } // i genuinely have no idea what this is
                    case 13:
                        return { r: cos(rand(o/1e10)*PI)*.9, i: sin(rand(o/1e10)*PI)*.9 }
                    case 14:
                        return { r: cos(o) ** 3 * 1.15, i: sin(o) ** 3 * 1.15 }
                    case 15:
                        return { r: cos(o*cos(o)), i: sin(o*sin(o))/2 }
                    case 16:
                        return { r: harm(o+PI/2) * 0.8, i: harm(o) * 0.8 }
                    case 17:
                        return { r: harmS(o+PI/2) * 0.9, i: harmS(o) * 0.9 }
                    case 18:
                        return { r: cos((o*128/PI&o*127/PI)/128*PI), i: sin((o*128/PI|o*127/PI)/128*PI) }
                    case 19:
                        return { r: cos((o*4/PI|0)/4*PI), i: sin((o*4/PI|0)/4*PI) }
                }
            };
            const X2 = o => ({ r: cos(o), i: sin(o) }); //back up
            const M = (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + b.r * a.i });
            const A = (a, b) => ({ r: a.r + b.r, i: a.i + b.i });

            const FFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = { r: I[ii], i: 0 };
                else {
                    FFT(O, I, oi, ii, N / 2, s * 2);
                    FFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(-2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            const IFFT = (O, I, oi, ii, N, s) => {
                if (N == 1) O[oi] = I[ii];
                else {
                    IFFT(O, I, oi, ii, N / 2, s * 2);
                    IFFT(O, I, oi + N / 2, ii + s, N / 2, s * 2);
                    for (let j = 0; j < N / 2; ++j) {
                        let T = M(X(2 * PI / N * j), O[oi + j + N / 2]);
                        O[oi + j + N / 2] = A(O[oi + j], M(T, { r: -1, i: 0 }));
                        O[oi + j] = A(O[oi + j], T);
                    }
                }
            };

            // Calculate the duration of the audio buffer
            const duration = inputLeft.length / sampleRate;

            // Create output buffer (stereo)
            const outputBuffer = context.createBuffer(2, inputLeft.length, sampleRate);
            const outputLeft = outputBuffer.getChannelData(0);
            const outputRight = outputBuffer.getChannelData(1);

            // Initialize buffers
            const I = Array.from({ length: SIZE }, () => 0);
            const O = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));
            const I2 = Array.from({ length: SIZE }, () => 0);
            const O2 = Array.from({ length: SIZE }, () => ({ r: 0, i: 0 }));

            const pitch = parseInt(document.getElementById('pitch').value);
            const Shift = parseInt(document.getElementById('BandShift').value)
            const divbands = parseInt(document.getElementById('divbands').value);

            const DecayType = parseInt(document.getElementById('decayType').value);
            const Release = parseFloat(document.getElementById('release').value) ** (1 / (4 + (divbands - 1) * 2));
            const BassBoost = parseFloat(document.getElementById('BassBoost').value);

            const envelopeStateLeft = Array(SIZE).fill(0);
            const envelopeStateRight = Array(SIZE).fill(0);

            const window = Array.from({ length: SIZE }, (_, i) =>
                0.5 * (1 - Math.cos(2 * Math.PI * i / (SIZE - 1)))
            );

            const clampOut = parseFloat(document.getElementById('clamp_output').value);
            const Threshold = parseFloat(document.getElementById('threshold').value);

            // Process left and right channels separately
            const processChannel = (inputData, carrierData, outputData, envelopeState) => {
                const startTime = performance.now();
                const Break = document.getElementById('BandBreak').checked;
                const flip = document.getElementById('FreqFlip').checked

                for (let t = 0; t < inputData.length; t += HOP_SIZE) {
                    const currentTime = (performance.now() - startTime) / 1000; // Current time in seconds

                    // Fill input buffer for input data with windowing
                    for (let i = 0; i < SIZE; i++) {
                        I[i] = (inputData[t + i] || 0) * window[i];
                        I2[i] = (carrierData[t + i] || 0) * window[i];
                    }

                    // Perform FFT on input data
                    FFT(O, I, 0, 0, SIZE, 1);

                    // Perform FFT on carrier data
                    FFT(O2, I2, 0, 0, SIZE, 1);

                    // Modulate frequency components
                    for (let i = 0; i < SIZE; i++) {
                        let timer = currentTime; // Timer value between 0 and 1
                        const speedType = parseInt(document.getElementById('speedType').value)

                        switch (speedType) {
                            case 0:
                                timer = currentTime / 8;
                                break;
                            case 1:
                                timer = currentTime / duration;
                                break;
                            case 2:
                                timer = currentTime * parseFloat(document.getElementById('userSpeed').value);
                                break;
                        }

                        // Apply envelope following
                        let envelope = 0;
                        const mag1 = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                        let mag2 = 0;
                        let ip = 0;
                        let ip_ = 0;
                        const Ratio = (SIZE / 1024);

                        let callCount = 0;

                        const lin = (a, b, t) => a * (1 - t) + b * t;

                        // divide bands
                        for (let j = 0; j <= divbands; j++) {
                            ip = (i * 2 ** (-pitch / 12) | 0);
                            const weight = 1 - abs(j - divbands / 2) / divbands;
                            
                            ip_ = Math.round(ip + (j - divbands / 2) + Shift);

                            if (flip) {
                                ip_=Math.round(SIZE/16-ip_)
                            }

                            if (ip_ >= 0 && ip_ < SIZE && O2[ip_]) {
                                mag2 += Math.sqrt(O2[ip_].r * O2[ip_].r + O2[ip_].i * O2[ip_].i) * weight;
                            } else {
                                mag2 += 0;
                            }

                            const REL = Math.min((1 - Release) * Ratio, 1);

                            switch (DecayType) {
                                case 1: // RMS
                                    envelopeState[i] = (1 - REL) * envelopeState[i] + REL * mag2 * mag2;
                                    envelope += Math.sqrt(envelopeState[i]);
                                    break;
                                case 2: // Peak
                                    envelopeState[i] = Math.max(mag2, envelopeState[i] * (1 - REL));
                                    envelope += envelopeState[i];
                                    break;
                            }
                            // somehow (1 + 2 / divbands / 2) solved the volume issue
                            envelope /= divbands * ((1 + 2 / divbands) / 2);
                        }

                        // Apply modulation with normalization and volume with BassBoost
                        const BassCurveType = parseInt(document.getElementById('BassCurve').value);
                        const normEQcurveType = parseInt(document.getElementById('EQType').value);

                        let BassCurve = 0;
                        switch (BassCurveType) {
                            case 0:
                                BassCurve = 1;
                                break;
                            case 1:
                                BassCurve = 10 / (i + 1);
                                break;
                            case 2:
                                BassCurve = ((1 - i / SIZE) ** 2);
                                break;
                        }

                        let normEQcurve = 0;
                        switch (normEQcurveType) {
                            case 0:
                                normEQcurve = Math.min(1, (i < SIZE / 2 ? i : SIZE - i) / (SIZE / 4));
                                break;
                            case 1:
                                normEQcurve = Math.sin(i / SIZE * PI);
                                break;
                        }

                        // Example calculation using the timer
                        let modulatedValue = 1
                        const simpleChorus = parseInt(document.getElementById('simpleChorus').value);
                        const modulatedInput = i*((timer*256|0)/256);

                        switch (simpleChorus) {
                            case 1:
                                modulatedValue = sin(modulatedInput*PI);
                                break;
                            case 2:
                                modulatedValue = cos(modulatedInput*PI);
                                break;
                            case 3:
                                modulatedValue = asin(sin(modulatedInput*PI));
                                break;
                            case 4:
                                modulatedValue = asin(cos(modulatedInput*PI));
                                break;
                        }

                        soundgoodizer = parseFloat(document.getElementById('SoundGoodizer').value);
                        const normEQ = (normEQcurve + BassBoost * BassCurve / (Math.sqrt(Ratio)*1024) * 20) * modulatedValue * lin(1, ((i/SIZE)**150*15+((i/SIZE)**150-1)*2-sin(i/SIZE*PI)*4)/2, soundgoodizer)

                        // Apply modulation based on BR_out value
                        switch (parseInt(document.getElementById('BR_out').value)) {
                            case 1:
                                O[i] = M(O[i], X(2 * PI * i / SIZE));
                                O2[i] = M(O2[i], X(2 * PI * i / SIZE));
                                break;
                            case 3:
                                O[i] = M(O[i], X2(2 * PI * i / SIZE));
                                break;
                            case 2:
                                O2[i] = M(O2[i], X2(2 * PI * i / SIZE));
                                break;
                        }

                        const volume = document.getElementById('volume').value / Math.sqrt(Ratio);

                        const steps = parseFloat(document.getElementById('steps').value);
                        const RoundType = [Math.floor, Math.round, Math.ceil][parseInt(document.getElementById('RoundType').value)];
                        envelope = steps ? RoundType(envelope * (steps / 16)) / (steps / 16) : envelope;

                        O[i].r *= envelope * volume * normEQ;
                        O[i].i *= envelope * volume * normEQ;

                        if (clampOut == 2) {
                            O[i].r = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].r));
                            O[i].i = Math.min(4 * Ratio * Threshold, Math.max(-4 * Ratio * Threshold, O[i].i));
                        }
                    }

                    let frequencyMagnitudes = Array(SIZE).fill(0);
                    if (clampOut == 4) {
                        for (let i = 0; i < SIZE; i++) {
                            const ratio = 2; // Compression ratio

                            // Calculate the magnitude of the frequency component
                            const magni = Math.sqrt(O[i].r * O[i].r + O[i].i * O[i].i);
                            frequencyMagnitudes[i] = Math.sqrt((frequencyMagnitudes[i] ** 2 * 24 + magni ** 2) / 25);
                            let level = frequencyMagnitudes[i];

                            let gain = Math.min(1, (Threshold / level) ** (ratio - 1)); // Compute gain reduction

                            O[i].r *= gain;
                            O[i].i *= gain;
                        }
                    }

                    if (Break) {
                        // Reverse the second half of the spectrum
                        for (let i = 1; i < SIZE / 2; i++) {
                            let tmp = O[i];
                            O[i] = O[SIZE - i];
                            O[SIZE - i] = tmp;
                        }
                        // discard the second half of the spectrum
                        for (let i = SIZE / 2; i < SIZE; i++) {
                            O[i].r = 0;
                            O[i].i = 0;
                        }
                    }

                    // Perform IFFT
                    IFFT(I, O, 0, 0, SIZE, 1);

                    // Overlap-add with windowing
                    for (let i = 0; i < SIZE; i++) {
                        const inputt =  outputData[t + i] + I[i].r / SIZE * window[i];
                        if (clampOut == 1) {
                            outputData[t + i] = Math.min(Threshold, Math.max(-Threshold, inputt));
                        } else {
                            outputData[t + i] += (I[i].r / SIZE) * window[i];
                        }
                    }
                }
            };

            // Process left channel
            processChannel(inputLeft, carrierLeft, outputLeft, envelopeStateLeft);

            // Process right channel
            processChannel(inputRight, carrierRight, outputRight, envelopeStateRight);

            return outputBuffer;
        }

        function visualize(analyser, dataArray) {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;

            function draw() {
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i];
                const B255 = (Math.min(barHeight, 255) / 255) ** 1.5 * 255;
                ctx.fillStyle = `rgb(${Math.min(B255 * 2, 255)}, 0, ${Math.min((256 - B255) * 2, 255)})`;
                ctx.fillRect(x, canvas.height - barHeight * 1.56, barWidth, barHeight * 1.56);

                x += barWidth + 1;
            }

            requestAnimationFrame(draw);
            }

            draw();
        }

        document.getElementById('playButton').addEventListener('click', function() {
            if (processedBuffer) {
                playbackSource = audioContext.createBufferSource();
                playbackSource.buffer = processedBuffer; // Play the processed buffer stored in RAM
                playbackSource.connect(audioContext.destination);

                // Set up a new analyser for playback visualization
                const playbackAnalyser = audioContext.createAnalyser();
                playbackAnalyser.fftSize = 2048;
                const playbackFrequencyData = new Uint8Array(playbackAnalyser.frequencyBinCount);

                playbackSource.connect(playbackAnalyser);
                playbackAnalyser.connect(audioContext.destination);

                // Visualize the playback audio
                visualize(playbackAnalyser, playbackFrequencyData);

                playbackSource.start();
            }
        });

        document.getElementById('pauseButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('stopButton').addEventListener('click', function() {
            if (playbackSource) {
                playbackSource.stop();
                playbackSource = null;
            }
        });

        document.getElementById('downloadButton').addEventListener('click', function() {
            const carrierName = document.getElementById('carrierInput').files[0].name.split('.').slice(0, -1).join('.');
            const modularName = document.getElementById('audioInput').files[0].name.split('.').slice(0, -1).join('.');
            if (processedBuffer) {
            const wavBuffer = bufferToWav(processedBuffer);
            const blob = new Blob([wavBuffer], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${carrierName} (${modularName}).wav`;
            a.click();
            URL.revokeObjectURL(url);
            }
        });

        function bufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = loadedCarrierBuffer.length * numOfChan * 2 + 44; // Use carrier buffer length
            const bufferArray = new ArrayBuffer(length);
            const view = new DataView(bufferArray);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, loadedCarrierBuffer.length * numOfChan * 2, true); // Use carrier buffer length

            // Write interleaved audio data
            let offset = 44;
            for (let i = 0; i < loadedCarrierBuffer.length; i++) { // Use carrier buffer length
                for (let channel = 0; channel < numOfChan; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
